{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>This site contains notes for the following courses:</p> <ul> <li> <p>PROGRAMMING FOR DATA MANAGEMENT &amp; ANALYSIS, sections:</p> <ul> <li>All Python 1 sections (except for JSON files)</li> <li>Pandas</li> <li>Matplotlib</li> <li>SQL (except for \"Window functions\")</li> <li>PySpark</li> </ul> </li> <li> <p>PYTHON FOR DATA ANALYSIS 1, sections:</p> <ul> <li>All Python 1 sections (except for sections in \"Other topics\")</li> <li>NumPy</li> <li>Pandas</li> <li>Matplotlib</li> </ul> </li> <li> <p>PYTHON FOR DATA ANALYSIS 2, sections: </p> <ul> <li>All Python 2 sections</li> </ul> </li> </ul> <p>taught by Gerard Conangla Planes.</p> <p>The notes cover almost all topics that are needed for the courses (and sometimes a bit more),  but there might be some gaps and typos. I will include more chapters in the notes as the semester advances.</p> <p>Note</p> <p>It is recommended to complement this notes with information from the rest of the bibliography,  the internet and, of course, a lot of practice doing exercises.</p>"},{"location":"#detecting-errors-in-the-notes","title":"Detecting errors in the notes","text":"<p>If you find any error, please write me at gconangla@faculty.ie.edu and I will try to fix it as fast as I can.</p>"},{"location":"sections/other/git/","title":"Git","text":"<p>Git is a free and open source software for distributed version control1. Git works by keeping track of changes in files, and it is very useful when working in teams, since it allows to merge changes from different people in the same file.</p> <p>Git is like a tree, where each node is a commit. Each commit has a parent commit, except for the first commit, which has no parent. </p> <p>Some basic git words that we will encounter often are:</p> <ul> <li>commit: a snapshot of the repository at a certain point in time. Each commit has a unique identifier (hash).</li> <li>branch: since git is like a tree, a branch is a line of commits.</li> <li>master: the default branch (lately, this is being considered a bad name, and it is recommended to use <code>main</code>  instead).</li> <li>develop: branch where we merge all the features that we are developing. When we are ready to release a new version, we merge <code>develop</code> into <code>master</code>.</li> <li>origin: the (default name of a) remote repository. This basically means the repository saved in GitHub,  Bitbucket, etc.</li> <li>merge: when we merge two branches, we take the changes from one branch and apply them to the other branch. After  the merge, the two branches will be the same.</li> <li>push: send changes from a local repository (your computer) to a remote repository (github, bitbucket, etc).</li> <li>pull: send changes from a remote repository to a local repository. We use this when we are working in a team, and we want to get the changes that other people have made to the remote repository into our local repository.</li> </ul>"},{"location":"sections/other/git/#installation","title":"Installation","text":"<p>To install git, follow the instructions here for  your operating system.</p>"},{"location":"sections/other/git/#configuration","title":"Configuration","text":"<p>After installing git, we should configure it with our name and email. This is important, since git will use this information to identify the author of each commit. To do so, we can use the following commands:</p> <pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"some_email@some_domain.com\"\n</code></pre>"},{"location":"sections/other/git/#creating-a-repository","title":"Creating a repository","text":"<p>To create a new repository, we should go to the folder where we want to create it, and use the command <code>git init</code>. This will create a new folder called <code>.git</code> in the current directory. This folder will contain all the information  about the repository (the folder should never be modified manually).</p>"},{"location":"sections/other/git/#gitignore","title":".gitignore","text":"<p>A <code>.gitignore</code> file is a text file that tells git which files or folders from our repository to ignore.  This is useful to avoid committing files that we don't want to share with other people, such as temporary files  or files with passwords.</p> <p>A .gitignore file should be placed in the root directory of our repository. We can create it manually. For example, if we want to ignore all files with extension <code>.csv</code> inside our folder <code>data</code>, we can write the following in our  <code>.gitignore</code> file:</p> <pre><code>data/*.csv\n</code></pre>"},{"location":"sections/other/git/#git-commands","title":"Git commands","text":""},{"location":"sections/other/git/#using-git-from-pycharm","title":"Using git from Pycharm","text":"<p>Pycharm has a built-in git client, which uses git commands under the hood in a graphical, friendly interface.  To use it, we should first create a new project from an existing repository.  Then, we can use the git menu on the bottom left of the IDE to check branches and perform other common git operations.</p> <p> </p> The git menu, displaying local and remote branches. <p>When we want to commit changes, we can use the commit menu on the top left of the IDE:</p> <p> </p> The commit menu, displaying files that have changed. <p>To create a new commit, we should first select the files that we want to commit, and then write a commit message:</p> <p> </p> Creating a new commit from the commit menu. <p>If there are no conflicts (i.e., if the files that we want to commit have not been modified by other people at the same place), then the commit will be created. Otherwise, we will have to solve the conflicts manually. In this case, Pycharm will show us the conflicts and allow us to solve them:</p> <p> </p> Pycharm showing us the conflicts in a file. <p>Note</p> <p>Other IDEs, such as VSCode, also have built-in git clients. For VSCode, see  here. </p>"},{"location":"sections/other/git/#basic-terminal-commands","title":"Basic terminal commands","text":"<p>We can also use git from the terminal. The most common commands are:</p> <ul> <li><code>git init</code>: when in a folder, initiate a (new) repository</li> <li><code>git clone /path/to/repository</code>: create a working copy of a repository. When the repository is in a remote server,  your command will be      <pre><code>git clone username@host:/path/to/repository\n</code></pre></li> <li><code>git add &lt;filename&gt;</code>: add files to the repository. </li> <li><code>git status</code>: indicates what files have changed since the last commit.</li> <li><code>git commit -m \"Commit message\"</code>: create a commit of the repository. The message should indicate what's new in  this commit.</li> <li><code>git fetch --all</code>: downloads commits, files, and refs from a remote repository into your local repo.  Fetching is what you do when you want to see what everybody else has been working on.</li> </ul>"},{"location":"sections/other/git/#branches-and-merging","title":"Branches and merging","text":"<ul> <li><code>git branch</code>: list all branches in a repository</li> <li><code>git branch branch_name</code>: create a new branch called branch_name</li> <li><code>git checkout branch_name</code>: switch to branch <code>branch_name</code> (which should already exist) </li> <li> <p><code>git merge branchname</code>: merges branchname to current branch. If there are conflicts, they will remain unmerged.      You can decide what to do case by case in your IDE. It's a good idea to delete the branch after, if you will not     work in it anymore.</p> <p>Note</p> <p>It is recommended to merge from the IDE (e.g. Pycharm), since it is easier to decide what to do in the case of merge conflicts. </p> </li> <li> <p><code>git pull</code>: update your local repository to the newest commit of the (remote) branch. This command is equivalent to   <code>git fetch</code> followed by <code>git merge</code>.</p> </li> <li><code>git push [origin/other_remote_name] [branch_name]</code>: send changes from last commit of local branch to <code>branch_name</code>     on your remote repository. If the local branch does not exist on the remote repository, we should use    <code>git push -u origin [branch_name]</code> (<code>-u</code> is short for <code>--set-upstream-to</code>).</li> <li><code>git remote add origin &lt;server&gt;</code>: connect your repository to a remote server. In \"server\" we would put the url of a     github repo, e.g. https://github.com/gerardpc/somerepo.git or <code>git@bitbucket.org:gerardpc/somerepo.git</code>.     To remove a remote repository, use <code>git remote rm &lt;remote-name&gt;</code>. To see the current remote repositories, use    <code>git remote -v</code>.</li> <li><code>git branch -d branchname</code>: delete a branch</li> <li><code>git branch -m new_name</code>: rename the current branch</li> </ul>"},{"location":"sections/other/git/#other-useful-tricks","title":"Other useful tricks","text":"<p>By default, github will ask you for your username and password every time you push changes to a repository. An alternative is the use of ssh keys, see the instructions here.</p> <ol> <li> <p>More info: http://rogerdudler.github.io/git-guide/ \u21a9</p> </li> </ol>"},{"location":"sections/python/classes/","title":"Classes and objects","text":""},{"location":"sections/python/classes/#classes-and-object-oriented-programming","title":"Classes and Object-Oriented-Programming","text":"<p>Objects and classes are a way to group up a bunch of function and variables into a single \"thing\". When you get  all the way down to it, this is simply a way of organizing everything into groups that make sense.  There are benefits down the road for making things easier to understand, debug, extend, or maintain, but  basically it is just a way to make code easy to understand and develop.</p> <p>This might sound very abstract, but in practice it is not: everything is an object in Python!  <code>int</code>, <code>dict</code>, <code>list</code>... etc. are all different types of objects.</p> <p>To be more precise, <code>int</code>, <code>dict</code>, <code>list</code>... are known as classes, and objects are particular instances of such classes. In the next example:  <pre><code>a = 2\n</code></pre> <code>int</code> would be the class, and <code>a</code> would be the object (or instance, they are used interchangeably). So,  in other words, classes are the blueprint from which objects are created.</p> <p>Note</p> <p>It is often helpful to make analogies of classes with animals: for instance, if <code>dog</code> is a class, then <code>Max = dog()</code> (one dog in particular) is the instance.</p> <p>Making use of classes in programming is what is known as Object-Oriented-Programming (OOP). OOP is highly  concerned with code organization, reusability, and encapsulation. OOP is partially in contrast to Functional  Programming, which is a different paradigm used a lot in Python. Not everyone who programs in Python  uses OOP. </p> <p>Note</p> <p>So, should we use functions or classes when programming? As a general rule of thumb, we can think of classes/objects  as nouns and functions/methods as verbs. In other words, functions do specific things, classes are  specific things. With a language like Python we are not forced to choose: we can use just a little bit of each, when it is most convenient.</p>"},{"location":"sections/python/classes/#defining-classes","title":"Defining classes","text":"<p>Python makes it very easy to define our own classes. A very basic class would look something like this:</p> <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\n</code></pre> <p>Note</p> <p>Variables in classes are also known as attributes, and functions in classes are also known as methods. These words are complete synonyms.</p> <p>We'll explain why you have to include that <code>self</code> as a parameter a little bit later.  First, to assign the above class to an object you would do the following:</p> <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\n</code></pre> <p>Now the variable <code>myobjectx</code> holds an object of the class <code>MyClass</code> that contains the variable  and the function defined within the class called <code>MyClass</code>. Accessing Object Variables</p>"},{"location":"sections/python/classes/#accessing-object-variables","title":"Accessing object variables","text":"<p>To access the variable inside the newly created object <code>myobjectx</code> you would do the following: <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nmyobjectx.variable\n</code></pre></p> <p>So for instance the below would output the string <code>blah</code>: <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nprint(myobjectx.variable)\n</code></pre></p> <p>You can create multiple different objects that are of the same class (i.e., have the same variables and functions  defined). However, each object contains independent copies of the variables defined in the class. For instance,  if we were to define another object with the <code>MyClass</code> class and then change the string in the variable above:</p> <p><pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nmyobjecty = MyClass()\nmyobjecty.variable = \"yackity\"\n# Then print out both values\nprint(myobjectx.variable)\nprint(myobjecty.variable)\n</code></pre> nothing would happen to the first object.</p>"},{"location":"sections/python/classes/#accessing-object-functions","title":"Accessing object functions","text":"<p>To access a function inside of an object you use notation similar to accessing a variable:</p> <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nmyobjectx.function()\n</code></pre> <p>The above would print out the message <code>This is a message inside the class.</code></p>"},{"location":"sections/python/classes/#the-meaning-of-self","title":"The meaning of <code>self</code>","text":"<p>The built-in <code>self</code> is used by a class to refer to a specific instantiation of the class. This is easier seen with an example. Consider this class:</p> <pre><code>class Dog:\ndef set_name(name):\ndog_name = name\n</code></pre> <p>and now compare it to:</p> <pre><code>class Dog:\ndef set_name(self, name):\nself.dog_name = name\n</code></pre> <p>The idea of the function <code>set_name</code> is clear: we want to give a name to our object of the class <code>Dog</code>. So, what's the difference between both cases? In the first case, we are defining <code>dog_name</code> inside of the  function <code>set_name</code>, but when we leave the function this \"inside\" variable disappears. Hence, the function has no effect.</p> <p>Note</p> <p>Actually, the first function would not work for reasons a bit more obscure, but that doesn't matter for now. See this  if you're interested in reading more aaa.</p> <p>What we want to do is access the particular dog instance, and set a name to that instance. This is the  purpose of <code>self</code>: it means \"our current instance\".</p>"},{"location":"sections/python/classes/#__init__-function","title":"<code>__init__()</code> function","text":"<p>The <code>__init__()</code> function is a special function that is called when the class is being instantiated.  <code>__init__</code> doesn't initialize a class, it initializes an instance of a class or an object. </p> <p>The difference between variables assigned inside the <code>__init__()</code> method versus variables assigned in the class definition is that in the first case we are only defining values for one particular instance, whereas if we define a value in the class definition, all objects from that class will have the same value. </p> <p>Note</p> <p>In other words, each dog has colour, but dogs as a class don't: hence the color for one particular dog should be defined inside the <code>__init__()</code> method. </p> <p>The class is a concept of an object. When you see Fido and Spot, you recognise their similarity,  their doghood. That's the class. However, when you say <pre><code>class Dog:\ndef __init__(self, legs, colour):\nself.legs = legs\nself.colour = colour\nfido = Dog(4, \"brown\")\nspot = Dog(3, \"mostly yellow\")\n</code></pre></p> <p>You're saying, Fido is a brown dog with 4 legs while Spot is a bit of a cripple and is mostly yellow. </p>"},{"location":"sections/python/classes/#class-inheritance","title":"Class inheritance","text":"<p>Inheritance is a mechanism that allows you to create a hierarchy of classes that share a set of  properties and methods by deriving a class from another class. This is extremely useful because it allows us to write less code thanks to code reuse.</p> <p>For instance, imagine that we need to define a class for a dogs and cats (and potentially many more). Instead of  writing everything every time for each other animal that we define, we could make them inherit from another parent class <code>Animal</code>:</p> <pre><code>class Animal:\ndef __init__(self, age, height):\nself.age = age\nself.height = height\ndef print_height(self):\nprint(self.height)\nclass Dog(Animal):\ndef __init__(self, age, height, race):\nsuper().__init__(age, height)\nself.race = race        \nclass Cat(Animal):\ndef __init__(self, age, height, meowness):\nsuper().__init__(age, height)\nself.meowness = meowness\nmy_cat = Cat(age=2, height=35, meowness=0.5)\nsome_dog = Dog(age=1, height=50, race=\"beagle\")\nmy_cat.print_height()\nprint(some_dog.race)\n# Output\n35\nbeagle\n</code></pre> <p>In this example, <code>Dog</code> and <code>Cat</code> inherit from the class <code>Animal</code>. This means that all <code>Animal</code> methods and attributes are also available to <code>Dog</code> and <code>Cat</code> as if they were defined inside their definitions. </p> <p>Note</p> <p>In the previous code snippet you might notice the use of the <code>super()</code> function. <code>super()</code> is a built-in function returns a proxy that allows us to access methods of the base class. We use it to refer to the base class: in the previous example, we are using it to call the <code>Animal.__init__</code> function from the <code>Dog</code> and <code>Cat</code> <code>__init__</code> functions.</p>"},{"location":"sections/python/comprehensions/","title":"Comprehensions","text":""},{"location":"sections/python/comprehensions/#list-comprehensions","title":"List Comprehensions","text":"<p>List comprehensions provide a concise way to create lists. Common applications are to make new  lists where each element is the result of some operations applied to each member of another sequence  or iterable, or to create a subsequence of those elements that satisfy a certain condition.</p> <p>For example, assume we want to create a list of squares, like:</p> <pre><code>squares = []\nfor x in range(10):\nsquares.append(x**2)\n</code></pre> <p>We can obtain the same result with: <pre><code>squares = [x**2 for x in range(10)]\n</code></pre> This last snippet is an example of a list comprehension. </p> <p>List comprehensions always returns a result list. It consists of brackets containing an expression followed by a <code>for</code> clause, then zero or more <code>for</code> or <code>if</code> clauses. The expressions can be anything, meaning you can put in all kinds of objects in lists.</p> <p>Note</p> <p>Warning: the comprehension syntax can be a bit confusing at first. If the comprehension is too long, it is recommended to use the normal <code>for</code> loop syntax instead, which is more readable.</p>"},{"location":"sections/python/comprehensions/#examples","title":"Examples","text":"<p>For example, this combines the elements of two lists if they are not equal:</p> <pre><code>[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n</code></pre> <p>and it\u2019s equivalent to:</p> <pre><code>combs = []\nfor x in [1,2,3]:\nfor y in [3,1,4]:\nif x != y:\ncombs.append((x, y))\n</code></pre> <p>Some other examples:</p> <pre><code>vec = [-4, -2, 0, 2, 4]\n# create a new list with the values doubled\n[x*2 for x in vec]\n# [-8, -4, 0, 4, 8]\n# filter the list to exclude negative numbers\n[x for x in vec if x &gt;= 0]\n# [0, 2, 4]\n# apply a function to all the elements\n[abs(x) for x in vec]\n# [4, 2, 0, 2, 4]\n</code></pre>"},{"location":"sections/python/comprehensions/#dictionary-comprehensions","title":"Dictionary Comprehensions","text":"<p>Dictionary comprehensions are similar, but allow you to easily construct dictionaries. For example:</p> <pre><code>{x: x**2 for x in (2, 4, 6)}\n</code></pre>"},{"location":"sections/python/comprehensions/#examples_1","title":"Examples","text":"<p>Beyond the basic usage above, dictionary comprehensions can also be used to create dictionaries from  arbitrary key and value expressions. These are some examples:</p> <ul> <li>Create a dictionary with only pairs for odd numbers:   <pre><code>{x: x**2 for x in range(10) if x % 2 == 1}\n</code></pre></li> <li>An example that also uses <code>if</code>:   <pre><code>{x: x**2 for x in range(10) if x % 2 == 1}\n</code></pre></li> <li>Create a dictionary from two lists:   <pre><code>{x: y for x, y in zip(['a', 'b'], [1, 2])}\n</code></pre></li> </ul>"},{"location":"sections/python/comprehensions/#set-comprehensions","title":"Set Comprehensions","text":"<p>Set comprehensions are similar to list comprehensions, but return a set and not a list. Syntactically, set comprehensions are the same as list comprehensions except that they use curly braces <code>{}</code> instead.</p> <p>For example:</p> <pre><code>{x for x in 'abracadabra' if x not in 'abc'}\n</code></pre>"},{"location":"sections/python/control_flow/","title":"Control flow","text":""},{"location":"sections/python/control_flow/#conditional-statements","title":"Conditional statements","text":"<p>Python uses boolean logic to evaluate conditions. For example: <pre><code>x = 2\nprint(x == 2) # prints out True\nprint(x == 3) # prints out False\nprint(x &lt; 3) # prints out True\n</code></pre></p>"},{"location":"sections/python/control_flow/#ifelse-statements","title":"if/else statements","text":"<p>Conditional statements are used to control the flow of the program with <code>if</code>/<code>else</code> statements.  We use the <code>if</code> statement to run a block code only when a certain condition is met.</p> <p>For example, assigning grades (A, B, C) based on marks obtained by a student.</p> <pre><code>if the percentage is above 90, assign grade A\nif the percentage is above 75, assign grade B\nif the percentage is above 65, assign grade C\n</code></pre> <p>In Python, there are three forms of the if...else statement.</p> <pre><code>if statement\nif...else statement\nif...elif...else statement\n</code></pre> <p>The syntax of if statement in Python is:</p> <p><pre><code>if condition:\n# body of if statement\n</code></pre> The <code>if</code> statement evaluates <code>condition</code>.</p> <pre><code>If condition is evaluated to True, the code inside the body of if is executed.\nIf condition is evaluated to False, the code inside the body of if is skipped.\n</code></pre> <p><pre><code>number = 10\n# check if number is greater than 0\nif number &gt; 0:\nprint('Number is positive.')\nprint('The if statement is easy')\n</code></pre> Output <pre><code>Number is positive.\nThe if statement is easy\n</code></pre> An <code>if</code> statement can have an optional <code>else</code> clause.</p> <p>The syntax of<code>if...else</code> statement is: <pre><code>if condition:\n# block of code if condition is True\nelse:\n# block of code if condition is False\n</code></pre> The <code>if...else</code> statement is used to execute a block of code among two alternatives.</p> <p>However, if we need to make a choice between more than two alternatives, we can use the <code>if...elif...else</code> statement.</p> <p>The syntax of the if...elif...else statement is: <pre><code>if condition1:\n# code block 1\nelif condition2:\n# code block 2\nelse: \n# code block 3\n</code></pre></p> <p>We can also use an <code>if</code> statement inside of an <code>if</code> statement. This is known as a nested if statement: <pre><code>number = 5\n# outer if statement\nif number &gt; 0:\n# inner if statement\nif number &gt; 100000:\nprint('Number is very big!')    \n# inner else statement\nelse:\nprint('Number is positive')\nelif number == 0:\nprint(\"Number is zero.\")\n# outer else statement\nelse:\nprint('Number is negative')\n# Output: Number is positive\n</code></pre></p> <p>Any value can be used as an \"if-test\". The \"zero\" values all count as false: <code>None</code>, <code>0</code>, empty string,  empty list, empty dictionary. Each block of if/else statements starts with a <code>:</code> and the statements are  grouped by their indentation:</p> <pre><code>if time_hour &gt;= 0 and time_hour &lt;= 24:\nprint('Suggesting a drink option...')\nif mood == 'sleepy' and time_hour &lt; 10:\nprint('coffee')\nelif mood == 'thirsty' or time_hour &lt; 2:\nprint('lemonade')\nelse:\nprint('water')\n</code></pre>"},{"location":"sections/python/control_flow/#match-case","title":"Match case","text":"<p>Python 3.10 offers a simple and effective way to test multiple values and perform conditional  actions: the match-case statement. In case you\u2019re familiar with C++, it works similarly to the switch case.</p> <p>For our example, let\u2019s say you\u2019re building a program to check a computer\u2019s processor.  Based on the result, the program will let the gamer know if their processor is compatible  with a certain video game. Here\u2019s how our program would look:</p> <pre><code># First, ask the player about their CPU\ncpu_model = input(\"Please enter your CPU model: \")\n# The match statement evaluates the variable's value\nmatch cpu_model:\ncase \"celeron\": # We test for different values and print different messages\nprint (\"Forget about it and play Minesweeper instead...\")\ncase \"core i3\":\nprint (\"Good luck with that ;)\")\ncase \"core i5\":\nprint (\"Yeah, you should be fine.\")\ncase \"core i7\":\nprint (\"Have fun!\")\ncase \"core i9\":\nprint (\"Our team designed nice loading screens\u2026 Too bad you won't see them...\")\ncase _: # the underscore character is used as a catch-all.\nprint (\"Is that even a thing?\")\n</code></pre> <p>The above code checks a few possible values for the cpuModel variable.  If the CPU model the user enters doesn\u2019t match our expected options, the final  case statement prints an error message. Here\u2019s a possible output: <pre><code>Please enter your CPU model: core i9\nOur teams designed nice loading screens... Too bad you won't see them...\n</code></pre></p> <ul> <li>Types of programs, stages in programming and expressions.</li> <li>Using conditional statements to satisfy program specifications</li> </ul>"},{"location":"sections/python/control_flow/#strings","title":"Strings","text":"<p>Python has a built-in string class named <code>str</code> with many handy features. String literals can be  enclosed by either double or single quotes. Backslash escapes work the usual way within both  single and double quoted literals -- e.g. <code>\\n</code> <code>\\'</code> <code>\\\"</code>. A double quoted string literal can  contain single quotes without any fuss (e.g. <code>\"I didn't do it\"</code>) and likewise single quoted string  can contain double quotes. </p> <p>String literals inside triple quotes, \"\"\" or ''', can span multiple lines of text. Python strings are \"immutable\", which means they cannot be changed after they are created. Since strings can't be changed, we construct new strings as we go to represent computed values.  So for example the expression (<code>'hello'</code> + <code>'there'</code>) takes in the 2 strings <code>'hello'</code> and <code>'there'</code> and  builds a new string <code>'hellothere'</code>.</p> <p>Characters in a string can be accessed using the bracket <code>[ ]</code> syntax. </p> <p>Note</p> <p>Like other languages, Python uses zero-based indexing, so if <code>s</code> is <code>'hello'</code> <code>s[1]</code> is <code>'e'</code>.  If the index is out of bounds for the string, Python raises an error. </p> <p>The handy \"slice\" syntax (below) also works to extract any substring from a string.  The <code>len(string)</code> function returns the length of a string. The <code>[ ]</code> syntax and the <code>len()</code>  function actually work on any sequence type -- strings, lists, etc.  Python tries to make its operations work consistently across different types. </p> <p>Note</p> <p>Python newbie gotcha: don't use \"<code>len</code>\" as a variable name to avoid blocking out the <code>len()</code> function. </p> <p>The <code>+</code> operator can concatenate two strings. Notice in the code below that variables are not pre-declared --  just assign to them and go.</p> <pre><code>s = 'hi'\nprint(s[1])          ## i\nprint(len(s))        ## 2\nprint(s + ' there')  ## hi there\n</code></pre> <p>The '<code>+</code>' symbol does not automatically convert numbers or other types to string form. The <code>str()</code> function  converts values to a string form so they can be combined with other strings.</p> <pre><code>pi = 3.14\n##text = 'The value of pi is ' + pi      ## NO, does not work\ntext = 'The value of pi is '  + str(pi)  ## yes\n</code></pre> <p>A \"raw\" string literal is prefixed by an '<code>r</code>' and passes all the chars through without special treatment of  backslashes, so <code>r'x\\nx'</code> evaluates to the length-4 string <code>'x\\nx'</code>.</p> <pre><code>raw = r'this\\t\\n and that'\n# this\\t\\n and that\nprint(raw)\nmulti = \"\"\"It was the best of times.\nIt was the worst of times.\"\"\"\n# It was the best of times.\n#   It was the worst of times.\nprint(multi)\n</code></pre>"},{"location":"sections/python/control_flow/#string-methods","title":"String Methods","text":"<p>Here are some of the most common string methods. A method is like a function, but it runs  \"on\" an object. If the variable <code>s</code> is a string, then the code <code>s.lower()</code> runs the <code>lower()</code> method on  that string object and returns the result (this idea is one of the basic ideas that make up  Object Oriented Programming, OOP). Here are some of the most common string methods:</p> <pre><code>s.lower(), s.upper() -- returns the lowercase or uppercase version of the string\ns.strip() -- returns a string with whitespace removed from the start and end\ns.isalpha()/s.isdigit()/s.isspace()... -- tests if all the string chars are in the various character classes\ns.startswith('other'), s.endswith('other') -- tests if the string starts or ends with the given other string\ns.find('other') -- searches for the given other string (not a regular expression) within s, and returns the first index where it begins or -1 if not found\ns.replace('old', 'new') -- returns a string where all occurrences of 'old' have been replaced by 'new'\ns.split('delim') -- returns a list of substrings separated by the given delimiter. The delimiter is not a regular expression, it's just text. 'aaa,bbb,ccc'.split(',') -&gt; ['aaa', 'bbb', 'ccc']. As a convenient special case s.split() (with no arguments) splits on all whitespace chars.\ns.join(list) -- opposite of split(), joins the elements in the given list together using the string as the delimiter. e.g. '---'.join(['aaa', 'bbb', 'ccc']) -&gt; aaa---bbb---ccc\n</code></pre> <p>A google search for \"python str\" should lead you to the official python.org string methods which lists all the <code>str</code> methods.</p> <p>The \"slice\" syntax is a handy way to refer to sub-parts of sequences -- typically strings and lists.  The slice <code>s[start:end]</code> is the elements beginning at start and extending up to but not including end.  Suppose we have <code>s = \"Hello\"</code>:</p> <p><pre><code>s[1:4] is 'ell' -- chars starting at index 1 and extending up to but not including index 4\ns[1:] is 'ello' -- omitting either index defaults to the start or end of the string\ns[:] is 'Hello' -- omitting both always gives us a copy of the whole thing (this is the pythonic way to copy a sequence like a string or list)\ns[1:100] is 'ello' -- an index that is too big is truncated down to the string length\n</code></pre> The standard zero-based index numbers give easy access to chars near the start of the string.  As an alternative, Python uses negative numbers to give easy access to the chars at the end of  the string: <code>s[-1]</code> is the last char <code>'o'</code>, <code>s[-2]</code> is <code>'l'</code> the next-to-last char, and so on.  Negative index numbers count back from the end of the string:</p> <pre><code>s[-1] is 'o' -- last char (1st from the end)\ns[-4] is 'e' -- 4th from the end\ns[:-3] is 'He' -- going up to but not including the last 3 chars.\ns[-3:] is 'llo' -- starting with the 3rd char from the end and extending to the end of the string. \n</code></pre> <p>It is a neat thing of slices that for any index n, <code>s[:n] + s[n:] == s</code>. This works  even for n negative or out of bounds. </p> <p>One neat thing python can do is automatically convert objects into a string suitable for printing.  Two built-in ways to do this are formatted string literals, also called \"<code>f-strings</code>\", and invoking <code>str.format()</code>.</p> <p>You'll often see formatted string literals used in situations like:</p> <pre><code>value = 2.791514\nprint(f'approximate value = {value:.2f}')  # approximate value = 2.79\ncar = {'tires':4, 'doors':2}\nprint(f'car = {car}') # car = {'tires': 4, 'doors': 2}\n</code></pre> <p>A formatted literal string is prefixed with <code>'f'</code> (like the <code>'r'</code> prefix used for raw strings). Any  text outside of curly braces <code>'{}'</code> is printed out directly. Expressions contained in <code>'{}'</code> are are  printed out using the format specification described in the format spec. There are lots of neat things  you can do with the formatting including truncation and conversion to scientific notation and left/right/center alignment.</p> <p><code>f-strings</code> are very useful when you'd like to print out a table of objects and would like the columns  representing different object attributes to be aligned like</p> <pre><code>address_book = [{'name':'N.X.', 'addr':'15 Jones St', 'bonus': 70},\n{'name':'J.P.', 'addr':'1005 5th St', 'bonus': 400},\n{'name':'A.A.', 'addr':'200001 Bdwy', 'bonus': 5},]\nfor person in address_book:\nprint(f'{person[\"name\"]:8} || {person[\"addr\"]:20} || {person[\"bonus\"]:&gt;5}')\n# N.X.     || 15 Jones St          ||    70\n# J.P.     || 1005 5th St          ||   400\n# A.A.     || 200001 Bdwy          ||     5\n</code></pre> <p>Note</p> <p>We'll see about the <code>for</code> loop in the next section!</p>"},{"location":"sections/python/control_flow/#loops","title":"Loops","text":""},{"location":"sections/python/control_flow/#python-lists","title":"Python lists","text":"<p>Python has a built-in ordered list type named \"<code>list</code>\". Lists are written within square brackets <code>[ ]</code>.  Lists work similarly to strings -- use the <code>len()</code> function and square brackets <code>[ ]</code> to access data, with  the first element at index 0. (See the official python.org list docs.)</p> <pre><code>colors = ['red', 'blue', 'green']\nprint(colors[0])    # red\nprint(colors[2])    # green\nprint(len(colors))  # 3\n</code></pre> <p>Note</p> <p>You can put any sort of variable you want inside a list! Numbers, strings or other (more exotic) objects will work.</p> <p>Assignment with an <code>=</code> on lists does not make a copy. Instead, assignment makes the two variables  point to the same one list in memory.</p> <pre><code>b = colors   # Does not copy the list, just reuses it!\n</code></pre> <p>This means that if we now change <code>b</code>, we will also be changing the contents of the list <code>colors</code>. To make a different (bud identical) copy of a list, that can be modified without affecting the  original list, wee need to call the <code>copy()</code> method</p> <pre><code>b = colors.copy()   # b is now a proper copy of colors\n</code></pre> <p>The \"empty list\" is just an empty pair of brackets <code>[ ]</code>. The '<code>+</code>' works to append two lists,  so <code>[1, 2] + [3, 4]</code> yields <code>[1, 2, 3, 4]</code> (this is just like <code>+</code> with strings).</p>"},{"location":"sections/python/control_flow/#for-loop","title":"For loop","text":"<p>Python's for and in constructs are extremely useful, and the first use of them we'll see is  with lists. The <code>for</code> construct -- <code>for var in list</code> -- is an easy way to look at each element  in a list (or other collection). </p> <pre><code>squares = [1, 4, 9, 16]\nsum = 0\nfor num in squares:\nsum += num\nprint(sum)  # 30\n</code></pre> <p>Note</p> <p>Do not add or remove items from the list during iterations! It will give you plenty of headaches.</p> <p>If you know what sort of thing is in the list, use a variable name in the loop that captures that  information (such as \"num\", or \"name\", or \"url\") to improve readability. </p> <p>The in construct on its own is an easy way to test if an element appears in a list or another collection: <code>value in collection</code> tests if the value is in the collection, returning <code>True</code>/<code>False</code>.</p> <pre><code>list = ['larry', 'curly', 'moe']\nif 'curly' in list:\nprint('yay')\n</code></pre> <p>The for/in constructs are very commonly used in Python code and work on data types other than list,  so you should just memorize their syntax. You may have habits from other languages where you start  manually iterating over a collection, where in Python you should just use for/in.</p> <p>You can also use for/in to work on a string. The string acts like a list of its chars, so </p> <pre><code>for ch in s: \nprint(ch)\n</code></pre> <p>prints all the chars in a string.</p>"},{"location":"sections/python/control_flow/#range","title":"Range","text":"<p>The <code>range(n)</code> function yields the numbers 0, 1, ... n-1, and <code>range(a, b)</code> returns a, a+1, ... b-1 -- up to but  not including the last number. The combination of the for-loop and the range() function allow you to build  a traditional numeric for loop:</p> <pre><code># print the numbers from 0 through 99\nfor i in range(100):\nprint(i)\n</code></pre>"},{"location":"sections/python/control_flow/#while-loop","title":"While Loop","text":"<p>Python also has the standard while-loop. The above for/in loops solves the common case of iterating over  every element in a list, but the while loop gives you total control over the index numbers.</p> <p>Its syntaxis is quite simple:</p> <pre><code>while \"some boolean condition\":\n# block of code that gets executed in each iteration\n...\n</code></pre> <p>Here's a while loop which accesses every 3rd element in a list:</p> <pre><code># Access every 3rd element in a list\ni = 0\nwhile i &lt; len(a):\nprint(a[i])\ni = i + 3\n</code></pre> <p>As in other languages, we have the <code>break</code> and <code>continue</code> statements:</p> <ul> <li><code>break</code> finishes the while loop</li> <li><code>continue</code> moves on to the next iteration</li> </ul> <pre><code>a = [1, 2, 3, 4, 5, 6, 7, 8]\ni = 0\nwhile i &lt; len(a):\nprint(a[i])\nif i &gt; 4:\nbreak # finish while loop\nelif i == 2:\nprint(\"i is 2!\")\ni += 2\ncontinue # go back to the beginning of the while loop\ni += 1    \n</code></pre>"},{"location":"sections/python/data_structures/","title":"Data structures","text":""},{"location":"sections/python/data_structures/#data-structures_1","title":"Data structures","text":"<p>Python has some built-in data structures that are very convenient to use. </p> <ul> <li>Lists: an ordered collection of elements</li> <li>Dictionaries: a collection of elements, indexed by keys</li> <li>Sets: a collection of elements with no order, indexes or repeated elements</li> <li>Tuples: an ordered collection of elements that, unlike lists, cannot be modified</li> </ul>"},{"location":"sections/python/data_structures/#lists","title":"Lists","text":"<p>We have seen an introduction to lists in the previous loops section. We will see a few other details here:</p>"},{"location":"sections/python/data_structures/#list-methods","title":"List methods","text":"<p>Here are some common list methods.</p> <ul> <li><code>list.append(elem)</code> -- adds a single element to the end of the list. Common error: does not return the new list, just modifies the original.</li> <li><code>list.insert(index, elem)</code> -- inserts the element at the given index, shifting elements to the right.</li> <li><code>list.extend(list2)</code> adds the elements in list2 to the end of the list. Using + or += on a list is similar to using extend().</li> <li><code>list.index(elem)</code> -- searches for the given element from the start of the list and returns its index. Throws a ValueError if the element does not appear (use \"in\" to check without a ValueError).</li> <li><code>list.remove(elem)</code> -- searches for the first instance of the given element and removes it (throws ValueError if not present)</li> <li><code>list.sort()</code> -- sorts the list in place (does not return it). (The sorted() function shown later is preferred.)</li> <li><code>list.reverse()</code> -- reverses the list in place (does not return it)</li> <li><code>list.pop(index)</code> -- removes and returns the element at the given index. Returns the rightmost element if index is omitted (roughly the opposite of append()).</li> </ul> <p>Notice that these are methods on a list object, while <code>len()</code> is a function that takes the list  (or string or whatever) as an argument.</p> <pre><code>list = ['larry', 'curly', 'moe']\nlist.append('shemp')         ## append elem at end\nlist.insert(0, 'xxx')        ## insert elem at index 0\nlist.extend(['yyy', 'zzz'])  ## add list of elems at end\nprint(list)  ## ['xxx', 'larry', 'curly', 'moe', 'shemp', 'yyy', 'zzz']\nprint(list.index('curly'))    ## 2\nlist.remove('curly')         ## search and remove that element\nlist.pop(1)                  ## removes and returns 'larry'\nprint(list)  ## ['xxx', 'moe', 'shemp', 'yyy', 'zzz']\n</code></pre> <p>Note</p> <p>Common error: note that the above methods do not return the modified list, they just  modify the original list.</p> <pre><code>list = [1, 2, 3]\nprint(list.append(4))   ## NO, does not work, append() returns None\n## Correct pattern:\nlist.append(4)\nprint(list)  ## [1, 2, 3, 4]\n</code></pre>"},{"location":"sections/python/data_structures/#building-up-a-list","title":"Building up a list","text":"<p>One common pattern is to start a list as the empty list [], then use append() or extend() to add elements to it:</p> <pre><code>list = []          ## Start as the empty list\nlist.append('a')   ## Use append() to add elements\nlist.append('b')\n</code></pre>"},{"location":"sections/python/data_structures/#list-slices","title":"List Slices","text":"<p>Slices work on lists just as with strings, and can also be used to change sub-parts of the list.</p> <pre><code>list = ['a', 'b', 'c', 'd']\nprint(list[1:-1])   ## ['b', 'c']\nlist[0:2] = 'z'    ## replace ['a', 'b'] with ['z']\nprint(list)         ## ['z', 'c', 'd']\n</code></pre>"},{"location":"sections/python/data_structures/#dictionaries","title":"Dictionaries","text":"<p>Python provides another composite data type called a dictionary, which is similar to a list in that it is a  collection of objects.</p> <p>Dictionaries and lists share the following characteristics:</p> <ul> <li>Both are mutable.</li> <li>Both are dynamic. They can grow and shrink as needed.</li> <li>Both can be nested. A list can contain another list. A dictionary can contain another dictionary.  A dictionary can also contain a list, and vice versa.</li> </ul> <p>Dictionaries differ from lists primarily in how elements are accessed:</p> <ul> <li>List elements are accessed by their position in the list, via indexing. </li> <li>Dictionary elements are accessed via keys.</li> </ul> <p>Defining a Dictionary</p> <p>A dictionary consists of a collection of key-value pairs. Each key-value pair maps the key to its associated value. You can define a dictionary by enclosing a comma-separated list of key-value pairs in curly braces (<code>{}</code>). A colon  (<code>:</code>) separates each key from its associated value:</p> <p><pre><code>d = {\n&lt;key&gt;: &lt;value&gt;,\n&lt;key&gt;: &lt;value&gt;,\n.\n.\n.\n&lt;key&gt;: &lt;value&gt;\n}\n</code></pre> For example: <pre><code>football_teams = {\n\"bilbao\": \"athletic\",\n\"barcelona\": \"bar\u00e7a\",\n\"madrid\": \"real madrid\",\n\"munich\": \"bayern\",\n\"paris\": \"psg\"\n}\n</code></pre></p> <p>Of course, dictionary elements must be accessible somehow. If you don\u2019t get them by index, then how do you get them? A value is retrieved from a dictionary by specifying its corresponding key in square brackets (<code>[]</code>):</p> <p><pre><code>&gt;&gt;&gt; football_teams['bilbao']\n'athletic'\n&gt;&gt;&gt; football_teams['paris']\n'psg'\n</code></pre> If you refer to a key that is not in the dictionary, Python raises an exception: <pre><code>&gt;&gt;&gt; football_teams['toronto']\nKeyError: 'Toronto'\n</code></pre></p> <p>Defining a dictionary using curly braces and a list of key-value pairs, as shown above, is fine  if you know all the keys and values in advance. But what if you want to build a dictionary on the fly?</p> <p>You can start by creating an empty dictionary, which is specified by empty curly braces. Then you can  add new keys and values one at a time:</p> <pre><code>&gt;&gt;&gt; person = {}\n&gt;&gt;&gt; type(person)\n&lt;class 'dict'&gt;\nperson['fname'] = 'Joe'\nperson['lname'] = 'Fonebone'\nperson['age'] = 51\nperson['spouse'] = 'Edna'\nperson['children'] = ['Ralph', 'Betty', 'Joey']\nperson['pets'] = {'dog': 'Fido', 'cat': 'Sox'}\n</code></pre> <p>Note</p> <p>In dictionaries, a given key can appear in only once.  Duplicate keys are not allowed. A dictionary maps each key to a corresponding value,  so it doesn\u2019t make sense to map a particular key more than once. </p>"},{"location":"sections/python/data_structures/#iterating-over-dictionaries","title":"Iterating over dictionaries","text":"<p>When you\u2019re working with dictionaries, it\u2019s likely that you\u2019ll want to work with both the keys  and the values. One of the most useful ways to iterate through a dictionary in Python is by  using <code>.items()</code>, which is a method that returns a new view of the dictionary\u2019s items:</p> <pre><code>&gt;&gt;&gt; a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}\n&gt;&gt;&gt; d_items = a_dict.items()\n&gt;&gt;&gt; d_items  # Here d_items is a view of items\ndict_items([('color', 'blue'), ('fruit', 'apple'), ('pet', 'dog')])\n</code></pre> <p>To iterate through the keys and values of the dictionary, we will just need to \"unpack\" the elements of  the dict like so:</p> <pre><code>for key, value in a_dict.items():\nprint(key, '-&gt;', value)\n# Output\ncolor -&gt; blue\nfruit -&gt; apple\npet -&gt; dog\n</code></pre>"},{"location":"sections/python/data_structures/#dict-important-methods","title":"Dict important methods","text":"<ul> <li><code>clear()</code> Removes all the elements from the dictionary</li> <li><code>copy()</code>  Returns a copy of the dictionary</li> <li><code>fromkeys()</code>  Returns a dictionary with the specified keys and value</li> <li><code>get()</code>   Returns the value of the specified key</li> <li><code>items()</code> Returns a list containing a tuple for each key value pair</li> <li><code>keys()</code>  Returns a list containing the dictionary's keys</li> <li><code>pop()</code>   Removes the element with the specified key</li> <li><code>popitem()</code>   Removes the last inserted key-value pair</li> <li><code>setdefault()</code>    Returns the value of the specified key. If the key does not exist: insert the key, with the specified value</li> <li><code>update()</code>    Updates the dictionary with the specified key-value pairs</li> <li><code>values()</code>    Returns a list of all the values in the dictionary</li> </ul>"},{"location":"sections/python/data_structures/#sets","title":"Sets","text":"<p>In Python, we create sets by placing all the elements inside curly braces <code>{}</code>, separated by commas.</p> <p>A set can have any number of items and they may be of different types (integer, float, tuple, string etc.).  But a set cannot have mutable elements like lists, sets or dictionaries as its elements.</p> <pre><code># create a set of integer type\nstudent_id = {112, 114, 116, 118, 115}\nprint('Student ID:', student_id)\n# create a set of string type\nvowel_letters = {'a', 'e', 'i', 'o', 'u'}\nprint('Vowel Letters:', vowel_letters)\n# create a set of mixed data types\nmixed_set = {'Hello', 101, -2, 'Bye'}\nprint('Set of mixed data types:', mixed_set)\n# Output\nStudent ID: {112, 114, 115, 116, 118}\nVowel Letters: {'u', 'a', 'e', 'i', 'o'}\nSet of mixed data types: {'Hello', 'Bye', 101, -2}\n</code></pre> <p>Sets cannot have duplicate elements. Let's see what will happen if we try to include duplicate items in a set: <pre><code>numbers = {2, 4, 6, 6, 2, 8}\nprint(numbers)   \n# Output\n{8, 2, 4, 6}\n</code></pre></p>"},{"location":"sections/python/data_structures/#set-methods","title":"Set methods","text":"<p>Some of the important methods of Python sets are listed below:</p> <ul> <li><code>add()</code>: Adds an element to the set</li> <li><code>clear()</code>: Removes all the elements from the set</li> <li><code>copy()</code>: Returns a copy of the set</li> </ul> <p>Typical mathematical operations on sets:</p> <ul> <li><code>difference()</code>: Returns a set containing the difference between two or more sets</li> <li><code>intersection()</code>: Returns a set, that is the intersection of two other sets</li> <li><code>union()</code>: Return a set containing the union of sets. Can also be used with the <code>|</code> operator between sets</li> <li><code>symmetric_difference()</code>: Returns a set with the symmetric differences of two sets.</li> </ul>"},{"location":"sections/python/data_structures/#tuples","title":"Tuples","text":"<p>A tuple is created by placing all the items (elements) inside parentheses (), separated by commas.  A tuple can have any number of items and they may be of different types (integer, float, list, string, etc.).</p> <pre><code># Different types of tuples\n# Empty tuple\nmy_tuple = ()\nprint(my_tuple)\n# Tuple having integers\nmy_tuple = (1, 2, 3)\nprint(my_tuple)\n# tuple with mixed datatypes\nmy_tuple = (1, \"Hello\", 3.4)\nprint(my_tuple)\n# nested tuple\nmy_tuple = (\"mouse\", [8, 4, 6], (1, 2, 3))\nprint(my_tuple)\n# Output\n()\n(1, 2, 3)\n(1, 'Hello', 3.4)\n('mouse', [8, 4, 6], (1, 2, 3))\n</code></pre> <p>Note</p> <p>When defining a tuple, parentheses are optional (although it is good practice to use them).  A tuple containing a single value must be defined with a comma, otherwise Python will not recognize it as a tuple.</p> <p>Like lists, tuples allow slicing and indexing:</p> <pre><code>my_tuple = ('p','e','r','m','i','t')\nprint(my_tuple[0])\n# Output: 'p'\n</code></pre> <p>However, unlike lists, tuples are immutable: once defined, they cannot be changed. For example:</p> <pre><code>my_tuple = (1, 2, 3)\nmy_tuple[0] = 4\n# Output\nTypeError: 'tuple' object does not support item assignment\n</code></pre>"},{"location":"sections/python/dataclasses/","title":"Python Dataclasses","text":"<p>abstract classes decorators, staticmethod, classmethod, property</p> <p>functions with * ** kwargs, etc.</p>"},{"location":"sections/python/datetime/","title":"Dates and times","text":"<p>The <code>datetime</code> module, which is part of the standard library, is used for working with dates and times in Python. This module provides a number of classes and functions for working with dates and times,  and is the basis for the date and time functionality in pandas.</p> <p>The <code>datetime</code> module provides three classes for working with dates and times:</p> <ul> <li><code>datetime.date</code> - for working with dates in isolation (which look like <code>YYYY-MM-DD</code>)</li> <li><code>datetime.time</code> - for working with times in isolation (which look like <code>HH:MM:SS</code>)</li> <li><code>datetime.datetime</code> - for working with dates and times together (which look like <code>YYYY-MM-DD HH:MM:SS</code>)</li> </ul> <p>The <code>datetime</code> module also provides a <code>datetime.timedelta</code> class for representing durations of time.</p>"},{"location":"sections/python/datetime/#importing-the-datetime-module","title":"Importing the datetime module","text":"<p>We can import the <code>datetime</code> module with the following statement:</p> <pre><code>import datetime\n</code></pre> <p>The datetime module name and this class name are the same (that's unfortunate), so we can't import the class and module name directly without causing a name conflict. However, as always we can import only the classes and functions we need from the module:</p> <pre><code>from datetime import date, time, datetime, timedelta\n</code></pre>"},{"location":"sections/python/datetime/#creating-date-and-time-objects","title":"Creating date and time objects","text":"<p>We can create <code>date</code>, <code>time</code> and <code>datetime</code> objects using the <code>date()</code>, <code>time()</code> and <code>datetime()</code> constructors respectively. Each of these constructors takes a number of arguments, which are used to initialise the object.</p>"},{"location":"sections/python/datetime/#creating-date-objects","title":"Creating date objects","text":"<p>The <code>date()</code> constructor takes three arguments:</p> <ul> <li><code>year</code> - the year as an integer</li> <li><code>month</code> - the month as an integer (1-12)</li> <li><code>day</code> - the day as an integer (1-31)</li> </ul> <pre><code>d = date(2018, 1, 1)\nprint(d)\n# Output: 2018-01-01\n</code></pre>"},{"location":"sections/python/datetime/#creating-time-objects","title":"Creating time objects","text":"<p>The <code>time()</code> constructor takes four arguments:</p> <ul> <li><code>hour</code> - the hour as an integer (0-23)</li> <li><code>minute</code> - the minute as an integer (0-59)</li> <li><code>second</code> - the second as an integer (0-59)</li> <li><code>microsecond</code> - the microsecond as an integer (0-999999)</li> </ul> <pre><code>t = time(12, 30, 0, 0)\nprint(t)\n# Output: 12:30:00\n</code></pre>"},{"location":"sections/python/datetime/#creating-datetime-objects","title":"Creating datetime objects","text":"<p>The <code>datetime()</code> constructor takes seven arguments:</p> <ul> <li><code>year</code> - the year as an integer</li> <li><code>month</code> - the month as an integer (1-12)</li> <li><code>day</code> - the day as an integer (1-31)</li> <li><code>hour</code> - the hour as an integer (0-23)</li> <li><code>minute</code> - the minute as an integer (0-59)</li> <li><code>second</code> - the second as an integer (0-59)</li> <li><code>microsecond</code> - the microsecond as an integer (0-999999)</li> </ul> <p>Note</p> <p>Only the <code>year</code>, <code>month</code> and <code>day</code> arguments are required. The other arguments default to <code>0</code>.</p> <pre><code>dt = datetime(2018, 1, 1, 12, 30, 0, 0)\nprint(dt)\n# Output: 2018-01-01 12:30:00\n</code></pre> <p>The <code>datetime()</code> constructor also takes a <code>tzinfo</code> argument, which is used to specify the time zone of the <code>datetime</code> object. This parameter is also optional, but if you don't specify a <code>tzinfo</code> argument (known as naive time), then the <code>datetime</code> object will be created in the local time zone. This is usually a bad idea that can lead to many problems</p> <p>We will discuss time zones in more detail in the time zones section.</p>"},{"location":"sections/python/datetime/#working-with-date-and-time-objects","title":"Working with date and time objects","text":"<p>Once we have created a <code>date</code>, <code>time</code> or <code>datetime</code> object, we can access the individual components of the object using the following attributes:</p> <ul> <li><code>year</code> - the year as an integer</li> <li><code>month</code> - the month as an integer (1-12)</li> <li><code>day</code> - the day as an integer (1-31)</li> <li><code>hour</code> - the hour as an integer (0-23)</li> <li><code>minute</code> - the minute as an integer (0-59)</li> <li><code>second</code> - the second as an integer (0-59)</li> <li><code>microsecond</code> - the microsecond as an integer (0-999999)</li> <li><code>tzinfo</code> - the time zone as a <code>tzinfo</code> object</li> </ul> <pre><code>from datetime import date\nd = date(2018, 1, 1)\nprint(d.year)\nprint(d.month)\nprint(d.day)\n# Output:\n# 2018\n# 1\n# 1\n</code></pre> <p>We can also use the <code>strftime()</code> method to format a <code>date</code>, <code>time</code> or <code>datetime</code> object as a string:</p> <pre><code>from datetime import date\nd = date(2018, 1, 1)\nprint(d.strftime('%Y-%m-%d'))\n# Output: 2018-01-01\n</code></pre>"},{"location":"sections/python/datetime/#parsing-date-and-time-strings","title":"Parsing date and time strings","text":"<p>To do the opposite, and parse a string into a <code>date</code>, <code>time</code> or <code>datetime</code> object, we can use the <code>strptime()</code> function. The <code>strptime()</code> function takes two arguments:</p> <ul> <li><code>date_string</code> - the string to parse</li> <li><code>format</code> - the format of the string to parse</li> </ul> <p>The <code>format</code> argument is a string that specifies the format of the string to parse. The format string uses the same directives as the <code>strftime()</code> method.</p> <pre><code>from datetime import datetime\nstr_date = '2018-01-01 12:30:00'\ndt = datetime.strptime(str_date, '%Y-%m-%d %H:%M:%S')\nprint(dt)\n# Output: 2018-01-01 12:30:00\n</code></pre>"},{"location":"sections/python/datetime/#difference-between-two-dates-or-times","title":"Difference between two dates or times","text":"<p>To calculate the difference between two <code>date</code>, <code>time</code> or <code>datetime</code> objects, we can use the <code>-</code> operator. The result of this operation is a <code>timedelta</code> object, which represents the time difference between the two objects.</p> <pre><code>from datetime import date\nd1 = date(2018, 1, 1)\nd2 = date(2018, 1, 2)\ndt = d2 - d1\nprint(dt)\n# Output: 1 day, 0:00:00\n</code></pre> <p>Timedeltas can be added to or subtracted from <code>date</code>, <code>time</code> or <code>datetime</code> objects using the <code>+</code> and <code>-</code> operators.</p> <pre><code>from datetime import date, timedelta\nd = date(2018, 1, 1)\ndt = d + timedelta(days=1)\nprint(dt)\n# Output: 2018-01-02\n</code></pre> <p>Note</p> <p>However, we can't sum two different <code>date</code>, <code>time</code> or <code>datetime</code> objects together. The sum only works when adding a <code>timedelta</code> to a <code>date</code>, <code>time</code> or <code>datetime</code> object.</p>"},{"location":"sections/python/datetime/#working-with-time-zones","title":"Working with time zones","text":"<p>The <code>datetime</code> module provides a <code>tzinfo</code> class for representing time zones. However, this class is an abstract base class (i.e., its methods are empty), and to use it we would need to implement it. The <code>pytz</code> module (a module that needs to be installed, since it doesn't come with Python)  provides a concrete implementation of the <code>tzinfo</code> class, which we can use to represent time zones.  For example, to define a <code>datetime</code> object in the UTC time zone and convert it to european summer time,  we can do the following:</p> <pre><code>from datetime import datetime\nimport pytz\ndt_1 = datetime(2018, 1, 1, 12, 30, 0, 0, tzinfo=pytz.utc)\ndt_2 = dt_1.astimezone(pytz.timezone('Europe/Paris'))\nprint(dt_1)\nprint(dt_2)\n# Output:\n# 2018-01-01 12:30:00+00:00\n# 2018-01-01 13:30:00+01:00\n</code></pre> <p>In this example, the <code>astimezone()</code> method converts a <code>datetime</code> object from one time zone to another.</p>"},{"location":"sections/python/datetime/#working-with-dates-and-times-in-pandas","title":"Working with dates and times in pandas","text":"<p>The pandas library provides a number of data structures for working with dates and times. The most commonly used are the <code>Timestamp</code> and <code>DatetimeIndex</code> classes.</p>"},{"location":"sections/python/datetime/#the-timestamp-class","title":"The Timestamp class","text":"<p>The <code>Timestamp</code> class represents a single date and time, and is very similar to the <code>datetime</code> class. To create a <code>Timestamp</code> object, we can use the <code>to_datetime()</code> function, which takes a string or a number of arguments, which are used to initialise the object.</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'date': ['2018-01-01 12:30:00']})\ndf['date'] = pd.to_datetime(df['date'])\nprint(df['date'].dtype)\n# Output: datetime64[ns]\n</code></pre> <p>This class provides a number of methods for working with dates and times. For example, we can use the <code>strftime()</code> method to format a <code>Timestamp</code> object as a string (like the <code>datetime</code> class), or we can use the <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code> and <code>microsecond</code> attributes to access the individual components of the object.</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'date': ['2018-01-01 12:30:00']})\ndf['date'] = pd.to_datetime(df['date'])\nprint(df['date'].dt.weekday_name)\n# Output: 0    Monday\n# Name: date, dtype: object\n</code></pre>"},{"location":"sections/python/datetime/#the-datetimeindex-class","title":"The DatetimeIndex class","text":"<p>When we have a date or datetime column in a pandas DataFrame, we can set is as the index of the DataFrame using the <code>set_index()</code> method. This will create a <code>DatetimeIndex</code> object, which is used to index the DataFrame.</p> <p>Note</p> <p>Using the dates as index is only possible if the dates are unique, and is only useful if we want to select rows by date. Otherwise, we can just leave the dates as a normal column in the DataFrame.</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'date': ['2018-01-01 12:30:00', '2018-01-02 12:30:00', '2018-01-03 12:30:00']})\ndf.set_index('date', inplace=True)\nprint(df.index)\n# Output\n# DatetimeIndex(['2018-01-01 12:30:00', '2018-01-02 12:30:00',\n#                '2018-01-03 12:30:00'],\n#               dtype='datetime64[ns]', name='date', freq=None)\n</code></pre> <p>Note</p> <p>Setting the index of a DataFrame to a <code>DatetimeIndex</code> object is a very common operation, so pandas provides a <code>parse_dates</code> argument for the <code>read_csv()</code> function, which can be used to automatically parse date and time columns into a <code>DatetimeIndex</code> object.</p> <p>We can also create a <code>DatetimeIndex</code> with the <code>pd.date_range()</code> function. This function takes a number of arguments, which are used to create a range of dates. For example, to create a <code>DatetimeIndex</code> with the dates from 2018-01-01 to 2018-01-10, we can do the following:</p> <pre><code>import pandas as pd\nindex = pd.date_range('2018-01-01', '2018-01-20', freq='W')\nprint(index)\n# Output:\n# DatetimeIndex(['2018-01-07', '2018-01-14'], dtype='datetime64[ns]', freq='W-SUN')\n</code></pre> <p>Note</p> <p>The <code>freq</code> argument specifies the frequency of the dates. In this example, we have used <code>W</code> to specify weekly frequency, and <code>W-SUN</code> to specify weekly frequency with the week ending on Sunday.</p>"},{"location":"sections/python/exceptions/","title":"Exceptions","text":""},{"location":"sections/python/exceptions/#basic-exception-handling","title":"Basic exception handling","text":"<p>Exceptions are a way to keep Python errors under control, once a program is running.  Exceptions errors arise when correct Python programs (i.e., syntactically correct code) produce an error.</p> <p>Python creates an exception object whenever such errors occur. When we write code that deals with the  exception, our programs will continue running, even if an error is thrown. If we don't, then our programs will  stop executing and show a trace-back, which is sometimes hard for a user to understand.</p>"},{"location":"sections/python/exceptions/#example-1","title":"Example 1","text":"<p>Let's run a program that divides a number by zero. We know (or we should) that you cannot divide by zero, but let\u2019s see what Python does: <pre><code>print(6/0)\n</code></pre> When we run the above code, Python gives the following traceback:</p> <p><pre><code>Traceback (most recent call last):\n  File \u201cC:\\Users\\ADMIN\\PycharmProject\\pythonProject\\main.py\u201d, line 1, in &lt;module&gt;\n print(6/0)\nZeroDivisionError: division by zero\n</code></pre> Since Python cannot divide a number by zero, it reports an error in the trace-back as <code>ZeroDivisionError</code>,  which is an exception object, and then the execution stops.  This kind of object responds to a scenario where Python can't do what we asked it to.</p> <p>Note</p> <p>There are many different types of exceptions in Python. You will probably find some of them soon, if you haven't yet. You can even define your own exceptions.</p> <p>If you think an error might occur in your code, use the try-except block to control the exception  that may be raised.</p> <p>To handle the <code>ZeroDivisionError</code> exception, use a try-except block like this:</p> <p><pre><code>try:\nprint(6/0)\nexcept ZeroDivisionError:\nprint(\"You can\u2019t divide by zero!\") # You can\u2019t divide by zero!\n</code></pre> When you runt it, you will see the following output: <pre><code>You can\u2019t divide by zero!\n</code></pre></p>"},{"location":"sections/python/exceptions/#example-2","title":"Example 2","text":"<p>Errors arise often when working with files that are missing. Python may fail to retrieve a file, if  you have written the wrong spelling of the filename, or the file does not exist.</p> <p>We handle this situation like before: by making use of the try-except block. For example, imagine the program  below tries to read a file that doesn't exist on your computer:</p> <pre><code>filename = 'some_nonexistent_file.txt'\nwith open(filename) as file:\ncontents = file.read()\n</code></pre> <p>Since Python cannot read a file that does not exist, it raises an exception:</p> <pre><code>Traceback (most recent call last):\n  File \u201cC:\\Users\\ADMIN\\PycharmProject\\pythonProject\\main.py\u201d, line 2, in &lt;module&gt;\n with open(filename) as f_obj:\nFileNotFoundError: [Errno 2] No such file or directory: \u2018some_nonexistent_file.txt\u2019\n</code></pre> <p>This is the <code>FileNotFoundError</code> exception. In this example, the <code>open()</code> function creates the error.  To solve this error, use the try block just before the line, which involves the <code>open()</code> function:</p> <pre><code>filename = 'some_nonexistent_file.txt'\ntry:\nwith open(filename) as f_obj:\ncontents = f_obj.read()\nexcept FileNotFoundError:\nmsg = \"Sorry, the file \"+ filename + \"does not exist.\"\nprint(msg) # Sorry, the file some_nonexistent_file.txt does not exist.\n</code></pre> <p>Now the code works correctly. This is known as catching the exception.</p>"},{"location":"sections/python/exceptions/#try-except-structure","title":"Try-except structure","text":"<p>The full exception handling in Python has this structure:</p> <pre><code>try:\n# Some Code.... \nexcept:\n# optional block\n# Handling of exception (if required)\nelse:\n# execute if no exception\nfinally:\n# Some code .....(always executed)\n</code></pre> <p>Note</p> <p>Note that in the try-except block above we didn't specify what exception we are  catching. It is not mandatory to do so, but it is very good practice to do it always. Otherwise, we could be having a different error in the code (that we have not foreseen) and we wouldn't notice!</p> <p>However, in practice we often only use it like this: <pre><code>try:\n# some code\nexcept SomeException:\n# what to do when the exception is raised\n</code></pre></p>"},{"location":"sections/python/exceptions/#how-to-manually-raise-an-exception-in-python","title":"How to manually raise an exception in Python","text":"<p>How do we raise an exception in Python so that it can later be caught via an except block? We should always use the most specific Exception constructor that semantically fits your issue.</p> <p>Some common rules:</p> <ul> <li>Be specific in your message, e.g.:     <pre><code>raise ValueError('A very specific bad thing happened.')\n</code></pre></li> <li>Don't raise generic exceptions: avoid raising a generic Exception. To catch it, you'll have to  catch all other more specific exceptions that subclass it.</li> </ul>"},{"location":"sections/python/functions/","title":"Functions","text":""},{"location":"sections/python/functions/#functions_1","title":"Functions","text":""},{"location":"sections/python/functions/#introduction","title":"Introduction","text":"<p>You may be familiar with the mathematical concept of a function. A function is a relationship or  mapping between one or more inputs and a set of outputs. In mathematics, a function is typically represented like</p> \\[\\begin{align} z = f(x,y) \\end{align}\\] <p>Here, \\(f\\) is a function that operates on the inputs \\(x\\) and \\(y\\). The output of the function is \\(z\\).  However, programming functions are much more generalized and versatile than this mathematical definition.  In fact, appropriate function definition and use is so critical to proper software development that virtually  all modern programming languages support both built-in and user-defined functions.</p> <p>In programming, a function is a self-contained block of code that encapsulates a specific task or related group  of tasks. We have already seen some of the built-in functions provided by Python: <code>print()</code>, <code>type()</code> or <code>len()</code>.  For example, <code>len()</code> returns the length of the argument passed to it:</p> <pre><code>&gt;&gt;&gt; a = ['foo', 'bar', 'baz', 'qux']\n&gt;&gt;&gt; len(a)\n4\n</code></pre> <p>These functions are part of the Python Standard Library, a collection of modules accessible to Python programs that require no installation of external code. The Python standard library can be used to  simplify the programming process, removing the need to reinvent the wheel and rewrite commonly used commands.</p> <p>Most functions from the standard library can be used by calling <code>import package_name</code> at the beginning of a script, where <code>package_name</code> is the name of the precise library that we want to use. We'll see a couple of important  Python modules in the next sections.</p> <p>Note</p> <p>Not all functions need to be imported to be used. <code>print()</code>, <code>type()</code> or <code>len()</code> are so general that we can use them without the need to import anything.</p>"},{"location":"sections/python/functions/#the-math-library","title":"The math library","text":"<p>For straightforward mathematical calculations in Python, you can use the built-in mathematical operators,  such as addition (<code>+</code>), subtraction (<code>-</code>), division (<code>/</code>), and multiplication (<code>*</code>). But more advanced operations,  such as exponential, logarithmic, trigonometric, or power functions, are not built in. Does that mean you need  to implement all of these functions from scratch? </p> <p>Fortunately, no. Python provides a module specifically designed for higher-level mathematical operations: the math  module. The math module comes packaged with the Python release, so you don\u2019t have to install it separately.  Using it is just a matter of importing the module:</p> <p><pre><code>&gt;&gt;&gt; import math\n</code></pre> You can import the Python math module using the above command. After importing, you can use it straightaway. For instance, imagine that we want to use the cosine function, \\(f(x) = \\cos(x)\\). Then we would do</p> <p><pre><code>x = 3.14\ny = math.cos(y)\n</code></pre> and similarly for all other functions and parameters of the math module. </p> <p>Note</p> <p>If we don't want to write <code>math.XXX</code> in front of every import of the math module, we can also just import the specific parts of the module that we need, as in</p> <pre><code>from math import cos\nx = 3.14\ny = cos(y)\n</code></pre>"},{"location":"sections/python/functions/#numbers-math-functions","title":"Numbers, math functions","text":"<p>The math module provides many functions and important \"named\" numbers. This is a list of some of the most important:</p> <ul> <li><code>ceil(x)</code>: returns the smallest integer greater than or equal to x.</li> <li><code>trunc(x)</code>: returns the truncated integer value of x.</li> <li><code>factorial(x)</code>: returns the factorial of x</li> <li><code>pow(x, y)</code>: returns x raised to the power y</li> <li><code>cos(x)</code>, <code>sin(y)</code>, <code>tan(y)</code>: trigonometric functions</li> <li><code>pi</code>: mathematical constant 3.1415...</li> <li><code>e</code>: mathematical constant 2.7182...</li> </ul>"},{"location":"sections/python/functions/#random-numbers","title":"Random numbers","text":"<p>Python provides the <code>random</code> module to generate random numbers. This is also a built-in module that requires no installation. <code>random</code> provides a number of useful tools for generating what we call pseudo-random data.</p> <p>Note</p> <p>Disclaimer: most random data generated with Python is not fully random in the scientific sense of the word.  Rather, it is pseudorandom: generated with a pseudorandom number generator (PRNG), which is essentially any  algorithm for generating seemingly random but still reproducible data.</p>"},{"location":"sections/python/functions/#random-floats","title":"Random floats","text":"<p>The <code>random.random()</code> function returns a random float in the interval \\([0.0, 1.0)\\):</p> <pre><code>&gt;&gt;&gt; # Don't call `random.seed()` yet\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.random()\n0.35553263284394376\n&gt;&gt;&gt; random.random()\n0.6101992345575074\n</code></pre> <p>If you run this code yourself, the numbers returned on your machine will be different.  The default when you don\u2019t seed the generator is to use your current system time or a \u201crandomness source\u201d from  your OS if one is available.</p> <p>With <code>random.seed()</code>, you can make results reproducible, and the chain of calls after <code>random.seed()</code> will  produce the same trail of data:</p> <pre><code>&gt;&gt;&gt; random.seed(444)\n&gt;&gt;&gt; random.random()\n0.3088946587429545\n&gt;&gt;&gt; random.random()\n0.01323751590501987\n&gt;&gt;&gt; random.seed(444)  # Re-seed\n&gt;&gt;&gt; random.random()\n0.3088946587429545\n&gt;&gt;&gt; random.random()\n0.01323751590501987\n</code></pre>"},{"location":"sections/python/functions/#random-integers","title":"Random integers","text":"<p>You can generate a random integer between two endpoints in Python with the <code>random.randint()</code> function. This spans  the full \\([x, y]\\) interval and may include both endpoints:</p> <pre><code>&gt;&gt;&gt; random.randint(0, 10)\n7\n&gt;&gt;&gt; random.randint(500, 50000)\n18601\n</code></pre> <p>Note</p> <p>If we wanted to simulate a dice, we could run <code>random.randint(1, 6)</code>.</p>"},{"location":"sections/python/functions/#custom-function-definitions","title":"Custom function definitions","text":"<p>If no function from an already existing package fits our needs, we can always define our own  custom function.</p> <p>When you define your own Python function, it works just the same as with built-in functions.  From somewhere in your code, you\u2019ll call your Python function and program execution will  transfer to the body of code that makes up the function.</p> <p>Note</p> <p>Functions are really really important in programming, since they allow code reusability.</p> <p>When the function is finished, execution returns to the location where the function was called.  Depending on how you designed the function\u2019s interface, data may be passed in when the function is called,  and return values may be passed back when it finishes.</p> <p>The usual syntax for defining a Python function is as follows:</p> <pre><code>def &lt;function_name&gt;([&lt;arguments&gt;]):\n\"\"\"Docstring.\"\"\"\n&lt;statement(s)&gt;\n</code></pre> <p>where the components are:</p> <ul> <li><code>def</code>: the keyword that informs Python that a function is being defined</li> <li><code>&lt;function_name&gt;</code>: A valid Python identifier that names the function</li> <li><code>&lt;arguments&gt;</code>: An optional, comma-separated list of parameters that may be passed to the function</li> <li><code>Docstring</code>: information on how the function works, what it does, its arguments and return types.</li> <li><code>:</code>: Punctuation that denotes the end of the Python function header (the name and parameter list)</li> <li><code>&lt;statement(s)&gt;</code>: A block of valid Python code that does something with the passed parameters</li> </ul> <p>Here\u2019s an example that defines and calls f(): <pre><code>def f():    \ns = '-- Inside f()'    \nprint(s)\nprint('Before calling f()')\nf()\nprint('After calling f()')\n</code></pre></p> <p>Here\u2019s how this code works:</p> <ul> <li> <p>Line 1 uses the def keyword to indicate that a function is being defined. Execution of the def    statement merely creates the definition of <code>f()</code>. All the following lines that are indented (lines 2 to 3)    become part of the body of <code>f()</code> and are stored as its definition, but they aren\u2019t executed yet.</p> </li> <li> <p>Line 4 is a bit of whitespace between the function definition and the first line of the main program.    While it isn\u2019t syntactically necessary, it is nice to have. </p> </li> <li> <p>Line 5 is the first statement that isn\u2019t indented because it isn\u2019t a part of the definition of <code>f()</code>.    It\u2019s the start of the main program. When the main program executes, this statement is executed first.</p> </li> <li> <p>Line 6 is a call to <code>f()</code>. Note that empty parentheses are always required in both a function definition    and a function call, even when there are no parameters or arguments. Execution proceeds to <code>f()</code> and the statements    in the body of <code>f()</code> are executed.</p> </li> <li> <p>Line 7 is the next line to execute once the body of <code>f()</code> has finished. Execution returns to this <code>print()</code> statement.</p> </li> </ul>"},{"location":"sections/python/functions/#return-statement","title":"Return statement","text":"<p>To use a function, first you need to call it. As we have seen, a function call consists of the function's name  followed by the function\u2019s arguments in parentheses:</p> <pre><code>function_name(arg1, arg2, ..., argN)\n</code></pre> <p>You\u2019ll need to pass arguments to a function call only if the function requires them. The parentheses, on the other  hand, are always required in a function call. If you forget them, then you won\u2019t be calling the function but  referencing it as a function object.</p> <p>But, how do we make the function return a value? For that we need to use the Python <code>return</code> statement. </p> <pre><code>def mean(sample):\nreturn sum(sample) / len(sample)\n</code></pre> <p>we can also return more than one value if we put the results in a list, tuple or dictionary:</p> <pre><code>def sum_and_diff(var1, var2):\nreturn var1 + var2, var1 - var2\n</code></pre>"},{"location":"sections/python/functions/#definition-arguments-and-type-annotations","title":"Definition, arguments and type annotations","text":"<p>Consider the following function definition:</p> <p><pre><code>def duplicate(msg):\n\"\"\"Returns a string containing two copies of `msg`\"\"\"\nreturn msg + msg\n</code></pre> The argument of the function is the parameter <code>msg</code>: this function is intended to duplicate the passed message. For example, if called with the value <code>\"Hello\"</code>, it returns the value <code>\"HelloHello\"</code>. If called with other types of  data, however, it will not work as expected. </p> <p>Note</p> <p>What will the function do if given an <code>int</code> or a <code>float</code> value?</p> <p>Python allows you to indicate the intended type of the function parameters and the type of the function  return value in a function definition using a special notation demonstrated in this example:</p> <p><pre><code>def duplicate(msg: str) -&gt; str:\n\"\"\"Returns a string containing two copies of `msg`\"\"\"\nreturn msg + msg\nresult = duplicate('Hello')\nprint(result)\n</code></pre> This definition of <code>duplicate</code> makes use of type annotations that indicate the function\u2019s parameter type  and return type (the return type is what comes after the <code>-&gt;</code>). A type annotation, sometimes called a type hint,  is an optional notation that specifies the type of a parameter or function result.  It tells the programmer using the function what kind of data to  pass to the function, and what kind of data to expect when the function returns a value.</p> <p>Note</p> <p>It\u2019s important to understand that adding type annotations to a function definition does not cause the  Python interpreter to check that the values passed to a function are the expected types, or cause the  returned value to be converted to the expected type! This is only an indication for the programmer and, if you are using one, for the IDE.</p> <p>For example, consider the following function:</p> <p><pre><code>def add(x: int, y: int) -&gt; int:\n\"\"\"Returns the sum of `x` and `y`\"\"\"\nreturn x + y\n</code></pre> If the function <code>add</code> in the example above is called like this: <pre><code>result = add('5', '15')\n</code></pre> the function will receive two string values, concatenate them, and return the resulting string <code>\"515\"</code>.  The <code>int</code> annotations are completely ignored by the Python interpreter. </p> <p>Note</p> <p>You should always try to use type annotations! Code looks much better with them, and it is easier to understand.</p>"},{"location":"sections/python/functions/#mutability-and-arguments","title":"Mutability and arguments","text":"<p>In Python, arguments of functions can be of two types: immutable (<code>int</code>, <code>float</code>, <code>str</code>, <code>tuples</code>...) or mutable (mostly <code>lst</code> and <code>dict</code>). </p> <p>If you pass a mutable object into a function, the function gets a reference to that same object: this means that the function can modify the value of the outer variable. However, with immutable objects, the rest of the script will remain unchanged. </p> <p>Example of a function that modifies a list:</p> <pre><code>def try_to_change_list_contents(the_list):\nprint('got', the_list)\nthe_list.append('four')\nprint('changed to', the_list)\nouter_list = ['one', 'two', 'three']\nprint('before, outer_list =', outer_list)\ntry_to_change_list_contents(outer_list)\nprint('after, outer_list =', outer_list)\n# Output:\nbefore, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n</code></pre> <p>Example of a function not modifying a string:</p> <pre><code>def try_to_change_string_reference(the_string):\nprint('got', the_string)\nthe_string = 'In a kingdom by the sea'\nprint('set to', the_string)\nouter_string = 'It was many and many a year ago'\nprint('before, outer_string =', outer_string)\ntry_to_change_string_reference(outer_string)\nprint('after, outer_string =', outer_string)\n# Output:\nbefore, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n</code></pre>"},{"location":"sections/python/functions/#lambda-functions","title":"Lambda functions","text":"<p>Lambda functions are small anonymous functions. They work as normal python functions, but are defined within a single line and a little bit differently, as:</p> <pre><code>lambda arguments : expression \n</code></pre> <p>A lambda function can take any number of arguments, but can only have one expression. For instance, a function that adds 10 to an argument a, and returns the result would be written as:</p> <pre><code>x = lambda a : a + 10\nprint(x(5)) \n</code></pre>"},{"location":"sections/python/generators/","title":"Generators","text":""},{"location":"sections/python/generators/#iterators-generators-yield","title":"Iterators, generators, yield","text":""},{"location":"sections/python/io_files/","title":"Input, output and files","text":""},{"location":"sections/python/io_files/#text-files","title":"Text files","text":""},{"location":"sections/python/io_files/#introduction","title":"Introduction","text":"<p>One of the most common tasks that you can do with Python is reading and writing files.  Whether it\u2019s writing to a simple text file, reading a complicated server log, or even analyzing raw  byte data, all of these situations require reading or writing a file.</p> <p>Before we can go into how to work with files in Python, it\u2019s important to understand what exactly a  file is and how modern operating systems handle some of their aspects.</p> <p>At its core, a file is a contiguous set of bytes used to store data. This data is organized  in a specific format and can be anything as simple as a text file or as complicated as a  program executable. In the end, these byte files are then translated into binary 1 and 0 for  easier processing by the computer.</p> <p>Files on most modern file systems are composed of three main parts:</p> <ul> <li>Header: metadata about the contents of the file (file name, size, type, and so on)</li> <li>Data: contents of the file as written by the creator or editor</li> <li>End of file (EOF): special character that indicates the end of the file</li> </ul> <p>What this data represents depends on the format specification used, which is typically represented by an extension.</p>"},{"location":"sections/python/io_files/#file-paths","title":"File paths","text":"<p>When you access a file on an operating system, a file path is required. The file path is a string  that represents the location of a file. It\u2019s broken up into three major parts:</p> <ul> <li>Folder Path: the file folder location on the file system where subsequent folders are separated    by a forward slash / (Unix) or backslash \\ (Windows)</li> <li>File Name: the actual name of the file</li> <li>Extension: the end of the file path pre-pended with a period (.) used to indicate the file type</li> </ul> <p>Here\u2019s a quick example. Let\u2019s say you have a file located within a file structure like this:</p> <pre><code>/\n\u2502\n\u251c\u2500\u2500 path/\n|   \u2502\n\u2502   \u251c\u2500\u2500 to/\n\u2502   \u2502   \u2514\u2500\u2500 cats.gif\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 dog_breeds.txt\n|\n\u2514\u2500\u2500 animals.csv\n</code></pre> <p>Let\u2019s say you wanted to access the cats.gif file, and your current location was in the same folder as path.  In order to access the file, you need to go through the path folder and then the to folder, finally  arriving at the <code>cats.gif</code> file. The Folder Path is <code>path/to/</code>. The File Name is cats. The File  Extension is <code>.gif</code>. So the full path is <code>path/to/cats.gif</code>.</p>"},{"location":"sections/python/io_files/#opening-and-closing-a-file-in-python","title":"Opening and Closing a File in Python","text":"<p>When you want to work with a file, the first thing to do is to open it. This is done by invoking  the <code>open()</code> built-in function. <code>open()</code> has a single required argument that is the path to the file.  <code>open()</code> has a single return, the file object. Once we are done with the file, we need to close it:</p> <pre><code>file = open('dog_breeds.txt')\n# do something with file\nfile.close()\n</code></pre> <p>It\u2019s important to remember that it\u2019s your responsibility to close the file! This is why it's always recommended to use the <code>with</code> statement when dealing with files:</p> <pre><code>with open('dog_breeds.txt') as reader:\n# Further file processing goes here\n...\n</code></pre> <p>When the <code>with</code> statement is finished, everything goes back to normal (and we don't need to remember to close anything). </p> <p>When opening a file, we are (directly or indirectly) using one of the different modes provided by Python. The most commonly used modes are the following:</p> <ul> <li><code>r</code>: Open for reading (default mode if nothing is specified)</li> <li><code>w</code>: Open for writing, truncating (overwriting) the file first</li> <li><code>a</code>: Open for writing, appending to the end of the file</li> <li><code>rb</code> or <code>wb</code>: Open in binary mode (read/write using byte data)</li> </ul> <p>Reading example:</p> <pre><code>with open('dog_breeds.txt', 'r') as file:\n# Option 1: Read entire file all at once\nmy_str = file.read()\n# Option 2: read line by line\nstr_list = []\nfor line in file:\nstr_list.append(line)\n</code></pre> <p>Writing example: <pre><code>with open('dog_breeds_reversed.txt', 'w') as file:\n# Write the dog breeds to the file in reversed order\nfor line in reversed(file):\nfile.write(line)\n</code></pre></p> <p>Appending to end of a file example: <pre><code>with open(\"test.txt\", \"a\") as file:\nfile.write(\"appended text\")\n</code></pre></p> <p>Note</p> <p>To read a binary file, in contrast to a text file, we would use <code>open(\"filename\", \"b\")</code></p>"},{"location":"sections/python/io_files/#reading-and-writing-json-files","title":"Reading and writing JSON files","text":"<p>JSON is an open standard file format and data interchange format that uses human-readable text  to store and transmit data objects, consisting of attribute\u2013value pairs and arrays (or other serializable values).  It is a common data exchange format on the internet, including that of web applications with servers. An  example JSON file looks like this:</p> <pre><code>{\n\"first_name\": \"John\",\n\"last_name\": \"Smith\",\n\"is_alive\": true,\n\"age\": 27,\n\"address\": {\n\"street_address\": \"21 2nd Street\",\n\"city\": \"New York\",\n\"state\": \"NY\",\n\"postal_code\": \"10021-3100\"\n},\n\"phone_numbers\": [\n{\n\"type\": \"home\",\n\"number\": \"212 555-1234\"\n},\n{\n\"type\": \"office\",\n\"number\": \"646 555-4567\"\n}\n],\n\"children\": [\n\"Catherine\",\n\"Thomas\",\n\"Trevor\"\n],\n\"spouse\": null\n}\n</code></pre>"},{"location":"sections/python/io_files/#json-file-to-python","title":"JSON file to Python","text":"<p>To load (read) the data from a <code>.json</code> file, we use the following code structure:</p> <p><pre><code>import json\nwith open(\"strings.json\", \"r\") as file:\nd = json.load(file)\nprint(d)\n</code></pre> In this example, the <code>strings.json</code> file is loaded into a variable <code>d</code> of type <code>dict</code>. If, on the contrary, we want to write a new JSON file from a dictionary variable we already have, we would use: <pre><code>import json\nmy_dict = ...\nwith open(\"out_file.json\", \"w\") as file:\njson.dump(my_dict, file)\n</code></pre> Bear in mind, however, that the structure of a JSON file is included on its use of curly brackets, in contrast to YAML files or Python code, that use indentation for that. Hence, the <code>out_file.json</code> (from the last example) will not be pretty to look at. If we want to force the use of indentation, we can add the optional parameter <code>indent</code> like so: <pre><code>import json\nmy_dict = ...\nwith open(\"out_file.json\", \"w\") as file:\njson.dump(my_dict, file, indent=4)\n</code></pre></p> <p>Note</p> <p>The <code>json</code> package is included with the standard Python installation, we don't need to install it.</p>"},{"location":"sections/python/io_files/#json-string-to-python","title":"JSON string to Python","text":"<p>The <code>json</code> package also has functions to serialize a Python object into a JSON string, and also to perform the inverse operation and deserialize a JSON string into a Python dictionary:</p> <ul> <li>Dictionary to JSON string:     <pre><code>import json \n# Data to be written \ndictionary ={ \n\"id\": \"04\", \n\"name\": \"sunil\", \n\"department\": \"HR\"\n} \n# Serializing json  \njson_object = json.dumps(dictionary, indent=4) \nprint(json_object)\n# Output\n{\n\"department\": \"HR\",\n\"id\": \"04\",\n\"name\": \"sunil\"\n}    \n</code></pre></li> <li>JSON string to dictionary:     <pre><code>import json\ndata = \"\"\"\n    {  \n    \"Name\": \"Jennifer Smith\",  \n    \"Contact Number\": 7867567898,  \n    \"Email\": \"jen123@gmail.com\",  \n    \"Hobbies\":[\"Reading\", \"Sketching\", \"Horse Riding\"]  \n    }\n\"\"\"\n# parse data:  \nres = json.loads(data)  \n</code></pre></li> </ul> <p>Note</p> <p>We can first read a JSON file into a string, and then use <code>json.loads()</code> to convert it into a Python dictionary. The result is the same as using <code>json.load()</code> to read the file directly into a dictionary.</p>"},{"location":"sections/python/python_introduction/","title":"Introduction to Python","text":""},{"location":"sections/python/python_introduction/#language-introduction","title":"Language Introduction","text":"<p>Python is an interpreted language. It uses variables to store information:  whether information is a number, text or a list of names, it will always be saved in a variable.  Information in variables can later be processed, or kept as is. </p> <p>When we declare variables in Python, we are not forced to tell the interpreter of what sort they  will be; Python will infer it at runtime. This gives the programmer some flexibility, but also  the possibility of making mistakes.</p> <p>An excellent way to see how Python code works is to run the Python interpreter and type code  right into it. If you ever have a question like, \"What happens if I do this or that?\" just  typing it into the Python interpreter is a fast and likely the best way to see what happens. </p> <pre><code>$ python3        ## Run the Python interpreter\nPython 3.X.X (XXX, XXX XX XXXX, XX:XX:XX) [XXX] on XXX\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; a = 6       ## set a variable in this interpreter session\n&gt;&gt;&gt; a           ## entering an expression prints its value\n6\n&gt;&gt;&gt; a + 2\n8\n&gt;&gt;&gt; a = 'hi'    ## 'a' can hold a string just as well\n&gt;&gt;&gt; a\n'hi'\n&gt;&gt;&gt; len(a)      ## call the len() function on a string\n2\n&gt;&gt;&gt; a + len(a)  ## try something that doesn't work\nTraceback (most recent call last):\nFile \"\", line 1, in \nTypeError: can only concatenate str (not \"int\") to str\n&gt;&gt;&gt; a + str(len(a))  ## probably what you really wanted\n'hi2'\n&gt;&gt;&gt; foo         ## try something else that doesn't work\nTraceback (most recent call last):\nFile \"\", line 1, in \nNameError: name 'foo' is not defined\n&gt;&gt;&gt; ^D          ## type CTRL-d to exit (CTRL-z in Windows/DOS terminal)\n</code></pre> <p>Note</p> <p>If you don't understand everything that is happening in the previous code snippet,  don't worry! We'll see it on the next sessions.</p> <p>As you can see above, it's easy to experiment with variables and operators.  Also, the interpreter throws, or \"raises\" in Python parlance, a runtime error if the  code tries to read a variable that has not been assigned a value. Like other programming languages,  Python is case sensitive so \"<code>a</code>\" and \"<code>A</code>\" are different variables. The end of a line marks the end  of a statement, so Python does not require a semicolon at the end of each statement.  Comments begin with a <code>#</code> and extend to the end of the line.</p>"},{"location":"sections/python/python_introduction/#basic-variables-and-types","title":"Basic variables and types","text":""},{"location":"sections/python/python_introduction/#numbers","title":"Numbers","text":"<p>The interpreter acts as a simple calculator: you can type an expression at it and it will write the value.  Expression syntax is straightforward: the operators +, -, * and / can be used to perform arithmetic;  parentheses (()) can be used for grouping. For example:</p> <pre><code>&gt;&gt;&gt;\n2 + 2\n4\n50 - 5*6\n20\n(50 - 5*6) / 4\n5.0\n8 / 5  # division always returns a floating point number\n1.6\n</code></pre> <p>The integer numbers (e.g. 2, 4, 20) have type <code>int</code>, the ones with a fractional part  (e.g. 5.0, 1.6) have type <code>float</code>. Finally, boolean numbers have type <code>bool</code> and represent logical values of <code>True</code> or <code>False</code>.</p> <p>Note</p> <p>Booleans can't be operated as normal numbers, with additions or powers. Rather, they should be used in logical expressions such as \"do this if this and that, or do that if this and that\". We'll see more about it in another section.</p> <p>Division (/) always returns a float. To do floor division and get an integer result you can  use the // operator; to calculate the remainder you can use %: <pre><code>&gt;&gt;&gt;\n17 / 3  # classic division returns a float\n5.666666666666667\n&gt;&gt;&gt;\n17 // 3  # floor division discards the fractional part\n5\n17 % 3  # the % operator returns the remainder of the division\n2\n5 * 3 + 2  # floored quotient * divisor + remainder\n17\n</code></pre></p> <p>With Python, it is possible to use the ** operator to calculate powers:</p> <pre><code>&gt;&gt;&gt;\n5 ** 2  # 5 squared\n25\n2 ** 7  # 2 to the power of 7\n128\n</code></pre> <p>The equal sign <code>=</code> is used to assign a value to a variable. Afterwards, no result is displayed  before the next interactive prompt: <pre><code>&gt;&gt;&gt;\nwidth = 20\nheight = 5 * 9\nwidth * height\n900\n</code></pre></p> <p>If a variable is not \u201cdefined\u201d (assigned a value), trying to use it will give you an error:</p> <pre><code>&gt;&gt;&gt;\nn  # try to access an undefined variable\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'n' is not defined\n</code></pre> <p>There is full support for floating point; operators with mixed type operands convert the integer operand  to floating point: <pre><code>&gt;&gt;&gt;\n4 * 3.75 - 1\n14.0\n</code></pre> In interactive mode, the last printed expression is assigned to the variable _. This means that when you are using  Python as a desk calculator, it is somewhat easier to continue calculations, for example: <pre><code>&gt;&gt;&gt;\ntax = 12.5 / 100\nprice = 100.50\nprice * tax\n12.5625\nprice + _\n113.0625\nround(_, 2)\n113.06\n</code></pre></p> <p>This variable should be treated as read-only by the user. Don\u2019t explicitly assign a value to it \u2014 you would  create an independent local variable with the same name masking the built-in variable with its magic behavior.</p>"},{"location":"sections/python/python_introduction/#text","title":"Text","text":"<p>Python can manipulate text (represented by type <code>str</code>, so-called \u201cstrings\u201d) as well as numbers.  This includes characters \u201c!\u201d, words \u201crabbit\u201d, names \u201cParis\u201d, sentences \u201cGot your back.\u201d, etc. \u201cYay! :)\u201d.  They can be enclosed in single quotes ('...') or double quotes (\"...\") with the same result. <pre><code>&gt;&gt;&gt;\n'spam eggs'  # single quotes\n'spam eggs'\n\"Paris rabbit got your back :)! Yay!\"  # double quotes\n'Paris rabbit got your back :)! Yay!'\n'1975'  # digits and numerals enclosed in quotes are also strings\n'1975'\n</code></pre></p> <p>We should always use double quotes <code>\"...\"</code> as quotation marks (since they allo the use of <code>'</code> inside): <pre><code>&gt;&gt;&gt;\n\"doesn't need to\"  # ...use double quotes instead\n\"doesn't need to\"\n</code></pre></p> <p>In the Python shell, the string definition and output string can look different. The print()  function produces a more readable output, by omitting the enclosing quotes and by  printing escaped and special characters: <pre><code>&gt;&gt;&gt;\ns = 'First line.\\nSecond line.'  # \\n means newline\ns  # without print(), special characters are included in the string\n'First line.\\nSecond line.'\nprint(s)  # with print(), special characters are interpreted, so \\n produces new line\nFirst line.\nSecond line.\n</code></pre></p> <p>If you don\u2019t want characters prefaced by \\ to be interpreted as special characters, you can use raw  strings by adding an r before the first quote:</p> <pre><code>&gt;&gt;&gt;\nprint('C:\\some\\name')  # here \\n means newline!\nC:\\some\name\nprint(r'C:\\some\\name')  # note the r before the quote\nC:\\some\\name\n</code></pre> <p>String literals can span multiple lines. One way is using triple-quotes: <code>\"\"\"...\"\"\"</code>.  End of lines are automatically included in the string:</p> <pre><code>print(\"\"\"\\\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\"\"\")\n</code></pre> <p>produces the following output (note that the initial newline is not included):</p> <pre><code>Usage: thingy [OPTIONS]\n-h                        Display this usage message\n-H hostname               Hostname to connect to\n</code></pre> <p>Strings can be concatenated (glued together) with the + operator, and repeated with *:</p> <pre><code>&gt;&gt;&gt;\n# 3 times 'un', followed by 'ium'\n3 * 'un' + 'ium'\n'unununium'\n</code></pre>"},{"location":"sections/python/python_introduction/#basic-python-functions","title":"Basic Python functions","text":"<p>We can find the complete set of Python built-in functions here. In this section we will only describe the most common and basic:</p>"},{"location":"sections/python/python_introduction/#type","title":"Type","text":"<p>The <code>type()</code> function is mostly used for debugging purposes. If a single argument <code>type(obj)</code> is passed,  it returns the type of the given object. </p> <pre><code>x = 10\nprint(type(x))\n# Output: &lt;class 'int'&gt;\n</code></pre>"},{"location":"sections/python/python_introduction/#length","title":"Length","text":"<p>The <code>len()</code> function returns the length of a data structure passed to it. We'll see more about it in coming sessions:</p> <pre><code>&gt;&gt;&gt; a = ['foo', 'bar', 'baz', 'qux']\n&gt;&gt;&gt; len(a)\n4\n</code></pre>"},{"location":"sections/python/python_introduction/#python-output","title":"Python Output","text":"<p>In Python, we can simply use the <code>print()</code> function to print output on the \"standard output\". For example, <pre><code>print('Python is powerful')\n# Output: Python is powerful\n</code></pre> Here, the <code>print()</code> function displays the string enclosed inside the single quotation. In the above code, the <code>print()</code> function is taking a single parameter (the actual syntax of  the print function accepts as much as 5 parameters, but if we really need them we can google it).</p> <p>We can also use the <code>print()</code> function to display the values of Python variables. We can do it in several ways, but the most convenient is the use of the <code>f-string</code>: 1. Prefix the string that we want to print with the letter <code>f</code>, as in <code>print(f\"some text here\")</code>.  2. Now, imagine that we have defined a variable before, as in     <pre><code>dog_name = \"Ruff\"\n</code></pre> 3. To use this variable with <code>print()</code> in an f-string we just need to call it like     <pre><code>print(f\"My dog name is {dog_name}\")\n# Output: My dog name is Ruff\n</code></pre> 4. We can insert as many variables as we like in an f-string:     <pre><code>age = 15\nhair_color = purple\nname = \"Amy\"\nprint(f\"My name is {name}, I'm {age} and have {hair_color} hair.\")\n# Output: My name is Amy, I'm 15 and have purple hair.\n</code></pre></p> <p>We can also join two strings together inside the <code>print()</code> statement. For example, <pre><code>print('This class is ' + 'awesome.')\n# Output: This class is awesome.\n</code></pre></p> <p>The <code>print()</code> function normally prints out one or more python items followed by a newline (but the ending character, which by default is <code>\\n</code>, can be changed.)</p>"},{"location":"sections/python/python_introduction/#python-input","title":"Python input","text":"<p>While programming, we might want to take the input from the user. In Python, we can use the <code>input()</code> function: <pre><code>input(prompt)\n</code></pre> Here, <code>prompt</code> is the string we wish to display on the screen and is optional.</p> <p>An example: <pre><code># using input() to take user input\nnum = input('Enter a number: ')\nprint('You Entered:', num)\nprint('Data type of num:', type(num))\n</code></pre> Output: <pre><code>Output\nEnter a number: 10\nYou Entered: 10\nData type of num: &lt;class 'str'&gt;\n</code></pre> In the above example, we have used the <code>input()</code> function to take input from the user  and stored the user input in the num variable.</p> <p>It is important to note that the entered value 10 is a <code>string</code>, not a <code>number</code>. So, type(num)  returns . If we want to convert the string to a number, we should do it explicitly, like: <pre><code>age = input(\"Enter your age: \")\nage = int(age)\n</code></pre>"},{"location":"sections/python/python_introduction/#basic-python-operators","title":"Basic Python operators","text":""},{"location":"sections/python/python_introduction/#python-arithmetic-operators","title":"Python Arithmetic Operators","text":"<p>Arithmetic operators are used to perform mathematical operations like addition, subtraction,  multiplication, etc. For example,</p> <pre><code>a = 7\nb = 2\n# addition\nprint ('Sum: ', a + b)  \n# subtraction\nprint ('Subtraction: ', a - b)   \n# multiplication\nprint ('Multiplication: ', a * b)  \n# division\nprint ('Division: ', a / b) \n# floor division\nprint ('Floor Division: ', a // b)\n# modulo\nprint ('Modulo: ', a % b)  \n# a to the power b\nprint ('Power: ', a ** b)   \n</code></pre> <p>Output: <pre><code>Sum: 9\nSubtraction: 5\nMultiplication: 14\nDivision: 3.5\nFloor Division: 3\nModulo: 1\nPower: 49\n</code></pre></p>"},{"location":"sections/python/python_introduction/#assignment-operators","title":"Assignment operators","text":"<p>Assignment operators are used to assign values to variables. For example,</p> <p><pre><code># assign 5 to x \nvar x = 5\n</code></pre> Here, <code>=</code> is an assignment operator that assigns 5 to x. Some extra examples: <pre><code># assign 10 to a\na = 10\n# assign 5 to b\nb = 5 \n# assign the sum of a and b to a\na += b      # a = a + b\nprint(a)\n# Output: 15\n</code></pre></p>"},{"location":"sections/python/python_introduction/#python-comparison-operators","title":"Python Comparison Operators","text":"<p>Comparison operators compare two values/variables and return a boolean result: <code>True</code> or <code>False</code>.  For example,</p> <pre><code>a = 5\nb = 2\n# equal to operator\nprint('a == b =', a == b)\n# not equal to operator\nprint('a != b =', a != b)\n# greater than operator\nprint('a &gt; b =', a &gt; b)\n# less than operator\nprint('a &lt; b =', a &lt; b)\n# greater than or equal to operator\nprint('a &gt;= b =', a &gt;= b)\n# less than or equal to operator\nprint('a &lt;= b =', a &lt;= b)\n</code></pre>"},{"location":"sections/python/python_introduction/#python-logical-operators","title":"Python Logical Operators","text":"<p>Logical operators are used to check whether an expression is <code>True</code> or <code>False</code>.  They are used in decision-making. For example, <pre><code># logical AND\nprint(True and True)     # True\nprint(True and False)    # False\n# logical OR\nprint(True or False)     # True\n# logical NOT\nprint(not True)          # False\n</code></pre> Python also offers some special types of operators, like the identity operator and the membership operator.  In Python, <code>is</code> and <code>is not</code> are used to check if two values are located on the same part of the memory: <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\nx3 = [1,2,3]\ny3 = [1,2,3]\nprint(x1 is not y1)  # prints False\nprint(x2 is y2)  # prints True\nprint(x3 is y3)  # prints False\n</code></pre> <code>in</code> and <code>not in</code> are the membership operators. They are used to test whether a value or  variable is found in a sequence (string, list, tuple, set and dictionary):</p> <pre><code>x = 'Hello world'\ny = {1:'a', 2:'b'}\n# check if 'H' is present in x string\nprint('H' in x)  # prints True\n# check if 'hello' is present in x string\nprint('hello' not in x)  # prints True\n# check if '1' key is present in y\nprint(1 in y)  # prints True\n# check if 'a' key is present in y\nprint('a' in y)  # prints False\n</code></pre>"},{"location":"sections/python/python_programs/","title":"Python programs","text":""},{"location":"sections/python/python_programs/#python-programs_1","title":"Python programs","text":"<p>If you quit from the Python interpreter and enter it again, the definitions you have made  (functions and variables) are lost. Therefore, if you want to write a somewhat longer program,  you are better off using a text editor to prepare the input for the interpreter and running it  with that file as input instead. This is known as creating a script. As your program gets longer,  you may want to split it into several files for easier maintenance. You may also want to use a  handy function that you\u2019ve written in several programs without copying its definition into each program.</p> <p>What we want to make is a Python module: a file containing Python definitions and statements.  The file name is the module name  with the suffix <code>.py</code> appended. Within a module, the module\u2019s name (as a string) is available as  the value of the global variable <code>__name__</code>. </p>"},{"location":"sections/python/python_programs/#the-import-statement","title":"The import Statement","text":"<p>Python modules start by importing code from other modules, if necessary.  The import statement takes many different forms, but the simplest form is the one already shown above: <pre><code>import some_module\n</code></pre></p> <p>We can then access the contents of the module (for example, an imaginary <code>some_function</code> from <code>some_module</code>) like so: <pre><code>a = some_module.some_function()\n</code></pre></p> <p>An alternate form of the import statement allows individual objects from the module to be imported  directly into the caller\u2019s symbol table: <pre><code>from &lt;module_name&gt; import &lt;name(s)&gt;\n</code></pre></p> <p>Following execution of the above statement,  can be referenced in the caller\u2019s environment  without the  prefix: <pre><code>&gt;&gt;&gt; from mod import s\n&gt;&gt;&gt; s\n'If Comrade Napoleon says it, it must be right.'\n&gt;&gt;&gt; from math import e\n&gt;&gt;&gt; e\n2.718281828459045\n</code></pre> Because this form of import places the object names directly into the caller\u2019s symbol table,  any objects that already exist with the same name will be overwritten: <pre><code>&gt;&gt;&gt; a = ['foo', 'bar', 'baz']\n&gt;&gt;&gt; a\n['foo', 'bar', 'baz']\n&gt;&gt;&gt; from mod import a\n&gt;&gt;&gt; a\n[100, 200, 300]\n</code></pre> It is also possible to import individual objects but enter them into the local symbol  table with alternate names: <pre><code>from &lt;module_name&gt; import &lt;name&gt; as &lt;alt_name&gt;[, &lt;name&gt; as &lt;alt_name&gt; \u2026]\n</code></pre> This makes it possible to place names directly into the local symbol table but avoid conflicts with previously existing names: <pre><code>&gt;&gt;&gt; s = 'foo'\n&gt;&gt;&gt; a = ['foo', 'bar', 'baz']\n&gt;&gt;&gt; from mod import s as string, a as alist\n&gt;&gt;&gt; s\n'foo'\n&gt;&gt;&gt; string\n'If Comrade Napoleon says it, it must be right.'\n&gt;&gt;&gt; a\n['foo', 'bar', 'baz']\n&gt;&gt;&gt; alist\n[100, 200, 300]\n</code></pre> <p>Finally, you can also import an entire module under an alternate name:</p> <pre><code>import &lt;module_name&gt; as &lt;alt_name&gt;\n&gt;&gt;&gt; import mod as my_module\n&gt;&gt;&gt; my_module.a\n[100, 200, 300]\n&gt;&gt;&gt; my_module.foo('qux')\narg = qux\n</code></pre>"},{"location":"sections/python/python_programs/#definitions","title":"Definitions","text":"<p>The central part of the Python module are function and class definitions. Hence, so far a module could  look like this</p> <pre><code>import math as m\ndef silly_function(a: int) -&gt; int:\n\"\"\"Some description.\"\"\"\nb = m.cos(a)**2\nreturn b\n</code></pre>"},{"location":"sections/python/python_programs/#script","title":"Script","text":"<p>Our module, so far, only has imports and definitions. This means that it does not do anything. We can add some function calls (anything that is not inside a definition of a function or a class gets actually executed) in the last section of the file: </p> <pre><code>import math as m\ndef silly_function(a: int) -&gt; int:\n\"\"\"Some description.\"\"\"\nb = m.cos(a)**2\nreturn b\nprint(\"This will be executed.\")\nvar = silly_function(2)\nprint(f\"The result is {var}.\")\n</code></pre> <p>Note</p> <p>Even though the structure above is the standard, in principle you can order your code however you want. Just bear in mind that code starts executing from the beginning of the file and then goes down line by line. So if there is a script section in the middle of the file that makes use of something that hasn't  been defined yet, it will not work.</p>"},{"location":"sections/python/python_programs/#running-scripts-from-the-terminal","title":"Running scripts from the terminal","text":"<p>Any <code>.py</code> file that contains a module is essentially a Python script. Therefore, let's save our newly created module as <code>test.py</code> inside a folder. To run the script, we need to open a terminal, go to the  folder where the file is located and then run</p> <p><pre><code>/home/gerard/documents&gt; python3 test.py\n</code></pre> or, in Windows, <pre><code>C:\\Users\\gerard\\Documents&gt; python test.py\n</code></pre></p>"},{"location":"sections/python/python_projects/","title":"Python projects","text":""},{"location":"sections/python/python_projects/#introduction","title":"Introduction","text":"<p>In this section we will learn how to create a Python project from scratch. This project will be hosted in a remote repository, and we will learn how to create a Python package from it.</p> <p>We will use Poetry to manage our project dependencies (i.e., the libraries that our project uses), and the following extra tools to help us with the development process:</p> <ul> <li>Git: the most popular version control system. This will allow us to keep track of the changes in our code between different versions of our project.</li> <li>GitHub: a website to host our remote repository (although we could use other alternatives, such as  GitLab or Bitbucket). This will allow us to share our code with other people and to collaborate with them.</li> <li>Typer: a library to create command-line interfaces (CLIs) in Python. This will allow us to create a  program that uses our Python code and can be executed from the terminal.</li> <li>Ruff: an (extremely fast) Python linter and code formatter. This will help us to keep our code clean and consistent, following a \"standard\" style of writing Python code.</li> </ul> <p>If we have more time, we can also add to our project:</p> <ul> <li>Pytest: a library to create unit tests in Python.</li> <li>NiceGUI: a library to create quick graphical user interfaces (GUIs) in Python in web browsers (other alternatives are Streamlit and Dash).</li> </ul> <p>Note</p> <p>Some basic nomeclature:</p> <ul> <li>Python module: a file containing Python code. It can be imported by other Python modules.</li> <li>Python package: a directory containing several Python modules or other Python packages. Very</li> </ul> <p>often, a Python package will also contain a <code>__init__.py</code> file, which is a Python module that is executed when the package is imported (but it is not necessary to have it). A Python package can be imported by  other Python modules.</p>"},{"location":"sections/python/python_projects/#project-structure","title":"Project structure","text":"<p>A Python project should have a clean directory structure. This makes it easier to organize the code and to add new commands and arguments.</p> <p>The following is a possible directory structure for a Python machine learning project called <code>my_project</code>  (which is the name of the directory that contains the project):</p> <pre><code>.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 my_project\n\u2502   \u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 cli\n\u2502   \u251c\u2500\u2500 models    \u2502   \u2514\u2500\u2500 __main__.py\n\u251c\u2500\u2500 notebooks\n\u2514\u2500\u2500 data\n    \u251c\u2500\u2500 raw\n    \u251c\u2500\u2500 processed\n    \u2514\u2500\u2500 results    </code></pre> <p>In the previous directory structure, we have the following files and directories:</p> <ul> <li><code>README.md</code>: a file containing a description of the project. This file is written in Markdown, a markup language</li> <li><code>.gitignore</code>: a file containing the names of the files and directories that we want to ignore when we commit. For more information, see the git section.</li> <li><code>pyproject.toml</code>: a file containing the configuration of our project. This file is automatically generated by Poetry and (in general) we should not modify it manually.</li> <li><code>poetry.lock</code>: a file containing the exact versions of the libraries that we are using in our project. This file is automatically generated by Poetry, using the information in <code>pyproject.toml</code>, and (in general) we should not modify it manually.</li> <li><code>my_project</code>: a directory containing the actual Python modules and packages that we have created for our project. The name of this directory should be the same as the name of our project. Inside this directory, we have the following:<ul> <li><code>config</code>: a directory containing code for loading and saving configuration files (configuration files typically   are <code>.json</code> or <code>.yaml</code> files, that contain the parameters of our models).</li> <li><code>data</code>: a directory containing Python modules and packages that contain the code for loading and saving data.</li> <li><code>cli</code>: a directory containing the code for our CLI. This directory typically contains a <code>main.py</code> file,    which is the entry point of our CLI, and several other Python modules and packages that contain the code for   the different commands and arguments of our CLI. We will create this CLI with Typer    (see the corresponding section).</li> <li><code>models</code>: a directory containing Python modules and packages that contain the code for our machine learning models.</li> <li><code>__main__.py</code>: a file that is executed when we run <code>python -m my_project</code> from the terminal. This file typically   contains the code to run our CLI.</li> </ul> </li> <li><code>notebooks</code>: a directory containing Jupyter notebooks, or other python scripts for exploratory data analysis (EDA). These files are temporary, and once ready, anything important should be moved to the Python modules and packages in  <code>my_project</code>.</li> <li><code>data</code>: a directory containing the data for our project. This directory typically contains the following:<ul> <li><code>raw</code>: a directory containing the raw data for our project (i.e., the data that we have downloaded from the   internet or that we have received from other people).</li> <li><code>processed</code>: a directory containing the processed data for our project (i.e., the data that we have created   from the raw data).</li> <li><code>results</code>: a directory containing the results of our project (i.e., the data that we have created from the   processed data).</li> </ul> </li> </ul> <p>Note</p> <p>Of course, this is just a project structure suggestion. You can adapt it to your own needs.</p>"},{"location":"sections/python/python_projects/#creating-our-project-with-poetry","title":"Creating our project with Poetry","text":""},{"location":"sections/python/python_projects/#poetry-introduction","title":"Poetry introduction","text":"<p>Poetry is a tool for dependency management and packaging in Python. It allows us to define the libraries that our project uses in a <code>pyproject.toml</code> file (which is a standard file in all proper Python projects). With all the constraints defined in this file, Poetry will automatically install the correct versions of the libraries that we need in our project (the versions that are compatible with each other), and save them in a <code>poetry.lock</code> file.</p> <p>Under the hood, Poetry uses pip to install the libraries. However, it is not recommended to use pip directly, since it does not have a way to lock the versions of the libraries that we are using.</p> <p>Note</p> <p>Poetry is not the only tool for dependency management and packaging in Python. Other popular alternatives are pipenv and conda.</p>"},{"location":"sections/python/python_projects/#creating-the-project","title":"Creating the project","text":"<p>To create a new project, we should follow these steps:</p> <ol> <li>Create a new directory for our project. It should be named the same as our project.</li> <li>Open a terminal and navigate to the directory that we have just created.</li> <li> <p>Run the following command:</p> <pre><code>git init\n</code></pre> <p>This will initialize a new git repository in our project.</p> </li> <li> <p>Manually create the files </p> <ul> <li><code>README.md</code></li> <li><code>.gitignore</code> (see the git section).    You can fill these files later.</li> </ul> </li> <li> <p>Create a new virtual environment for the project. </p> <p>Note</p> <p>A virtual environment is a directory that contains a copy of the Python libraries, specific for your project. You should create a new virtual environment for each project that you create. This will allow you to have different versions of the same library in different projects, and to avoid conflicts between them.</p> <p>If you are using PyCharm, click on the bottom right corner of the window, where it says \"No interpreter\", and select \"Add new interpreter\", and then \"Add local environment\". A pop-up window will appear:</p> <p> Creating a new virtual environment for the project. </p> <p>Select \"Virtualenv Environment\", and modify the name of your virtual environment folder: this is the name that  your virtual environment will take. Make sure to write the name of your virtual environment folder in the  <code>.gitignore</code> file, so that it is not committed to the repository. Then, select your Python interpreter.  Finally, click on \"OK\".</p> </li> <li> <p>Open a terminal and navigate to the directory that we have just created. If you open it from PyCharm, it will     automatically activate the virtual environment that we have just created. You will see that the name of the     virtual environment appears in the terminal, before the <code>$</code> symbol. For example, if you have named your virtual     environment <code>py10_my_project</code>, you will see something like this: </p> <p><pre><code>(py10_my_project) gerardpc@my_pc: ~/repositories/my_project$\n</code></pre> The <code>(py10_my_project)</code> part is the name of the virtual environment; if it is not there, it means that the virtual environment is not activated.</p> </li> <li> <p>From the terminal with the activated virtual environment, install poetry with the following command:</p> <pre><code>pip install poetry\n</code></pre> </li> <li> <p>Finally, run the following command:</p> <pre><code>poetry init\n</code></pre> <p>Poetry will then ask you several questions about your project. You can leave the default values for most of them. After answering all the questions, Poetry will ask you if you want to create a new virtual environment for your project. You should answer \"no\", since we have already created a virtual environment for our project.</p> <p>After the command is finished, you will see that Poetry has created a <code>pyproject.toml</code> file in your project. This file contains the configuration of our project, and is used to define the libraries that our  project uses. For example, it could look like this:</p> <p><pre><code>[tool.poetry]\nname = \"python-course\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"gerardpc &lt;gerard@ie.edu&gt;\"]\nreadme = \"README.md\"\npackages = [{include = \"python_course\"}]\n[tool.poetry.dependencies]\npython = \"&gt;=3.10,&lt;3.13\"\npandas = \"^2.1.1\"\nmatplotlib = \"^3.8.0\"\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre> The \"dependencies\" bit is the one that contains the libraries that our project uses. Of course, since we have just created the project, we have not added any dependencies yet.</p> </li> </ol> <p>With this, we have created our project. We can now start developing it.</p>"},{"location":"sections/python/python_projects/#adding-dependencies-with-poetry","title":"Adding dependencies with Poetry","text":"<p>Typically, we will want to add libraries to our project. In a common machine learning project, we will want to add libraries such as <code>pandas</code>, <code>numpy</code>, <code>scikit-learn</code>, <code>tensorflow</code>, etc. As stated before, we can add these libraries from a terminal with poetry, which will automatically install the correct versions of the libraries that we need and update the <code>pyproject.toml</code> and <code>poetry.lock</code> files.</p> <p>The most common poetry commands that we will use are the following:</p> <ul> <li> <p><code>poetry add &lt;library_name&gt;</code>: adds a new library to our project. For example, if we want to add <code>pandas</code> to our project, we can run the following command:</p> <pre><code>poetry add pandas\n</code></pre> <p>This will add <code>pandas</code> to our project, and update the <code>pyproject.toml</code> and <code>poetry.lock</code> files.</p> </li> <li> <p><code>poetry remove &lt;library_name&gt;</code>: removes a library from our project. For example, if we want to remove <code>pandas</code> from our project, we can run the following command:</p> <pre><code>poetry remove pandas\n</code></pre> <p>This will remove <code>pandas</code> from our project, and update the <code>pyproject.toml</code> and <code>poetry.lock</code> files.</p> </li> <li> <p><code>poetry install</code>: installs all the libraries that are defined in the <code>pyproject.toml</code> file. We will typically use this command when we clone a repository from GitHub, to install all the libraries that the project uses (because when we are developing from scratch, we will use <code>poetry add</code> to add new libraries to our project).</p> </li> <li> <p><code>poetry show</code>: shows the libraries that are defined in the <code>pyproject.toml</code> file.</p> </li> <li> <p>To update a specific package (already installed) to its latest version, we can run the following command:</p> <p><pre><code>poetry update &lt;library_name&gt;\n</code></pre> This will also update the <code>pyproject.toml</code> and <code>poetry.lock</code> files.</p> </li> </ul>"},{"location":"sections/python/python_projects/#developing-our-project","title":"Developing our project","text":""},{"location":"sections/python/python_projects/#committing-our-changes-with-git","title":"Committing our changes with Git","text":"<p>Every time we make an important change in our project, we should commit it to our local repository.  This will allow us to keep track of the changes in our code between different versions of our project. In practice this means that in a day of work, we will be doing several commits. </p>"},{"location":"sections/python/python_projects/#linting-and-formatting-before-committing","title":"Linting and formatting before committing","text":"<p>Before committing, we should try to use a code linter and formatter to make sure that our code is clean and consistent. We will use Ruff for this. First, we need to install it in our virtual environment:</p> <pre><code>poetry add ruff\n</code></pre> <p>To lint the code (i.e., checking for mistakes in coding or for \"bad practices\" that may lead to incorrect results, etc.), we can use the following command from the terminal:</p> <p><pre><code>ruff check .\n</code></pre> where the <code>.</code> means that we want to check the files in the current directory (we could also specify another file or directory). Ruff will then show us the changes that need to be made to the code: some can be fixed automatically by running</p> <pre><code>ruff check --fix .\n</code></pre> <p>Other errors will need to be fixed by hand (clicking to the link we will go automatically to the line in the code that needs to be fixed).</p> <p>To format the code (i.e., making sure that the code is written in a consistent style, with lines that are not too long, with nice looking indentations, etc.), we can use the following command from the terminal:</p> <pre><code>ruff --format .\n</code></pre> <p>This will format the code in the current directory (we could also specify another file or directory).</p> <p>Note</p> <p>We can change the default configuration of Ruff by adding a section to the <code>pyproject.toml</code> file. For example, we could add the following section to the <code>pyproject.toml</code> file:</p> <pre><code>[tool.ruff]\nmax_line_length = 88\n</code></pre> <p>For more information, see the Ruff documentation.</p>"},{"location":"sections/python/python_projects/#committing-with-pycharm","title":"Committing with PyCharm","text":"<p>Once the code is linted and formatted, we can commit it to our local repository. If we are using PyCharm, we can do this from the commit menu on the top left of the IDE; check this section for more information.</p>"},{"location":"sections/python/python_projects/#push-to-a-remote-repository","title":"Push to a remote repository","text":"<p>To push the changes to a remote repository, the remote repository first needs to exist! We will see how to create a remote repository in GitHub:</p> <ol> <li>Log in to Github. If you don't have an account, create one.</li> <li> <p>Click to \"New repository\". You will enter a page that should look like this:</p> <p> Creating a new repository in GitHub. </p> <p>The repository name should be the same as the name of your project. You can leave the other options as they are. Then, click on \"Create repository\".</p> </li> <li> <p>After creating the repository, you will see a page with the URL of the repository. Copy this URL. Then, go to your     terminal and run the following command:</p> <p><pre><code>git remote add origin &lt;url&gt;\n</code></pre> where <code>&lt;url&gt;</code> is the URL of your repository. This will add the remote repository to your local repository with the name <code>origin</code>.</p> </li> <li> <p>Finally, run the following command:</p> <p><pre><code>git push -u origin master\n</code></pre> This will push the changes in your local repository to the remote repository. Alternatively, you can do this from PyCharm, using the git menu on the bottom left of the IDE. Select the branch you want to push, and right click on it. Then, select \"Push\". If everything goes well, you will see a message saying that the push was successful, and  if you go to your repository in GitHub, you will see that the changes have been pushed.</p> <p>Note</p> <p>If you chose to make your repository public, anyone will be able to see your code and push changes to it.</p> </li> </ol>"},{"location":"sections/python/python_projects/#creating-a-command-line-interface-cli","title":"Creating a command line interface (CLI)","text":"<p>The most important scripts in our project will be the ones that we use to run our code. For example, if we are developing a machine learning model, we will have a script to train the model, and another script to make predictions with it. We will typically want to run these scripts from the terminal, with different arguments. This will allow us to run the code in a remote server, or for other people to run it without having to know Python or be familiar with  Jupyter notebooks.</p> <p>At a very high level, i.e., before we start coding, we should think about the different commands and arguments that we want to have in our CLI. Once we have a clear idea of what we want, we can start coding. There are several libraries to create CLIs in Python; in our project we will use Typer. See the corresponding section for more information.</p>"},{"location":"sections/python/python_projects/#converting-your-finished-repository-into-a-python-package","title":"Converting your (finished) repository into a Python package","text":""},{"location":"sections/python/python_projects/#python-packages-introduction","title":"Python packages introduction","text":"<p>A <code>.whl</code> (wheel) file is a distribution package file saved in Python\u2019s wheel format. It is a standard format  installation of Python distributions and contains all the files and metadata required for installation.  The WHL file also contains information about the Python versions and platforms supported by this wheel file.  WHL file format is a ready-to-install format that allows running the installation package without building the  source distribution.</p> <p>Note</p> <ul> <li>All else being equal, wheels are typically smaller in size than source distributions.</li> <li>Installing from wheels directly avoids the intermediate step of building packages off of  the source distribution.</li> </ul> <p>A <code>.whl</code> file is essentially a zip archive with a specially crafted filename that tells installers what  Python versions and platforms the wheel will support.</p>"},{"location":"sections/python/python_projects/#creating-a-wheel-with-poetry","title":"Creating a wheel with Poetry","text":"<p>We can create a wheel file for our project with Poetry quite easily. First, we need to use the <code>build</code> command:</p> <pre><code>poetry build\n</code></pre> <p>That's it! Poetry will create a <code>dist</code> directory in our project, which will contain the wheel file. For example, if our project is called <code>my_project</code>, the wheel file will be called <code>my_project-0.1.0-py3-none-any.whl</code>. If we want to publish our package to PyPI, we can do it with the following command:</p> <pre><code>poetry publish\n</code></pre> <p>This will make our package available to everyone in PyPI. However, be careful: PyPI is a public repository, and you should only publish packages that are ready to be used by other people, not as a homework submission!</p>"},{"location":"sections/python/regular_expressions/","title":"Regular expressions","text":""},{"location":"sections/python/regular_expressions/#introduction","title":"Introduction","text":"<p>Regular expressions are a powerful tool for matching patterns in text. They are used in many contexts, including  search engines, text editors, and programming languages. For example, if we wanted to find all the lines in a file that began with the word \"From:\", we could use the following regular expression:</p> <pre><code>import re\npattern = '^From:'\nwith open('file.txt') as f:\nfor line in f:\nif re.search(pattern, line):\nprint(line)\n</code></pre> <p>In this example, the <code>^</code> character matches the beginning of the line. This means that the pattern will only match lines that begin with the word \"From:\". </p> <p>Usage of such special characters is the main advantage of regular expressions. They allow you to create strings that match specific patterns of characters, such as digits, words, or whitespace. There are several different types of special characters, but they can be learned relatively quickly. For example, the following code matches any line that contains a word that begins with \"F\" and ends with \"m\":</p> <pre><code>import re\nstring_var = 'Farmland'\npattern = 'F.*m'\nif re.search(pattern, string_var):\nprint(\"Found a match!\")\n# Output:\n\"Found a match!\"\n</code></pre> <p>The use of these characters can be confusing at first, but once you've learned the basics, you'll be able to to use them to perform powerful text manipulation with just a few lines of code. This section will teach you  the basics of regular expressions in Python, and how to use them to search text.</p> <p>Note</p> <p>To check if a string matches a regular expression without using Python,  you can use this website: </p>"},{"location":"sections/python/regular_expressions/#python-re-module","title":"Python re module","text":"<p>Python has a built-in module called <code>re</code>, which can be used to work with regular expressions. The <code>re</code> module provides several functions that make it a powerful tool for working with regular expressions.</p> <p>Note</p> <p>The <code>re</code> module is part of the Python standard library, which means that it is installed by default when you install Python. This means that you don't need to install any additional packages to use regular expressions in Python. Doing <code>import re</code> is enough to use the <code>re</code> module.</p> <p>The most important functions in the <code>re</code> module are:</p> <ul> <li><code>re.search()</code>: try to find a match with the pattern anywhere in the string.</li> <li><code>re.findall()</code>: Return a list of all matches in the text.</li> <li><code>re.sub()</code>: Replaces one or more matches with a string.</li> <li><code>re.split()</code>: Splits the text into a list, splitting it wherever the pattern matches.</li> </ul> <p>Note</p> <p>The <code>re</code> module also contains the <code>re.match()</code> function, which is similar to <code>re.search()</code>, but it only matches the pattern if it occurs at the beginning of the string. However, using <code>re.search()</code> is usually preferred, because it is more flexible and can be used to match patterns anywhere in the string.</p> <p>Note</p> <p>Perhaps you come across the <code>re.compile()</code> function, which compiles a string into a regular expression object. However, this function is rarely used in practice, because the <code>re</code> module automatically compiles the string into a regular expression object when you use it (so typically the gains in performance are minimal).</p>"},{"location":"sections/python/regular_expressions/#regular-expression-syntax","title":"Regular expression syntax","text":"<p>Regular expressions are used to match patterns in text. They are made up of a combination of regular characters and special characters. Regular characters are characters that match themselves, such as the letter \"a\" or the digit \"1\". Special characters are characters that have a special meaning in regular expressions. For example, the special character <code>.</code> matches any character, while the special character <code>*</code> matches zero or more occurrences of the previous character (or group of characters, if they are grouped for example with parentheses).</p> <p>Note</p> <p>Regular expressions are case-sensitive, which means that uppercase and lowercase letters are treated as different characters. For example, the regular expression <code>a</code> will match the letter \"a\", but not the letter \"A\".</p> <p>You can find a list of all the special characters in the Python documentation.</p> <p>The following tables gives a summary of the most important special characters and groups:</p> Character Description <code>.</code> Matches any character except a newline. <code>^</code> Matches the start of the string. <code>$</code> Matches the end of the string. <code>*</code> Matches zero or more occurrences of the previous character. <code>+</code> Matches one or more occurrences of the previous character. <code>?</code> Matches zero or one occurrences of the previous character. <code>{n}</code> Matches exactly <code>n</code> occurrences of the previous character. <code>{n,}</code> Matches <code>n</code> or more occurrences of the previous character. <code>{n,m}</code> Matches between <code>n</code> and <code>m</code> occurrences of the previous character. <code>[...]</code> Matches any character (replace the <code>...</code>) inside the brackets. <code>[^...]</code> Matches any character (replace the <code>...</code>) not inside the brackets. <code>|</code> Matches either the expression before or after the <code>|</code>. <code>(...)</code> Matches the expression inside the parentheses and groups it. Parentheses can be used to group expressions and to define the precedence of operators, like in math. <code>\\</code> Escapes a special character (used to match, for example, the <code>.</code>). <code>\\d</code> Matches any digit character. <code>\\D</code> Matches any non-digit character. <code>\\w</code> Matches any alphanumeric character. <code>\\W</code> Matches any non-alphanumeric character. <code>\\s</code> Matches any whitespace character. <code>\\S</code> Matches any non-whitespace character. <code>\\b</code> Matches the empty string, but only at the beginning or end of a word. It is used to match whole words. <code>(?:...)</code> Matches the expression inside the parentheses, but does not add it to the match. <code>(?=...)</code> Matches if ... matches next, but doesn\u2019t consume any of the string. This is called a lookahead assertion <code>(?!...)</code> Matches if ... doesn\u2019t match next. This is a negative lookahead assertion. <code>(?&lt;=...)</code> Matches if the current position in the string is preceded by a match for ... that ends at the current position. This is called a lookbehind assertion. <code>(?&lt;!...)</code> Matches if the current position in the string is not preceded by a match for ... that ends at the current position. This is a negative lookbehind assertion. <p>The following table shows some examples of regular expressions and the strings that they match:</p> Regular expression Matches <code>a</code> The letter \"a\" <code>abc</code> The string \"abc\" <code>a.c</code> The string \"abc\", \"axc\", \"a1c\", etc. <code>a.*c</code> The string \"ac\", \"abc\", \"abbc\", \"abbbc\", etc. <code>a+c</code> The string \"ac\", \"aac\", \"aaac\", etc. <code>\\d{2}-\\d{3}</code> A string of the form \"12-345\" <code>(.*)(\\d{8}-[A-Z]{3})(.*)</code> e.g. \"John Doe 12345678-ABC\" <code>a| b</code> The string \"a\" or the string \"b\" <code>\\W(a| b)\\W</code> The string \" a \", \" b \", etc. <code>^a</code> The string \"a\" at the beginning of the string <code>a$</code> The string \"a\" at the end of the string <code>^a.*c$</code> The string \"ac\", \"abc\", \"abbc\", \"abbbc\", etc. <code>(?&lt;=a)b</code> The string \"b\" if it is preceded by the string \"a\" <code>(?&lt;!a)b</code> The string \"b\" if it is not preceded by the string \"a\" <code>b(?=a)</code> The string \"b\" if it is followed by the string \"a\" <code>b(?!a)</code> The string \"b\" if it is not followed by the string \"a\" <p>Note</p> <p>When defining a regular expression in Python, it is recommended to always use raw strings, which are strings that are prefixed with an <code>r</code>. This is because regular expressions often contain backslashes, which are special characters in Python strings. For example, the string literal <code>r\"\\n\"</code> consists of  two characters: a backslash and a lowercase <code>n</code>, in contrast to the string <code>\"\\n\"</code>, which Python would interpret as a single newline character.    </p>"},{"location":"sections/python/regular_expressions/#re-functions","title":"<code>re</code> functions","text":""},{"location":"sections/python/regular_expressions/#the-search-function","title":"The <code>search</code> function","text":"<p>The <code>re.search()</code> function takes two arguments: a regular expression pattern and a string. It searches the string for the pattern and returns a match object if it finds a match. If it doesn't find a match, it returns <code>None</code>.</p> <p>For example, the following code searches for the pattern <code>abc</code> in the string <code>abcdef</code>:</p> <pre><code>import re\npattern = 'abc'\nstring = 'abcdef'\nmatch = re.search(pattern, string)\nprint(match)\n# Output:\n&lt;re.Match object; span=(0, 3), match='abc'&gt;\n</code></pre> <p>The <code>match</code> object contains information about the match, including the start and end position of the match, and the string that was matched:</p> <ul> <li><code>match.group()</code>: returns the string that was matched (in the last example, this would be <code>'abc'</code>).</li> <li><code>match.start()</code>: returns the start position of the match.</li> <li><code>match.end()</code>: returns the end position of the match.</li> <li><code>match.span()</code>: returns a tuple containing the start and end positions of the match.</li> <li><code>match.string</code>: returns the whole string that was searched (in the last example, this would be <code>'abcdef'</code>).</li> <li><code>match.re</code>: returns the regular expression object that was used to create the match object.</li> </ul> <p>Note</p> <p>The search function only returns the first match. If you want to find all matches, you can use the <code>re.findall()</code> function, which returns a list of all matches.</p>"},{"location":"sections/python/regular_expressions/#the-findall-function","title":"The <code>findall</code> function","text":"<p>The <code>re.findall()</code> function returns a list of all matches in the string. For example, the following code searches for all occurrences of the pattern <code>abc</code> in the string <code>abcdefgeabc</code>:</p> <pre><code>import re\npattern = 'abc'\nstring = 'abcdefgeabc'\nmatches = re.findall(pattern, string)\nprint(matches)\n# Output:\n['abc', 'abc']\n</code></pre> <p>If there are no matches, <code>findall</code> will return an empty list.</p>"},{"location":"sections/python/regular_expressions/#the-sub-function","title":"The <code>sub</code> function","text":"<p>The <code>re.sub()</code> function replaces one or more matches with a string. It takes three arguments: a regular expression pattern, a replacement string, and a string to search. It returns a new string with the matches replaced.</p> <p>For example, the following code replaces all occurrences of the pattern <code>abc</code> with the string <code>xyz</code> in the string <code>abcdefgeabc</code>:</p> <pre><code>import re\npattern = 'abc'\nreplacement = 'xyz'\nstring = 'abcdefgeabc'\nnew_string = re.sub(pattern, replacement, string)\nprint(new_string)\n# Output:\n'xyzdefgexyz'\n</code></pre>"},{"location":"sections/python/regular_expressions/#the-split-function","title":"The <code>split</code> function","text":"<p>The <code>re.split()</code> function splits the string into a list, splitting it wherever the pattern matches. It takes two arguments: a regular expression pattern and a string to split. It returns a list of strings.</p> <p>For example, the following code splits the string <code>abc,def,ghi</code> into a list of strings:</p> <pre><code>import re\npattern = ','\nstring = 'abc,def,ghi'\nnew_string = re.split(pattern, string)\nprint(new_string)\n# Output:\n['abc', 'def', 'ghi']\n</code></pre> <p>This method is similar to the <code>str.split()</code> method, but it allows you to split the string using a regular expression instead of a fixed string.</p>"},{"location":"sections/python/regular_expressions/#string-manipulation-in-pandas","title":"String manipulation in Pandas","text":""},{"location":"sections/python/regular_expressions/#standard-string-methods","title":"Standard string methods","text":"<p>Pandas offers several methods and attributes that allow you to work with strings. These methods are similar to the string methods and attributes in Python, but they are designed to work with Pandas Series.</p> <p>These methods can be accessed using the <code>str</code> attribute of a Series. For example, the following code creates a Series containing the strings \"John Doe\" and \"Jane Doe\", and then uses the <code>str.upper()</code> method to convert the strings to uppercase:</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'name': ['John Doe', 'Jane Doe']})\ndf['name'] = df['name'].str.upper()\nprint(df)\n# Output:\nname\n0   JOHN DOE\n1   JANE DOE\n</code></pre> <p>The following table gives an overview of the most important string methods in Pandas:</p> Method Description <code>str.lower()</code> Converts all characters to lowercase. <code>str.upper()</code> Converts all characters to uppercase. <code>str.title()</code> Converts the first character of each word to uppercase and the rest to lowercase. <code>str.capitalize()</code> Converts the first character to uppercase and the rest to lowercase. <code>str.strip()</code> Removes leading and trailing whitespace. <code>str.lstrip()</code> Removes leading whitespace. <code>str.rstrip()</code> Removes trailing whitespace. <code>str.replace()</code> Replaces all occurrences of a string with another string. <code>str.split()</code> Splits the string into a list of strings. <code>str.join()</code> Joins the elements of a list into a string. <code>str.cat()</code> Concatenates strings in a Series."},{"location":"sections/python/regular_expressions/#regular-expressions-in-pandas","title":"Regular expressions in Pandas","text":"<p>Pandas also offers several functions that allow you to use regular expressions to search and replace text in  a DataFrame. These functions are:</p> <ul> <li><code>str.contains()</code>: Returns a boolean Series indicating whether each string contains a match of a regular expression.</li> <li><code>str.findall()</code>: Returns a Series containing lists of all matches of a regular expression.</li> <li><code>str.replace()</code>: Replaces all matches of a regular expression with some other string.</li> </ul> <p>These functions are similar to the described functions in the <code>re</code> module, but they are designed to work with Pandas Series and DataFrames. For example, the following code searches for all rows in the DataFrame <code>df</code> where the column <code>name</code> contains the string \"John\":</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'name': ['John Doe', 'Jane Doe', 'John Smith', 'Jane Smith']})\npattern = 'John'\nmatches = df['name'].str.contains(pattern)\nprint(matches)\n# Output:\n0     True\n1    False\n2     True\n3    False\nName: name, dtype: bool\n</code></pre> <p>The <code>contains</code> and <code>findall</code> functions are typically used to create boolean masks, which can be used to filter the DataFrame. For example, the following code creates a boolean mask that is <code>True</code> for all rows where the column <code>name</code> contains the string \"John\":</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'name': ['John Doe', 'Jane Doe', 'John Smith', 'Jane Smith']})\npattern = 'John'\ndf_john = df.loc[df['name'].str.contains(pattern), :]\nprint(df_john)\n# Output:\nname\n0    John Doe\n2  John Smith\n</code></pre> <p>The <code>replace</code> function is typically used to replace text in a DataFrame. For example, the following code replaces all occurrences of the string \"John\" with the string \"Jane\" in the column <code>name</code>:</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'name': ['John Doe', 'Jane Doe', 'John Smith', 'Jane Smith']})\npattern = 'John'\nreplacement = 'Jane'\ndf['name'] = df['name'].str.replace(pattern, replacement)\nprint(df)\n# Output:\nname\n0    Jane Doe\n1    Jane Doe\n2  Jane Smith\n3  Jane Smith\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/","title":"Matplotlib","text":""},{"location":"sections/python_libraries/matplotlib/#introduction","title":"Introduction","text":"<p>Matplotlib is a plotting library for Python. It is a very powerful library and is used by many other  Python libraries, such as Pandas, Seaborn, and Plotly.</p> <p>Matplotlib is a relatively low-level library, meaning that it provides lots of flexibility to create custom plots, while at the same time it requires more code to do so. Other libraries, such as Seaborn, are built on top of Matplotlib and provide a higher-level interface.</p> <p>Note</p> <p>This article is just an introduction to matplotlib, and is based on the Matplotlib documentation. For more details, please refer to the documentation.</p>"},{"location":"sections/python_libraries/matplotlib/#plotting-with-subplots","title":"Plotting with subplots","text":"<p>Typically, we import Matplotlib as follows and then create a subplots object:</p> <pre><code>import matplotlib.pyplot as plt\nfig, ax = plt.subplots()\n</code></pre> <p><code>subplots</code> is a function that returns a <code>Figure</code> object and an <code>Axes</code> object. You can imagine the <code>Figure</code> object  as a canvas that contains all the plots that we want to create, while the <code>Axes</code> object is the actual plot (the blank  sheet you can plot and hold your data), and is synonymous with the term subplot (because each <code>axes</code> can have several subplots).</p> <p>Note</p> <p>To specify the number of subplots that we want to create, we can pass the <code>nrows</code> and <code>ncols</code> arguments to the <code>subplots</code> function. For example, to create a figure with 2 rows and 2 columns, we can do:</p> <pre><code>fig, ax = plt.subplots(2, 2)\n</code></pre> <p>After we have called <code>subplots</code>, we can use the <code>plot</code> method of the <code>Axes</code> object to plot some data with a line connecting the different data points. The input to the <code>plot</code> method is typically two arrays, one for the x-axis and one for the y-axis. For example,  if we have time-series data, we can plot the time on the x-axis and the values on the y-axis:</p> <pre><code>ax.plot(climate_change['date'], climate_change['co2'])\nax.set(\ntitle='Amount of CO2 (ppm) in each year', \nxlabel='Year',\nylabel='Amount of CO2 (ppm)'\n)\n</code></pre> <p>Note</p> <p>In the last example, the input to the <code>plot</code> method were two columns of a Pandas DataFrame. However, the <code>plot</code> method can also take two arrays as input. Basically, matplotlib <code>.plot(...)</code> requires the first two arguments to be of array-like type (e.g. lists, NumPy arrays, etc.), and the rest of the arguments are optional.</p> <p>If we are creating several subplots at the same time, we can use the <code>ax</code> argument to specify which subplot we want to plot on:</p> <pre><code>fig, axs = plt.subplots(2, 2)\naxs[0, 0].plot(x, y)\naxs[0, 0].set_title('Axis [0, 0]')\naxs[0, 1].plot(x, y, 'tab:orange')\naxs[0, 1].set_title('Axis [0, 1]')\naxs[1, 0].plot(x, -y, 'tab:green')\naxs[1, 0].set_title('Axis [1, 0]')\naxs[1, 1].plot(x, -y, 'tab:red')\naxs[1, 1].set_title('Axis [1, 1]')\n</code></pre> <p> </p> 4 subplots in a single figure. <p>Among other parameters, <code>.subplots()</code> have two parameters to specify the grid size. nrows and ncols are used  to point out the number of rows and columns we need respectively.</p>"},{"location":"sections/python_libraries/matplotlib/#plot-parameters","title":".plot() parameters","text":"<p>The <code>.plot()</code> method has a lot of parameters that can be used to customize the plot. For example, we can change the color, width and the line style of the plot:</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n# Fixing random state for reproducibility\nnp.random.seed(19680801)\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\ncolors = np.random.rand(N)\narea = (30 * np.random.rand(N))**2  # 0 to 15 point radii\nfig, axs = plt.subplots(1, 1)\nax.scatter(x, y, s=area, c=colors, alpha=0.5)\n</code></pre> <p>The color can be specified in different ways. For example, we can use the name of the color, as in the previous example, or we can use the hexadecimal code of the color:</p> <pre><code>ax.plot(x, y, color='#eeefff')\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#other-types-of-plots","title":"Other types of plots","text":""},{"location":"sections/python_libraries/matplotlib/#scatter-plots","title":"Scatter plots","text":"<p>To create a histogram of the distribution of the data for a single 1D array, we can use the <code>hist</code> method:</p> <pre><code>fig, axs = plt.subplots(1, 1)\nax.scatter(x, y, color='green'')\n</code></pre> <p> </p> A scatter plot example."},{"location":"sections/python_libraries/matplotlib/#histograms","title":"Histograms","text":"<p>To create a histogram of the distribution of the data for a single 1D array, we can use the <code>hist</code> method:</p> <pre><code>fig, axs = plt.subplots(1, 2)\nn_bins = 20\naxs[0].hist(dist1, bins=n_bins)\naxs[1].hist(dist2, bins=n_bins)\n</code></pre> <p> </p> A double histogram example."},{"location":"sections/python_libraries/matplotlib/#bar-plots","title":"Bar plots","text":"<p>To create a bar plot, we can use the <code>bar</code> method:</p> <pre><code>fig, ax = plt.subplots(1, 1)\n# Defines X-axis labels and Y-axis values\nfruits = ['apple', 'blueberry', 'cherry', 'orange']\ncounts = [40, 100, 30, 55]\nbar_labels = ['red', 'blue', '_red', 'orange']\nbar_colors = ['tab:red', 'tab:blue', 'tab:red', 'tab:orange']\nax.bar(fruits, counts, label=bar_labels, color=bar_colors)\n</code></pre> <p> </p> A bar plot example."},{"location":"sections/python_libraries/matplotlib/#more-types-of-plots","title":"More types of plots","text":"<p>You can find a list of all the different types of plots that can be created with Matplotlib in the Matplotlib gallery.</p>"},{"location":"sections/python_libraries/matplotlib/#show-figure","title":"Show figure","text":"<p>Once the plot is ready, we can show the figure with the <code>show</code> method: <pre><code>plt.show()\n</code></pre> This will open a new window with the figure. </p>"},{"location":"sections/python_libraries/matplotlib/#save-figure","title":"Save figure","text":"<p>Finally, we can also save the figure as a file (e.g., a png or an svg file) with the <code>savefig</code> method:</p> <pre><code>fig.savefig('co2_levels.png')\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#minimal-working-example","title":"Minimal working example","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n# Create data for plotting. Any pair of 1D data can be used here,\n# for example two columns of a Pandas DataFrame.\nt = np.arange(0.0, 2.0, 0.01)\ns = 1 + np.sin(2 * np.pi * t)\n# Create figure and axes\nfig, ax = plt.subplots()\n# Plot data\nax.plot(t, s)\n# Customize plot\nax.set(xlabel='time (s)', ylabel='voltage (mV)',\ntitle='About as simple as it gets, folks')\n# add a grid and legend\nax.grid()\nax.legend()\n# save as file and show window with plot\nfig.savefig(\"test.png\")\nplt.show()\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#other-options-to-customize-the-plot","title":"Other options to customize the plot","text":""},{"location":"sections/python_libraries/matplotlib/#legends","title":"Legends","text":"<p>There are many other options that can be used to customize the plot. For example, we can add a legend to the plot with the <code>legend</code> method:</p> <pre><code>ax.legend()\n</code></pre> <p>The <code>legend</code> method will use the <code>label</code> argument of the <code>plot</code> method to create the legend. We can also specify the location of the legend with the <code>loc</code> argument:</p> <pre><code>ax.legend(loc='upper center')\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#xlim-and-ylim","title":"xlim and ylim","text":"<p>Another useful method is <code>set_xlim</code> and <code>set_ylim</code>, which sets the limits of the x-axis and y-axis. They are used to only show a part of the plot, for example:</p> <pre><code>ax.set_xlim([1980, 1990])\nax.set_ylim([0, 2.5])\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#customizing-the-font","title":"Customizing the font","text":"<p>We can customize the fonts of the plot defining a <code>fontdict</code> dictionary and passing it to the <code>set_XXX</code> methods:</p> <pre><code>fontdict={'fontsize': 18, 'fontweight': 'bold', 'color': 'blue', 'family': 'serif'}\nax.set_title('Amount of CO2 (ppm) in each year', **fontdict)\nax.set_xlabel('Year', **fontdict)\nax.set_ylabel('Amount of CO2 (ppm)', **fontdict)\n</code></pre> <p>Another way to customize the font is to use the rcParams dictionary. This will change the default font for all the plots. For example, to change the font size and family, we can do:</p> <pre><code>plt.rcParams.update({'font.size': 18, 'font.family': 'serif'})\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#customizing-ticks","title":"Customizing ticks","text":"<p>We can customize the ticks of the plot (i.e., what numbers are shown in the x-axis and y-axis) with the <code>set_xticks</code> and <code>set_yticks</code> methods:</p> <pre><code>ax.set_xticks([1980, 1990, 2000, 2010, 2020])\nax.set_yticks([0, 1, 2, 3, 4, 5])\n</code></pre>"},{"location":"sections/python_libraries/matplotlib/#grid","title":"Grid","text":"<p>We can also add a grid to the plot with the <code>grid</code> method:</p> <pre><code>ax.grid()\n</code></pre> <p> </p> Sample figure with a grid."},{"location":"sections/python_libraries/numpy/","title":"Numpy","text":""},{"location":"sections/python_libraries/numpy/#introduction","title":"Introduction","text":"<p>Numpy is a library for scientific computing in Python. It provides a multidimensional array object, the <code>ndarray</code> (often known as just an array) that can be thought of as a generalization of a matrix. It also provides a  large collection of high-level and very efficient mathematical functions to operate on these arrays, including:</p> <ul> <li>Generic mathematical and logical operations</li> <li>Array shape manipulation</li> <li>Sorting</li> <li>Linear algebra</li> <li>Fourier transforms</li> <li>Basic statistical operations (including random numbers)</li> </ul> <p>and much more.</p>"},{"location":"sections/python_libraries/numpy/#installation","title":"Installation","text":"<p>Numpy is installed by default in Anaconda. If you are using a different Python distribution, you can  install it using pip:</p> <pre><code>pip install numpy\n</code></pre>"},{"location":"sections/python_libraries/numpy/#importing","title":"Importing","text":"<p>To import numpy, use the following command:</p> <pre><code>import numpy as np\n</code></pre> <p>Note</p> <p>It is a convention to import numpy as <code>np</code>. You can, of course, use any other name.</p>"},{"location":"sections/python_libraries/numpy/#arrays","title":"Arrays","text":"<p>The ndarray is a multidimensional array of elements of the same type, usually of numbers either integers or floats. The number of dimensions and items in an array is defined by its shape, which is a tuple of N non-negative integers.</p> <p>Note</p> <p>Numpy arrays may look similar to Python lists, but they are actually very different. For example, unlike lists, numpy arrays have a fixed size at creation time, and the elements of an array must be of the same type. Hence, there are no type-checks when iterating through the elements of an array, which makes iteration through an array much faster than through a list. </p> <p>Another important difference is that operations between arrays are vectorized, which means that they are performed on all the elements of the arrays \"at the same time\", which makes them much faster than operations between lists (which require <code>for</code> loops). The price to pay is that you can't use the <code>append</code> or <code>extend</code> methods of lists to change the size of an array. Instead, you need to create a new array with the desired size.</p>"},{"location":"sections/python_libraries/numpy/#creating-arrays","title":"Creating Arrays","text":"<p>There are several ways to create numpy arrays. The most common way is to create an array from a Python list, using the <code>array</code> function:</p> <pre><code>a = np.array([1, 2, 3])\nprint(a)\n# Output:\n[1 2 3]\n</code></pre> <p>You can also create a multidimensional array by passing a list of lists:</p> <pre><code>a = np.array([[1, 2, 3], [4, 5, 6]])\n</code></pre> <p>The array type can be explicitly specified at creation time:</p> <pre><code>a = np.array([1, 2, 3], dtype=float)\n</code></pre> <p>You can also create arrays filled with zeros or ones:</p> <pre><code>a = np.zeros((3, 3))\nb = np.ones((3, 3))\n</code></pre> <p>To create sequences of numbers, NumPy provides the <code>arange</code> function which is analogous to the Python built-in  range, but returns an array.</p> <pre><code>a = np.arange(10) # 0 .. n-1  (!)\nb = np.arange(1, 9, 2) # start, end (exclusive), step\n</code></pre> <p>For creating arrays with evenly spaced numbers, there is also the <code>linspace</code> function:</p> <pre><code>a = np.linspace(0, 1, 6)   # start, end, num-points\nprint(a)\n# Output:\n[0. 0.2 0.4 0.6 0.8 1.]\n</code></pre>"},{"location":"sections/python_libraries/numpy/#array-attributes","title":"Array attributes","text":"<p>The most important attributes of an ndarray object are:</p> <ul> <li><code>ndarray.ndim</code>: the number of axes (dimensions) of the array.</li> <li><code>ndarray.shape</code>: the dimensions of the array. This is a tuple of integers indicating the size of the array  in each dimension. For a matrix with <code>n</code> rows and <code>m</code> columns, <code>shape</code> will be <code>(n,m)</code>. The length of  the <code>shape</code> tuple is therefore the number of axes, <code>ndim</code>.</li> <li><code>ndarray.size</code>: the total number of elements of the array. This is equal to the product of the elements of <code>shape</code>.</li> <li><code>ndarray.dtype</code>: an object describing the type of the elements in the array. One can create or specify dtype\u2019s using standard Python types. Additionally NumPy provides types of its own (e.g. <code>numpy.int32</code> or <code>numpy.int16</code>).</li> <li><code>ndarray.itemsize</code>: the size in bytes of each element of the array. For example, an array of elements of type <code>float64</code> has <code>itemsize</code> 8 (=64/8), while one of type <code>complex32</code> has <code>itemsize</code> 4 (=32/8).</li> </ul>"},{"location":"sections/python_libraries/numpy/#basic-operations","title":"Basic operations","text":"<p>Python arithmetic operators on arrays apply elementwise. A new array is created and filled with the result.</p> <p><pre><code>a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = a + b\nprint(c)\n# Output:\n[5 7 9]\n</code></pre> Unlike in many matrix languages, the product operator <code>*</code> operates elementwise in NumPy arrays.  The matrix product can be performed using the <code>@</code> operator (in python &gt;=3.5):</p> <pre><code>a = np.array([[1, 2, 3], [4, 5, 6]])\nb = np.array([[1, 2], [3, 4], [5, 6]])\nc = a @ b\nprint(c)\n# Output:\n[[22 28]\n[49 64]]\n</code></pre> <p>Some operations, such as <code>+=</code> and <code>*=</code>, act in place to modify an existing array rather than create a new one. When operating with arrays of different types, the type of the resulting array corresponds to the more  general or precise one (a behavior known as upcasting).</p>"},{"location":"sections/python_libraries/numpy/#methods","title":"Methods","text":"<p>Many unary operations, such as computing the sum of all the elements in the array, are implemented as  methods of the ndarray class</p> <pre><code>a = np.array([[1, 2, 3], [4, 5, 6]])\nprint(a.sum())\n# Output:\n21\n</code></pre> <p>By default, these operations apply to the array as though it were a list of numbers, regardless of its shape.  However, by specifying the axis parameter you can apply an operation along the specified axis of an array: <pre><code>b = np.arange(12).reshape(3, 4)\nprint(b)\n# Output:\n[[ 0  1  2  3]\n[ 4  5  6  7]\n[ 8  9 10 11]]\nprint(b.sum(axis=0))     # sum of each column\n# Output:\n[12 15 18 21]\nprint(b.min(axis=1))     # min of each row\n# Output:\n[0 4 8]\nprint(b.cumsum(axis=1))  # cumulative sum along each row\n# Output:\n[[ 0  1  3  6]\n[ 4  9 15 22]\n[ 8 17 27 38]]\n</code></pre></p>"},{"location":"sections/python_libraries/numpy/#universal-functions","title":"Universal functions","text":"<p>NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called universal functions. Within NumPy, these functions operate elementwise on an array, producing an array as output.</p> <pre><code>a = np.arange(3)\nprint(np.exp(a))\n# Output:\n[1.         2.71828183 7.3890561 ]\n</code></pre>"},{"location":"sections/python_libraries/numpy/#indexing-slicing-and-iterating","title":"Indexing, Slicing and Iterating","text":"<p>One-dimensional arrays can be indexed, sliced and iterated over, much like lists and other Python sequences.</p> <pre><code>a = np.arange(10)**3\nprint(a)\n# Output:\n[  0   1   8  27  64 125 216 343 512 729]\nprint(a[2:5])\n# Output:\n[ 8 27 64]\n</code></pre> <p>We can use logical operators to select elements from an array:</p> <pre><code>b = np.arange(12).reshape(3, 4)\nprint(b)\n# Output:\n[[ 0  1  2  3]\n[ 4  5  6  7]\n[ 8  9 10 11]]\nprint(b[b &gt; 4])\n# Output:\n[ 5  6  7  8  9 10 11]\n</code></pre> <p>Multidimensional arrays can have one index per axis. These indices are given in a tuple separated by commas:</p> <pre><code>def f(x, y):\nreturn 10*x+y\nb = np.fromfunction(f, (5, 4), dtype=int)\nprint(b)\n# Output:\n[[ 0  1  2  3]\n[10 11 12 13]\n[20 21 22 23]\n[30 31 32 33]\n[40 41 42 43]]\nprint(b[2, 3])\n# Output:\n23\nprint(b[0:5, 1])  # each row in the second column of b\n# Output:\n[ 1 11 21 31 41]\n</code></pre>"},{"location":"sections/python_libraries/numpy/#stacking-together-different-arrays","title":"Stacking together different arrays","text":"<p>Several arrays can be stacked together along different axes:</p> <pre><code>a = np.floor(10*np.random.random((2,2)))\nb = np.floor(10*np.random.random((2,2)))\nprint(np.vstack((a,b)))\n# Output:\n[[5. 9.]\n[0. 0.]\n[1. 7.]\n[8. 2.]]\nprint(np.hstack((a,b)))\n# Output:\n[[5. 9. 1. 7.]\n[0. 0. 8. 2.]]\n</code></pre>"},{"location":"sections/python_libraries/numpy/#linear-algebra","title":"Linear algebra","text":"<p>NumPy provides the <code>linalg</code> package to perform linear algebra operations. To compute the inverse of a matrix:</p> <pre><code>a = np.array([[1., 2.], [3., 4.]])\nprint(np.linalg.inv(a))\n# Output:\n[[-2.   1. ]\n[ 1.5 -0.5]]\n</code></pre> <p>To compute the eigenvalues and eigenvectors of a square matrix:</p> <pre><code>a = np.array([[1., 2.], [3., 4.]])\nw, v = np.linalg.eig(a)\nprint(w)\n# Output:\n[-0.37228132  5.37228132]\nprint(v)\n# Output:\n[[-0.82456484 -0.41597356]\n[ 0.56576746 -0.90937671]]\n</code></pre>"},{"location":"sections/python_libraries/numpy/#random-numbers","title":"Random numbers","text":"<p>NumPy has powerful random number generating capabilities. It uses a particular algorithm called the Mersenne Twister to generate pseudorandom numbers. The <code>random</code> module provides tools for making random selections. For example, to pick a random number from a uniform distribution:</p> <pre><code>print(np.random.rand())\n# Output:\n0.47108547995356098\n</code></pre> <p>To pick a random number from a normal distribution:</p> <pre><code>print(np.random.normal(loc=0.0, scale=1.0))\n# Output:\n-0.72487283708301885\n</code></pre>"},{"location":"sections/python_libraries/pandas/","title":"Pandas","text":""},{"location":"sections/python_libraries/pandas/#introduction","title":"Introduction","text":"<p>Pandas is a high-level data manipulation tool built with the Numpy package. Its key data structure is called the  DataFrame, which allow us to store and manipulate tabular data (we can think of the rows as different \"observations\"  and the columns as the variables).</p> <p>Note</p> <p>Intuitively, pandas DataFrames can be thought of as a way to hold Excel spreadsheets data in a Python object.</p> <p>Since Pandas is not part of the standard Python library, we will need to install it first in the virtual  environment, for instance with <code>pip</code>:</p> <pre><code>pip install pandas\n</code></pre> <p>Once we have it installed, to use it in the code will need to import it with</p> <pre><code>import pandas\n# Code here\n...\n</code></pre> <p>Note</p> <p>Often, pandas is renamed to <code>pd</code> in the import, as: <pre><code>import pandas as pd\n</code></pre> This is of course not mandatory, but very common.    </p> <p>After importing the package, we can start using its most important object, the DataFrame.  There are several ways to create a DataFrame, for example:</p> <p><pre><code>dict = {\"country\": [\"Brazil\", \"Russia\", \"India\", \"China\", \"South Africa\"],\n\"capital\": [\"Brasilia\", \"Moscow\", \"New Dehli\", \"Beijing\", \"Pretoria\"],\n\"area\": [8.516, 17.10, 3.286, 9.597, 1.221],\n\"population\": [200.4, 143.5, 1252, 1357, 52.98] }\nimport pandas as pd\nbrics = pd.DataFrame(dict)\nprint(brics)\n</code></pre> which outputs <pre><code>     area    capital       country  population\n0   8.516   Brasilia        Brazil      200.40\n1  17.100     Moscow        Russia      143.50\n2   3.286  New Dehli         India     1252.00\n3   9.597    Beijing         China     1357.00\n4   1.221   Pretoria  South Africa       52.98\n</code></pre></p> <p>Note</p> <p>If you want a nice, complete introduction and walkthrough to Pandas, it is recommended to check the official documentation's own guide. The notes in this page are not comprehensive.</p>"},{"location":"sections/python_libraries/pandas/#pandas-vs-excel","title":"Pandas vs. Excel","text":"<p>Tasks such as data cleaning, data normalization, visualization, and statistical analysis can be performed on  both Excel and Pandas. That being said, Pandas has some major benefits over Excel:</p> <ul> <li>Limitation by size: Excel can handle around 1 million rows, while Python can handle millions and millions of rows  (the limitation is on PC computing power and memory).</li> <li>Complex data transformation: Memory-intensive computations in Excel can crash a workbook.  Python can handle complex computations without major problems.</li> <li>Automation: Excel was not designed to automate tasks. You can create a macro or use VBA to simplify some tasks,  but Python is a general programming language (meaning we can program almost anything).</li> </ul>"},{"location":"sections/python_libraries/pandas/#basic-objects-series-and-dataframes","title":"Basic objects: Series and Dataframes","text":"<p>Fundamentally, Pandas has two main objects that we will be using: </p> <ul> <li>Pandas Series are one-dimensional labeled arrays capable of holding any data  type (integers, strings, floating point numbers, Python objects, etc.). We can think of a Pandas Series as a single \"column\" of a table.</li> <li>Pandas Dataframes are 2-dimensional labeled data structures with columns of potentially different  types. We can think of it like a spreadsheet or SQL table, or a dict of Series objects. </li> </ul> <p>Note</p> <p>In general we will only be using Pandas Dataframes, which are the most commonly used pandas object. However, since Pandas Dataframes are a collection of Pandas Series, Series will appear often as the result of using some of the methods of Dataframes.</p>"},{"location":"sections/python_libraries/pandas/#series-creation","title":"Series creation","text":"<p>In a Series object, the axis labels are collectively referred to as the index. The basic method  to create a Series is to call:</p> <pre><code>s = pd.Series(data, index=index_name)\n</code></pre> <p>Here, data can be many different things, but they need to be 1D. For example:</p> <ul> <li>A Python dict or list</li> <li>A scalar value</li> <li>A numpy array</li> </ul> <p>If <code>data</code> is a numpy array, index must be the same length as data. If no index is passed,  one will be created having values <code>[0, ..., len(data) - 1]</code>.</p> <pre><code>s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\ns\nOut[4]: \na    0.469112\nb   -0.282863\nc   -1.509059\nd   -1.135632\ne    1.212112\ndtype: float64\ns.index\nOut[5]: Index(['a', 'b', 'c', 'd', 'e'], dtype='object')\npd.Series(np.random.randn(5))\nOut[6]: \n0   -0.173215\n1    0.119209\n2   -1.044236\n3   -0.861849\n4   -2.104569\ndtype: float64\n</code></pre> <p>Note</p> <p>The index of a Series is used to label and identify each element of the underlying data. We can access the index of a Series with the <code>.index</code> attribute: <pre><code>cities = ['Kolkata', 'Chicago', 'Toronto', 'Lisbon']\npopulations = [14.85, 2.71, 2.93, 0.51]\ncity_series = pd.Series(populations, index=cities)\nprint(city_series.index)\n# Output:\nIndex(['Kolkata', 'Chicago', 'Toronto', 'Lisbon'], dtype='object')\n</code></pre></p>"},{"location":"sections/python_libraries/pandas/#dataframe-creation","title":"Dataframe creation","text":"<p>DataFrames are, in practice, a dictionary of columns. That's why column labels must be unique.  Each column corresponds to a <code>Series</code>, and different columns can be of different type. Rows are  identified by an index, shared by all the columns (and may be non-unique). </p> <p>To instantiate a DataFrame we may use different kinds of input, such as:</p> <ul> <li> <p>A <code>dict</code> of 1D objects: Numpy arrays, lists, dicts, or Series. In any case, the arrays must all be the same length.  If an index is passed, it must also be the same length as the arrays. If no index is passed, the result will be  <code>range(n)</code>, where <code>n</code> is the array length:</p> <pre><code>d = {\"one\": [1.0, 2.0, 3.0, 4.0], \"two\": [4.0, 3.0, 2.0, 1.0]}\npd.DataFrame(d)\nOut[46]: \none  two\n0  1.0  4.0\n1  2.0  3.0\n2  3.0  2.0\n3  4.0  1.0\npd.DataFrame(d, index=[\"a\", \"b\", \"c\", \"d\"])\nOut[47]: \none  two\na  1.0  4.0\nb  2.0  3.0\nc  3.0  2.0\nd  4.0  1.0\n</code></pre> </li> <li> <p>From a list of dicts (where each dict has the same keys, which correspond to the DataFrame-to-be columns):</p> <pre><code>In [53]: data2 = [{\"a\": 1, \"b\": 2}, {\"a\": 5, \"b\": 10, \"c\": 20}]\nIn [54]: pd.DataFrame(data2)\nOut[54]: \na   b     c\n0  1   2   NaN\n1  5  10  20.0\nIn [55]: pd.DataFrame(data2, index=[\"first\", \"second\"])\nOut[55]: \na   b     c\nfirst   1   2   NaN\nsecond  5  10  20.0\nIn [56]: pd.DataFrame(data2, columns=[\"a\", \"b\"])\nOut[56]: \na   b\n0  1   2\n1  5  10\n</code></pre> </li> <li> <p>Tables from a <code>.csv</code> file or Excel file (e.g., <code>.xlsx</code>)</p> </li> <li>A single Pandas Series</li> <li>2-D numpy.ndarray</li> </ul> <p>In any case, the DataFrame construction always follows the same syntax: <pre><code>import pandas as pd\n# suppose \"a\" is a Python object type that can be converted to a DataFrame\na = ...\n# DataFrame object creation\ndf = pd.DataFrame(a)\n</code></pre></p> <p>Note</p> <p>Although Series are 1D, nothing prevents us from converting a Pandas Series into a Pandas DataFrame. This is often very convenient since DataFrames and Series do not have the same methods available.</p>"},{"location":"sections/python_libraries/pandas/#readingwriting-dataframes","title":"Reading/writing dataframes","text":"<p>Dataframes are very useful, but how can we transfer tabular information between different Python sessions?</p> <p>Note</p> <p>Remember that information stored in Python objects disappears once the current execution is finished.</p> <p>The most common way to achieve this is to save the tables in files. These files can be reused in future executions, or transferred through the internet (this is mostly how we download datasets from the internet).</p> <p>A simple way to store big data sets is to use <code>.csv</code> files (comma separated files). CSV files contain plain text and is a well known format that can be read by everyone (including Pandas).</p>"},{"location":"sections/python_libraries/pandas/#reading-from-a-csv","title":"Reading from a CSV","text":"<p>Reading from a CSV is as easy as:</p> <pre><code>import pandas as pd\ndf = pd.read_csv('data.csv')\nprint(df.to_string()) \n# Output\nDuration  Pulse  Maxpulse  Calories\n0          60    110       130     409.1\n1          60    117       145     479.0\n2          60    103       135     340.0\n3          45    109       175     282.4\n</code></pre> <p>If the file has a header, or uses different characters (instead of commas), the pandas documentation has several examples on how to use the <code>.read_csv()</code> method.</p> <p>Note</p> <p>In the previous example, the <code>to_string()</code> method is not really necessary. This method is used to make sure that we are printing the whole DataFrame (otherwise, if it has many columns and rows,  pandas might shorten it when we try to print).</p>"},{"location":"sections/python_libraries/pandas/#saving-to-a-csv","title":"Saving to a CSV","text":"<p>Saving an already existing DataFrame <code>df</code> into a <code>.csv</code> can be accomplished with:</p> <pre><code>df.to_csv('file_name.csv')\n</code></pre> <p>If you want to export without the index, simply add index=False;</p> <pre><code>df.to_csv('file_name.csv', index=False)\n</code></pre> <p>If you get a <code>UnicodeEncodeError</code>, simply add encoding='utf-8':</p> <pre><code>df.to_csv('file_name.csv', encoding='utf-8')\n</code></pre>"},{"location":"sections/python_libraries/pandas/#converting-a-dataframe-to-a-dictionary","title":"Converting a dataframe to a dictionary","text":"<p>We can convert a dataframe to a dictionary with the <code>.to_dict()</code> method. This method has several options, but the most common one is to convert the dataframe to a dictionary of lists, where the keys are the column names and the values are the values of each column:</p> <pre><code>import pandas as pd\ndf = pd.DataFrame(\n{\n\"first\": [\"John\", \"Mary\"],\n\"last\": [\"Doe\", \"Bo\"],\n\"job\": [\"Nurse\", \"Economist\"],\n\"height\": [5.5, 6.0],\n\"weight\": [130, 150],\n}\n)\nprint(df.to_dict())\n# Output\n{'first': {0: 'John', 1: 'Mary'}, \n'last': {0: 'Doe', 1: 'Bo'}, \n'job': {0: 'Nurse', 1: 'Economist'}, \n'height': {0: 5.5, 1: 6.0}, \n'weight': {0: 130, 1: 150}\n}\n</code></pre> <p>There are other options, such as converting the dataframe to a dictionary of lists (<code>orient=\"list\"</code>), or to a list of dictionaries (<code>orient=\"records\"</code>).</p>"},{"location":"sections/python_libraries/pandas/#viewing-dataframes","title":"Viewing DataFrames","text":"<p>To view the contents of a DataFrame, we can use one of several options:</p> <ul> <li>Using the <code>print(some_dataframe)</code> function</li> <li>To view the top of a dataframe, use <code>DataFrame.head()</code></li> <li>To view the bottom of a dataframe, use <code>DataFrame.tail()</code></li> </ul> <pre><code>In [13]: df.head()\nOut[13]: \nA         B         C         D\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\nIn [14]: df.tail(3)\nOut[14]: \nA         B         C         D\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\n2013-01-06 -0.673690  0.113648 -1.478427  0.524988\n</code></pre> <p>We can also explore the data with an IDE such as PyCharm, or we can export the DataFrame to a <code>.csv</code> file  and open it with a spreadsheet editor.</p>"},{"location":"sections/python_libraries/pandas/#accessing-data-in-a-dataframe","title":"Accessing data in a DataFrame","text":"<p>There are 3 options to access the data of a pandas object:</p> <ul> <li><code>[]</code>, the \"standard getter\" which is highly overloaded</li> <li><code>.loc[]</code>, label based selector</li> <li><code>.iloc[],</code> integer location based selector</li> </ul> <p>Note</p> <p>The <code>[]</code> operator is highly overloaded and its use is discouraged. Use <code>.loc[]</code> and <code>.iloc[]</code> whenever possible.</p>"},{"location":"sections/python_libraries/pandas/#accessing-data-in-one-ore-more-columns","title":"Accessing data in one ore more columns","text":"<p>We can either use the standard getter <code>[]</code> or <code>.loc[]</code>.</p> <p>With the standard getter it works like this (the return type is another DataFrame):</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30], 4.5: [\"Alice\", \"Eve\", \"Bob\"]},\nindex=[\"a\", \"b\", \"b\"],\n)\n&gt;&gt;&gt; my_dataframe[[4.5]]\n4.5\na  Alice\nb    Eve\nb    Bob\n&gt;&gt;&gt; my_dataframe[[4.5, \"colA\"]]\n4.5  colA\na  Alice    10\nb    Eve    20\nb    Bob    30\n</code></pre> <p>To select columns with the <code>.loc[]</code> operator we use the syntax <code>my_dataframe.loc[:, col_selector]</code>.  The <code>:</code> indicates that we want to select all rows (more on that later), and <code>col_selector</code> should be a list of the columns that we want to select:</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30, 40], 4.5: [\"Alice\", \"Eve\", \"Bob\", \"Charlie\"]},\nindex=[\"a\", \"b\", \"b\", \"c\"],\n)\n&gt;&gt;&gt; my_dataframe.loc[:, [4.5]]  # returns a DataFrame\n4.5\na  Alice\nb    Eve\nb    Bob\nc    Charlie\n&gt;&gt;&gt; my_dataframe.loc[:, [4.5, \"colA\"]]  # returns a DataFrame\n4.5  colA\na  Alice     10\nb    Eve     20\nb    Bob     30\nc    Charlie 40\n</code></pre> <p>Note</p> <p>In both examples we could have used a column name, instead of a list of column names,  as a selector. In this case, the return type, instead of a DataFrame, would be a Pandas Series. In general, try to avoid working with Series whenever possible and only use methods that return DataFrames.</p>"},{"location":"sections/python_libraries/pandas/#slicing","title":"Slicing","text":"<p>Slices act on row index, and are a way to access data from row X to row Y following the same  logic as explained before: a slice <code>[1:3]</code> will return all members from 1 to 3, except for the last one (i.e., 3 will be excluded). The return is a DataFrame:</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30, 40], 4.5: [\"Alice\", \"Eve\", \"Bob\", \"Charlie\"]},\nindex=[\"a\", \"b\", \"b\", \"c\"],\n)\n&gt;&gt;&gt; my_dataframe[1:3]\ncolA  4.5\nb    20  Eve\nb    30  Bob\n&gt;&gt;&gt; my_dataframe[:\"b\"]\ncolA    4.5\na    10  Alice\nb    20    Eve\nb    30    Bob\n</code></pre>"},{"location":"sections/python_libraries/pandas/#selecting-rows-and-columns-at-the-same-time","title":"Selecting rows and columns at the same time","text":"<p>To select rows with the <code>.loc[]</code> operator we use the syntax <code>my_dataframe.loc[row_selector, column_selector]</code>.  As before, <code>column_selector</code> can be <code>:</code>, which indicates that we want to select all columns (but we could also  put in here any list of columns we want).</p> <p>Note</p> <p><code>my_dataframe.loc[row_selector, :]</code> can also be written as <code>my_dataframe.loc[row_selector]</code>, without the <code>:</code>. However, the first version is more explicit, and so its use is recommended.</p> <p>We can select rows based on row name, row subset (by using a list, as with columns), a slice or, interestingly, based on boolean conditions:</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30, 40], 4.5: [\"Alice\", \"Eve\", \"Bob\", \"Charlie\"]},\nindex=[\"a\", \"b\", \"b\", \"c\"],\n)\n&gt;&gt;&gt; my_dataframe.loc[[\"c\", \"a\"], :]\ncolA      4.5\nc    40  Charlie\na    10    Alice\n&gt;&gt;&gt; my_dataframe.loc[3:2, :]\ncolA      4.5\n3    20      Eve\n1    30      Bob\n2    40  Charlie\n&gt;&gt;&gt; my_dataframe.loc[my_dataframe[\"colA\"] &gt; 30, 4.5]\n4.5\nc  Charlie \n</code></pre> <p>Note</p> <p>In the last example we have used a simple \"greater than\" boolean condition to select data in the DataFrame, but we can make this boolean condition as sophisticated or complex as we want, for example <pre><code>df.loc[(df[\"a\"] &gt; 0) &amp; (df[\"b\"] == df[\"d\"]), [\"a\", \"c\", \"g\"]\n</code></pre></p> <p>To filter rows by the contents of a string column, we can use the <code>.str</code> accessor:</p> <pre><code>df.loc[df[\"a\"].str.contains(\"hello\"), :]\n</code></pre>"},{"location":"sections/python_libraries/pandas/#accessing-data-from-its-location-on-the-dataframe","title":"Accessing data from its location on the DataFrame","text":"<p>The <code>.iloc[]</code> operator works the same as <code>.loc[]</code>, but on integer location of rows and also columns.  The syntax is the same, <code>my_dataframe[row_selector, column_selector]</code> and you can use <code>:</code> to indicate all rows or columns.</p> <p>Note</p> <p><code>iloc</code> does not use the index labels to select rows and columns, but their integer location. Hence, <code>my_dataframe.iloc[0, :]</code> will always return the first row of the DataFrame, regardless of the index.</p>"},{"location":"sections/python_libraries/pandas/#column-selectors","title":"Column selectors","text":"<ul> <li>Selecting a single column (<code>my_dataframe.iloc[:, 1]</code>) always returns a Series.</li> <li>Selecting a list of columns (<code>my_dataframe.iloc[:, [1]]</code>) always returns a DataFrame.</li> </ul>"},{"location":"sections/python_libraries/pandas/#row-selectors","title":"Row selectors","text":"<ul> <li>Selecting a single integer position (<code>my_dataframe.iloc[1, :]</code>) always returns a Series.</li> <li>Selecting with a list of integer positions (<code>my_dataframe.iloc[[1, 5], :]</code>) always returns a DataFrame.</li> <li>Selecting with a slice of integer positions (<code>my_dataframe.iloc[1:4, :]</code>) always returns a DataFrame.  Recall that the upper limit is excluded.</li> <li>Selecting with a list of boolean indexes (<code>my_dataframe.iloc[1:4, :]</code>) always returns a DataFrame</li> </ul>"},{"location":"sections/python_libraries/pandas/#setting-new-values-on-a-dataframe","title":"Setting new values on a DataFrame","text":"<p>We can use the same methods that have been shown to access data to set new values to the DataFrame. We just need to put the dataframe cell selection on the left side of a Python assignment, for example:</p> <pre><code># this assigns the value 10 to all cells in the column \"D\"\ndf.loc[:, \"D\"] = 10\n# this assigns the value 0 to all cells with negative values\ndf.loc[df &lt; 0, :] = 0\n</code></pre>"},{"location":"sections/python_libraries/pandas/#working-with-dataframes","title":"Working with DataFrames","text":"<p>This section describes very common methods or tasks that you will be performing with pandas DataFrames. Before we start, however, one word of caution: DataFrames are objects, that derive from the  <code>pandas.DataFrame</code> class. As objects, they have a lot of available methods that have been implemented for the class, and we may think that when we call one of this methods, the original DataFrame might be modified (since, after all, methods can change the attributes of the class). However, in pandas this is not the case. </p> <p>Note</p> <p>By default, in pandas, dataframe operations return a copy of the dataframe and leave the original  dataframe data intact.</p> <p>Let's see this with an example. Assume we have the following dataframe <code>df</code>: <pre><code>print(df)\n# Output\ncol1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n</code></pre> If we sort it by <code>col1</code> and then print <code>df</code> again, the result will not change: <pre><code>df.sort_values(by=['col1'])\nprint(df)\n# Output\ncol1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n</code></pre> This is because these methods do not change the internal state (i.e., its attributes) of the <code>df</code> instance. Hence, if we want to use the output of this method, we will need to save the <code>return</code> output of this methods to another variable (or chain it):</p> <pre><code>new_df = df.sort_values(by=['col1'])\nprint(new_df)\n# Output\ncol1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\n</code></pre> <p>Hence, if we want to \"update\" the DataFrame after a change, we will need to assign the output of the method to the original variable, like:</p> <pre><code>new_df = df.sort_values(by=['col1'])\n</code></pre> <p>Note</p> <p>We can make this functions modify the original dataframe with the optional parameter <code>inplace=True</code> (<code>False</code> is the default). However, in general its use is discouraged.</p>"},{"location":"sections/python_libraries/pandas/#common-tasks","title":"Common tasks","text":""},{"location":"sections/python_libraries/pandas/#finding-the-size-of-a-dataframe","title":"Finding the size of a DataFrame","text":"<ul> <li>To display the number of rows, columns, etc.: <code>df.info()</code></li> <li>To get the number of rows and columns: <code>df.shape</code></li> <li>To get the number of rows: <code>len(df)</code></li> <li>To get the number of columns: <code>len(df.columns)</code></li> </ul> <p>We also have access to an attribute <code>df.empty</code>, of <code>bool</code> type, which returns <code>True</code> if the DataFrame is empty and <code>False</code> otherwise.</p>"},{"location":"sections/python_libraries/pandas/#removing-duplicates","title":"Removing duplicates","text":"<p>Pandas <code>drop_duplicates()</code> method helps in removing duplicates from Pandas Dataframes.</p> <pre><code>import pandas as pd \ndata = { \n\"A\": [\"TeamA\", \"TeamB\", \"TeamB\", \"TeamC\", \"TeamA\"], \n\"B\": [50, 40, 40, 30, 50], \n\"C\": [True, False, False, False, True] \n} \ndf = pd.DataFrame(data) \nprint(df.drop_duplicates())\n# Output\nA       B      C\n0    TeamA    50    True\n1    TeamB    40    False\n3    TeamC    30    False\n</code></pre>"},{"location":"sections/python_libraries/pandas/#filling-missing-data","title":"Filling missing data","text":"<p>We can use the <code>.isna()</code> method to detect (and fill, if we need to) cells without values:</p> <pre><code>df.loc[df[\"a\"].isna(), :] = 0\n</code></pre> <p>Note</p> <p>The <code>.isnull()</code> method is an alias for the <code>.isna()</code> method, so both are exactly the same.</p> <p>Note</p> <p>Pandas primarily uses the value <code>np.nan</code> to represent missing data. Missing data is by default  not included in computations.</p>"},{"location":"sections/python_libraries/pandas/#resetting-the-index","title":"Resetting the index","text":"<p>After dropping and filtering the rows of a DataFrame, the original index values for each row remain.  If we want to re-create the index, dropping the original values, we can do it with <pre><code>DataFrame.reset_index(drop=True)\n</code></pre></p>"},{"location":"sections/python_libraries/pandas/#renaming-columns","title":"Renaming columns","text":"<p>To rename specific columns of a DataFrame, we may use the <code>df.rename()</code> method: <pre><code>df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'})\n</code></pre> Only the columns in the dictionary passed as input will be renamed.</p>"},{"location":"sections/python_libraries/pandas/#sorting","title":"Sorting","text":"<p>We can sort a DataFrame by the values of one or multiple columns, like so:</p> <pre><code>df.sort_values(by=['col1', 'col2'], ascending=True)\ncol1  col2  col3 col4\n1    A     1     1    B\n0    A     2     0    a\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\n</code></pre>"},{"location":"sections/python_libraries/pandas/#creating-new-columns","title":"Creating new columns","text":"<p>There are several ways to create a new column, but the most common one follow this syntax: <pre><code>df[\"new_column_name\"] = ...\n</code></pre> and on the <code>...</code> we can put whatever we want. For example, if we have a list <code>my_list</code> with the same length as the DataFrame has rows, we could do: <pre><code>df[\"new_column_name\"] = my_list\n</code></pre> Alternatively, we could create a new column using the values from other columns, for example: <pre><code>df[\"new_column\"] = df[\"A\"] + df[\"B\"]\n</code></pre></p>"},{"location":"sections/python_libraries/pandas/#counting-unique-values","title":"Counting unique values","text":"<p>The unique function in pandas is used to find the unique values from a series:</p> <pre><code>import pandas as pd\n# Creating a dataframe\ndf = pd.DataFrame({'Sports': ['Football', 'Cricket', 'Baseball', 'Basketball',\n'Tennis', 'Table-tennis', 'Archery', 'Swimming', 'Boxing'], \n'Player': [\"Messi\", \"Afridi\", \"Chad\", \"Johnny\", \"Federer\",\n\"Yong\", \"Mark\", \"Phelps\", \"Khan\"],\n'Country': [\"Argentina\", \"Pakistan\", \"England\", \"England\", \"Switzerland\",\n\"China\", \"China\", \"USA\", \"Pakistan\" ],\n'Rank': [1, 9, 7, 12, 1, 2, 11, 1, 1] })\n# Finding unique countries\nprint(df[\"Country\"].unique())\n# Finding unique rankings\nprint(df[\"Rank\"].unique())\n# Output\n['Argentina' 'Pakistan' 'England' 'Switzerland' 'China' 'USA']\n[1, 9, 7, 12, 2, 11]\n</code></pre>"},{"location":"sections/python_libraries/pandas/#pivoting-a-dataframe-with-melt-untidy-to-tidy-data","title":"Pivoting a dataframe with melt: untidy to tidy data","text":"<p>The <code>pandas.melt()</code> function is used to transform or reshape data in a dataframe, transforming it from  wide format to long format (this is sometimes called pivoting).  The function takes a set of columns and converts it into a single column.</p> <p>Example 1</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': {0: 'a', 1: 'b', 2: 'c'},\n...                    'B': {0: 1, 1: 3, 2: 5},\n...                    'C': {0: 2, 1: 4, 2: 6}})\n&gt;&gt;&gt; df\nA  B  C\n0  a  1  2\n1  b  3  4\n2  c  5  6\n&gt;&gt;&gt; pd.melt(df, id_vars=['A'], value_vars=['B', 'C'])\nA variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n3  a        C      2\n4  b        C      4\n5  c        C      6\n</code></pre> <p>Example 2</p> <pre><code>import pandas as pd\ndf = pd.DataFrame(\n{\n\"first\": [\"John\", \"Mary\"],\n\"last\": [\"Doe\", \"Bo\"],\n\"job\": [\"Nurse\", \"Economist\"],\n\"height\": [5.5, 6.0],\n\"weight\": [130, 150],\n}\n)\nmelt_df = df.melt(\nid_vars=[\"first\", \"last\"], \nvar_name=\"quantity\", \nvalue_vars=[\"height\", \"weight\"]\n)\nprint(\"\\n Unmelted: \")\nprint(df)\nprint(\"\\n Melted: \")\nprint(melt_df)\n# Output\nUnmelted: \nfirst  last  job         height  weight\n0  John   Doe   Nurse       5.5     130\n1  Mary   Bo    Economist   6.0     150\nMelted: \nfirst     last    quantity   value\n0     John      Doe     height     5.5\n1     Mary      Bo      height     6.0\n2     John      Doe     weight     130.0\n3     Mary      Bo      weight     150.0\n</code></pre>"},{"location":"sections/python_libraries/pandas/#basic-statistics","title":"Basic statistics","text":"<p>There are many statistical operations already implemented in pandas. We can use them by selecting a subset of the DataFrame (e.g., a few columns) and then calling these methods. Some of the most  important are:</p> <ul> <li>The mean: <code>some_df.mean()</code></li> <li>The median: <code>some_df.median()</code></li> <li>The standard deviation: <code>some_df.std()</code></li> <li>The min and max: <code>.min()</code> and <code>.max()</code></li> <li>The number of records for each category in a column:     <pre><code>In [12]: titanic[\"Pclass\"].value_counts()\nOut[12]: \nPclass\n3    491\n1    216\n2    184\nName: count, dtype: int64\n</code></pre></li> </ul> <p>There is also a helpful <code>.describe()</code> method that gives you several of these at the same time.</p>"},{"location":"sections/python_libraries/pandas/#applying-custom-functions","title":"Applying custom functions","text":"<p>The pandas DataFrame <code>apply()</code> function is used to apply a function along an axis of a DataFrame  (it also works with Pandas Series). This function that we apply can be an external or a custom defined function. It works like this:</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'A': [1, 2], 'B': [10, 20]})\ndef square(x):\nreturn x * x\ndf1 = df.apply(square)\nprint(df)\nprint(df1)\n# Output\nA   B\n0  1  10\n1  2  20\nA    B\n0  1  100\n1  4  400\n</code></pre> <p>Note</p> <p>We don't need to apply the function to the whole dataframe. We can slice it and only apply the function to a subset of the columns.</p> <p>If you look at the above example, our <code>square()</code> function is very simple. We can easily convert it  into a lambda function: <pre><code>df1 = df.apply(lambda x: x * x)\n</code></pre> The output will remain the same as in the last example.</p>"},{"location":"sections/python_libraries/pandas/#group-by","title":"Group by","text":"<p>The <code>groupby()</code> method is used for grouping the data according to the categories and applying a  function to aggregate them categories. This is easier seen with an example. Suppose that  we have the following dataframe:</p> <pre><code>import pandas as pd\nimport numpy as np\ndf = pd.DataFrame(\n{\n\"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n\"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n\"C\": np.random.randn(8),\n\"D\": np.random.randn(8),\n}\n)\nprint(df)\n# Output\nA      B         C         D\n0  foo    one  0.845112  2.525473\n1  bar    one -0.485309  0.067261\n2  foo    two  1.106288  0.205404\n3  bar  three -0.958754  0.923104\n4  foo    two  2.033509 -0.436023\n5  bar    two -0.945948  0.869062\n6  foo    one -0.288766 -1.497993\n7  foo  three  0.344638 -0.786353\n</code></pre> <p>We can ask ourselves what happens if we combine the data from all the columns that share values in the columns <code>A</code> and <code>B</code> (e.g., all the columns that have <code>foo</code> in column <code>A</code> and <code>bar</code> in  column <code>B</code>). </p> <p>For this we need what's known as an aggregating function. This function gives an answer to the following question: assume that I found all the rows that share values in <code>A</code> and <code>B</code> and, somehow, I want to group together the values in all the remaining columns. How do I do that? Do I calculate the mean of those values? The sum? The minimum?</p> <p>With Python's <code>groupby()</code> function we may use any aggregating function we want: the important thing to understand is that this function will be applied to the set defined by all rows where <code>A</code> and <code>B</code> are shared.</p> <p>Going back to the previous dataframe, and using the <code>sum()</code> function as an example, we could use it as:</p> <pre><code>df.groupby([\"A\", \"B\"], as_index=False).sum()\n# Output\nA      B         C         D\n0  bar    one -0.485309  0.067261\n1  bar  three -0.958754  0.923104\n2  bar    two -0.945948  0.869062\n3  foo    one  0.556346  1.027480\n4  foo  three  0.344638 -0.786353\n5  foo    two  3.139796 -0.230619\n</code></pre> <p>The syntax is always the same: <code>df.groupby(list_of_columns_used_to_classify, as_index=False).some_func()</code>, where <code>some_func()</code> is the function that is used to aggregate the columns that are not in <code>list_of_columns_used_to_classify</code>.</p> <p>Note</p> <p>In the last example the <code>as_index=False</code> is important. If we don't use it, then the group by will return a dataframe with a \"strange\" new index, created by the combination of the values of <code>A</code> and <code>B</code>.</p>"},{"location":"sections/python_libraries/pandas/#joins-and-merges","title":"Joins and merges","text":"<p>Pandas provides a single function, <code>merge()</code>, as the equivalent of standard SQL database join operations,  but in this case between DataFrames.</p> <p>Before getting into the details of how to use <code>merge()</code>, you should first understand the various forms of joins. The idea of a merge (or join, as is known in SQL) is that we have two tables, and we stitch them together on the basis of two columns (one from the first table, another from the second table) having the same value. The resulting merged table will be the first table glued with the second table, with the shared column acting as glue. This can be done in different ways:</p> <ul> <li>inner merge: the resulting merged table will contain all the rows from the original tables that found a      match in the other table, but all rows (from either table) that find no match are discarded.</li> <li>outer merge: the opposite of the previous case: every row from either table will appear in the merged table,     and if for some of them there is no match, we will get null values on the columns coming from the other table.</li> <li>left merge: this is an intermediate case between the inner and the outer merge. It behaves like the inner    merge, but we also keep the rows from the first (\"left\") table that have no matches.    </li> <li>right merge: like the left merge, but the table on the second table is acting as if it was the left table   (usually we don't use the right merge for anything, since we can perform a left merge with the two tables in    the opposite order).</li> </ul> <p>These are some examples on how to use the <code>merge()</code> function:</p> <pre><code>import pandas as pd\n#create DataFrame\ndf1 = pd.DataFrame({'team': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],\n'points': [18, 22, 19, 14, 14, 11, 20, 28]})\ndf2 = pd.DataFrame({'team': ['A', 'B', 'C', 'D', 'G', 'H', 'Z'],\n'assists': [4, 9, 14, 13, 10, 8, 15]})\n#view DataFrames\nprint(df1)\nteam  points\n0    A      18\n1    B      22\n2    C      19\n3    D      14\n4    E      14\n5    F      11\n6    G      20\n7    H      28\nprint(df2)\nteam  assists\n0    A        4\n1    B        9\n2    C       14\n3    D       13\n4    G       10\n5    H        8\n6    Z       15\ndf1.merge(df2, on='team', how='outer')\n# Output\nteam  points  assists\n0    A    18.0      4.0\n1    B    22.0      9.0\n2    C    19.0     14.0\n3    D    14.0     13.0\n4    E    14.0      NaN\n5    F    11.0      NaN\n6    G    20.0     10.0\n7    H    28.0      8.0\n8    Z     NaN     15.0\ndf1.merge(df2, on='team', how='left')\n# Output\nteam  points  assists\n0    A      18      4.0\n1    B      22      9.0\n2    C      19     14.0\n3    D      14     13.0\n4    E      14      NaN\n5    F      11      NaN\n6    G      20     10.0\n7    H      28      8.0\ndf1.merge(df2, on='team', how='inner')\n# Output\nteam  points  assists\n0    A      18        4\n1    B      22        9\n2    C      19       14\n3    D      14       13\n4    G      20       10\n5    H      28        8\n</code></pre>"},{"location":"sections/python_libraries/pandas/#concatenating-dataframes","title":"Concatenating DataFrames","text":"<p>If we have 2 or more DataFrames which share exactly the same columns, we can concatenate them like this:</p> <pre><code>df1 = pd.DataFrame(\n{\n\"A\": [\"A0\", \"A1\", \"A2\", \"A3\"],\n\"B\": [\"B0\", \"B1\", \"B2\", \"B3\"],\n\"C\": [\"C0\", \"C1\", \"C2\", \"C3\"],\n\"D\": [\"D0\", \"D1\", \"D2\", \"D3\"],\n},\nindex=[0, 1, 2, 3],\n)\ndf2 = pd.DataFrame(\n{\n\"A\": [\"A4\", \"A5\", \"A6\", \"A7\"],\n\"B\": [\"B4\", \"B5\", \"B6\", \"B7\"],\n\"C\": [\"C4\", \"C5\", \"C6\", \"C7\"],\n\"D\": [\"D4\", \"D5\", \"D6\", \"D7\"],\n},\nindex=[4, 5, 6, 7],\n)\ndf3 = pd.DataFrame(\n{\n\"A\": [\"A8\", \"A9\", \"A10\", \"A11\"],\n\"B\": [\"B8\", \"B9\", \"B10\", \"B11\"],\n\"C\": [\"C8\", \"C9\", \"C10\", \"C11\"],\n\"D\": [\"D8\", \"D9\", \"D10\", \"D11\"],\n},\nindex=[8, 9, 10, 11],\n)\nframes = [df1, df2, df3]\nresult = pd.concat(frames)\nprint(result)\n# Output\nA    B    C    D\n0    A0   B0   C0   D0\n1    A1   B1   C1   D1\n2    A2   B2   C2   D2\n3    A3   B3   C3   D3\n4    A4   B4   C4   D4\n5    A5   B5   C5   D5\n6    A6   B6   C6   D6\n7    A7   B7   C7   D7\n8    A8   B8   C8   D8\n9    A9   B9   C9   D9\n10  A10  B10  C10  D10\n11  A11  B11  C11  D11\n</code></pre>"},{"location":"sections/python_libraries/pandas/#variable-types-and-memory-usage","title":"Variable types and memory usage","text":"<p>A pandas DataFrame can have columns of different types. To find out what these are, we may use <code>df.dtypes</code>: <pre><code>print(df.dtypes)\n# Output\nfloat              float64\nint                  int64\ndatetime    datetime64[ns]\nstring              object\ndtype: object\n</code></pre></p> <p>Note</p> <p>For very large datasets, make sure that you are not using more bits than you need in the columns. You can transform the variable types, for example <code>int64</code> to <code>int16</code>, anytime.</p> <p>To actually learn how much RAM memory (in Bytes) we are using for a particular DataFrame, we may use the <code>df.memory_usage(deep=True)</code> function:</p> <pre><code>&gt;&gt;&gt; df.memory_usage(deep=True)\n(lists each column's full memory usage)\n&gt;&gt;&gt; df.memory_usage(deep=True).sum()\n462432\n</code></pre>"},{"location":"sections/python_libraries/pyspark/","title":"PySpark","text":""},{"location":"sections/python_libraries/pyspark/#introduction","title":"Introduction","text":"<p>Spark is a platform for cluster computing. Spark lets you spread data and computations over clusters  with multiple nodes (think of each node as a separate computer). Splitting up your data makes it easier  to work with very large datasets because each node only works with a small amount of data. Hence, Spark is a common tool for what is informally known as big data (for example, for cleaning it up or transforming it into a more usable format).</p> <p>As each node works on its own subset of the total data, it also carries out a part of the total  calculations required, so that both data processing and computation are performed in parallel over  the nodes in the cluster. </p> <p>PySpark is the Python API for Spark. Having a Python library that allows us to interact with Spark using Python means that we can use Python to write code that will run on Spark clusters under the hood, without having to learn Scala or Java.</p>"},{"location":"sections/python_libraries/pyspark/#setting-up-spark","title":"Setting up Spark","text":"<p>Setting up Spark is considerably more complicated than using Pandas, and it requires additional software.  We should only use Spark when our data is too big to work with on a single machine, or when we need to parallelize our computations for other reasons (e.g. to speed up the computations). If that is not the case, we should use Pandas instead (or a Pandas alternative, like Polars).</p>"},{"location":"sections/python_libraries/pyspark/#windows-and-mac","title":"Windows and Mac","text":"<p>Follow the course slides to set up PySpark on your computer</p>"},{"location":"sections/python_libraries/pyspark/#linux","title":"Linux","text":"<p>The easiest way to start using PySpark is with a docker image. We have two options</p>"},{"location":"sections/python_libraries/pyspark/#option-1-running-a-jupyter-notebook","title":"Option 1: running a Jupyter notebook","text":"<p>Get the docker image from here by running: <pre><code>docker pull jupyter/pyspark-notebook\n</code></pre> Then run the image with <pre><code>docker run -it --rm -p 8888:8888 jupyter/pyspark-notebook\n</code></pre> After this two steps we can already write/run Python code with PySpark (from the notebook).</p>"},{"location":"sections/python_libraries/pyspark/#option-2-using-google-colab","title":"Option 2: using Google Colab","text":"<p>Open a new google colab notebook and run <pre><code>!pip install pyspark py4j\n</code></pre> on the first cell.</p> <p>Note</p> <p>This is the most straightforward way to work with PySpark, but executions are rather slow.</p>"},{"location":"sections/python_libraries/pyspark/#option-3-running-pyspark-from-an-ide-eg-pycharm","title":"Option 3: running PySpark from an IDE (e.g. PyCharm)","text":"<ol> <li>Install docker following the instructions here.</li> <li>Pull the docker image following the instructions here.</li> <li>Configure Pycharm to work with a remote docker interpreter</li> </ol>"},{"location":"sections/python_libraries/pyspark/#overview","title":"Overview","text":"<p>At a high level, every Spark application consists of a driver program that runs the user\u2019s main  function and executes various parallel operations on a cluster. The main abstraction Spark provides  is a resilient distributed dataset (RDD), which is a collection of elements partitioned across the  nodes of the cluster that can be operated on in parallel. RDDs are created by starting with a file  (Hadoop file system or any other Hadoop-supported file system), or an existing driver program (a Scala collection), and transforming it. Users may persist an RDD in memory to be reused across parallel operations.</p> <p>Note</p> <p>RDDs automatically recover from node failures.</p>"},{"location":"sections/python_libraries/pyspark/#pyspark-dataframes","title":"PySpark DataFrames","text":"<p>PySpark's main object is the PySpark DataFrame (which is not the same as a Pandas DataFrame).  PySpark DataFrames are implemented on top of RDDs and are lazily evaluated.  This means that whenever we create a PySpark DataFrame, nothing happens until we call an action on it: Spark does not immediately compute the transformation but plans how to compute later. </p> <p>RDD actions are operations that actually return a value to the user program or write a value to storage, and actually trigger the computation of a result. They can be:</p> <ul> <li><code>collect()</code>: return all the elements of the dataset as an array at the driver program.  This is usually useful after a filter or other operation that returns a sufficiently small subset of the data.</li> <li><code>count()</code>: return the number of elements in the dataset.</li> <li><code>first()</code>: return the first element of the dataset.</li> <li><code>take(n)</code>: return an array with the first n elements of the dataset.</li> <li><code>reduce(func)</code>: aggregate the elements of the dataset using a function <code>func</code>.</li> </ul>"},{"location":"sections/python_libraries/pyspark/#pandas-vs-spark","title":"Pandas vs Spark","text":"<p>PySpark DataFrames are conceptually equivalent to a Pandas DataFrame. The main difference is that PySpark DataFrames are immutable, meaning that they cannot be changed after they are created. </p> <p>Note</p> <p>Every time we perform an operation on a PySpark Dataframe, we are actually creating a new dataframe.</p> <p>This allows Spark to do more optimization under the hood.</p>"},{"location":"sections/python_libraries/pyspark/#working-with-pyspark-dataframes","title":"Working with PySpark DataFrames","text":""},{"location":"sections/python_libraries/pyspark/#sparksession","title":"SparkSession","text":"<p>PySpark applications start with initializing SparkSession, which is the entry point of PySpark:</p> <pre><code>from pyspark.sql import SparkSession\nspark = SparkSession.builder.getOrCreate()\n</code></pre>"},{"location":"sections/python_libraries/pyspark/#dataframe-creation","title":"DataFrame Creation","text":"<p>A PySpark DataFrame can be created via <code>pyspark.sql.SparkSession.createDataFrame</code> by several different ways. This is similar to pandas, where we can create a DataFrame with data from different data structures.</p> <p>For example, we can create a DataFrame by passing a list of lists, tuples, dictionaries or another pandas DataFrame, and then an RDD consisting of such a list.  <code>pyspark.sql.SparkSession.createDataFrame</code> takes the schema argument to specify the schema of the DataFrame.</p> <p>Note</p> <p>A PySpark schema is a list that defines the name, type, and nullable/non-nullable information for each column in a DataFrame.</p> <p>When the schema is omitted, PySpark infers the corresponding schema by taking a sample from the data.</p> <p>We can create a PySpark DataFrame from a list of rows:</p> <pre><code>from datetime import datetime, date\nimport pandas as pd\nfrom pyspark.sql import Row\ndf = spark.createDataFrame([\nRow(a=1, b=2., c='string1', d=date(2000, 1, 1), e=datetime(2000, 1, 1, 12, 0)),\nRow(a=2, b=3., c='string2', d=date(2000, 2, 1), e=datetime(2000, 1, 2, 12, 0)),\nRow(a=4, b=5., c='string3', d=date(2000, 3, 1), e=datetime(2000, 1, 3, 12, 0))\n])\nprint(df)\n# Output\nDataFrame[a: bigint, b: double, c: string, d: date, e: timestamp]\n</code></pre> <p>But we have other options to create a PySpark DataFrame, and sometimes they are more convenient:</p> <ul> <li> <p>Create a PySpark DataFrame with an explicit schema</p> <pre><code>df = spark.createDataFrame([\n(1, 2., 'string1', date(2000, 1, 1), datetime(2000, 1, 1, 12, 0)),\n(2, 3., 'string2', date(2000, 2, 1), datetime(2000, 1, 2, 12, 0)),\n(3, 4., 'string3', date(2000, 3, 1), datetime(2000, 1, 3, 12, 0))\n], schema='a long, b double, c string, d date, e timestamp')\nprint(df)\n# Output\nDataFrame[a: bigint, b: double, c: string, d: date, e: timestamp]\n</code></pre> </li> <li> <p>Create a PySpark DataFrame from a pandas DataFrame</p> <pre><code>pandas_df = pd.DataFrame({\n'a': [1, 2, 3],\n'b': [2., 3., 4.],\n'c': ['string1', 'string2', 'string3'],\n'd': [date(2000, 1, 1), date(2000, 2, 1), date(2000, 3, 1)],\n'e': [datetime(2000, 1, 1, 12, 0), datetime(2000, 1, 2, 12, 0), datetime(2000, 1, 3, 12, 0)]\n})\ndf = spark.createDataFrame(pandas_df)\nprint(df)\n# Output\nDataFrame[a: bigint, b: double, c: string, d: date, e: timestamp]\n</code></pre> </li> </ul> <p>All the DataFrames created above have the same content and schema.</p> <pre><code># All DataFrames above result same.\ndf.show()\ndf.printSchema()\n# Output\n+---+---+-------+----------+-------------------+\n|  a|  b|      c|         d|                  e|\n+---+---+-------+----------+-------------------+\n|  1|2.0|string1|2000-01-01|2000-01-01 12:00:00|\n|  2|3.0|string2|2000-02-01|2000-01-02 12:00:00|\n|  3|4.0|string3|2000-03-01|2000-01-03 12:00:00|\n+---+---+-------+----------+-------------------+\nroot\n|-- a: long (nullable = true)\n|-- b: double (nullable = true)\n|-- c: string (nullable = true)\n|-- d: date (nullable = true)\n|-- e: timestamp (nullable = true)\n</code></pre> <p>Note</p> <p>To print a dataframe in table format, you can use <code>df.show()</code>.</p>"},{"location":"sections/python_libraries/pyspark/#getting-data-inout","title":"Getting data In/Out","text":"<p>Other common options to put data in/out of a DataFrame are to get data from a file.</p> <ul> <li> <p>CSV files: <pre><code>df.write.csv('fruits.csv', header=True)\nspark.read.csv('fruits.csv', header=True).show()\n# Output\n+-----+------+---+---+\n|color| fruit| v1| v2|\n+-----+------+---+---+\n|  red|banana|  1| 10|\n| blue|banana|  2| 20|\n|  red|carrot|  3| 30|\n| blue| grape|  4| 40|\n|  red|carrot|  5| 50|\n|black|carrot|  6| 60|\n|  red|banana|  7| 70|\n|  red| grape|  8| 80|\n+-----+------+---+---+\n</code></pre></p> </li> <li> <p>Parquet is an efficient and compact file format to read and write faster.</p> <pre><code>df.write.parquet('fruits.parquet')\nspark.read.parquet('fruits.parquet').show()\n# Output\n+-----+------+---+---+\n|color| fruit| v1| v2|\n+-----+------+---+---+\n|  red|banana|  1| 10|\n| blue|banana|  2| 20|\n|  red|carrot|  3| 30|\n| blue| grape|  4| 40|\n|  red|carrot|  5| 50|\n|black|carrot|  6| 60|\n|  red|banana|  7| 70|\n|  red| grape|  8| 80|\n+-----+------+---+---+\n</code></pre> </li> </ul>"},{"location":"sections/python_libraries/pyspark/#viewing-data","title":"Viewing Data","text":"<p>The top rows of a DataFrame can be displayed using <code>DataFrame.show(n)</code> (where <code>n</code> is the number of printed rows).</p> <pre><code>df.show(1)\n# Output\n+---+---+-------+----------+-------------------+\n|  a|  b|      c|         d|                  e|\n+---+---+-------+----------+-------------------+\n|  1|2.0|string1|2000-01-01|2000-01-01 12:00:00|\n+---+---+-------+----------+-------------------+\n</code></pre> <p>only showing the first row. You can see the DataFrame\u2019s schema and column names as follows:</p> <pre><code>df.columns\n# Output\n['a', 'b', 'c', 'd', 'e']\ndf.printSchema()\n# Output\nroot\n|-- a: long (nullable = true)\n|-- b: double (nullable = true)\n|-- c: string (nullable = true)\n|-- d: date (nullable = true)\n|-- e: timestamp (nullable = true)\n</code></pre> <p>Show the summary of the DataFrame</p> <pre><code>df.select(\"a\", \"b\", \"c\").describe().show()\n# Output\n+-------+---+---+-------+\n|summary|  a|  b|      c|\n+-------+---+---+-------+\n|  count|  3|  3|      3|\n|   mean|2.0|3.0|   null|\n| stddev|1.0|1.0|   null|\n|    min|  1|2.0|string1|\n|    max|  3|4.0|string3|\n+-------+---+---+-------+\n</code></pre> <p><code>DataFrame.collect()</code> collects the distributed data to the driver side as the local data in Python.  Note that this can throw an out-of-memory error when the dataset is too large to fit in the driver side  because it collects all the data from executors to the driver side.</p> <pre><code>df.collect()\n# Output\n[Row(a=1, b=2.0, c='string1', d=datetime.date(2000, 1, 1), e=datetime.datetime(2000, 1, 1, 12, 0)),\nRow(a=2, b=3.0, c='string2', d=datetime.date(2000, 2, 1), e=datetime.datetime(2000, 1, 2, 12, 0)),\nRow(a=3, b=4.0, c='string3', d=datetime.date(2000, 3, 1), e=datetime.datetime(2000, 1, 3, 12, 0))]\n</code></pre> <p>In order to avoid throwing an out-of-memory exception, use <code>DataFrame.take(n)</code> or <code>DataFrame.tail()</code>.</p> <pre><code>df.take(1)\n# Output\n[Row(a=1, b=2.0, c='string1', d=datetime.date(2000, 1, 1), e=datetime.datetime(2000, 1, 1, 12, 0))]\n</code></pre> <p>PySpark DataFrame also provides the conversion back to a pandas DataFrame. </p> <pre><code>df.toPandas()\nprint(df)\n# Output\na   b       c           d           e\n0   1   2.0     string1     2000-01-01  2000-01-01 12:00:00\n1   2   3.0     string2     2000-02-01  2000-01-02 12:00:00\n2   3   4.0     string3     2000-03-01  2000-01-03 12:00:00\n</code></pre> <p>Note</p> <p><code>toPandas</code> also collects all data into the driver side, and that can easily cause an  out-of-memory-error if the data is too large to fit into the driver side.</p>"},{"location":"sections/python_libraries/pyspark/#selecting-and-accessing-data","title":"Selecting and accessing data","text":"<p>PySpark DataFrame is lazily evaluated and simply selecting a column does not trigger a computation. Instead, it returns a Column instance.</p> <pre><code>df.a\nColumn&lt;b'a'&gt;\n</code></pre> <p>In fact, most column-wise operations return Columns.</p> <pre><code>from pyspark.sql import Column\nfrom pyspark.sql.functions import upper\ntype(df.c) == type(upper(df.c)) == type(df.c.isNull())\nTrue\n</code></pre> <p>These column objects can be used to get new DataFrames that are subsets of the original one.</p> <p><pre><code>df.select(df.c).show()\n# Output\n+-------+\n|      c|\n+-------+\n|string1|\n|string2|\n|string3|\n+-------+\n</code></pre> To select several columns, we would write either <code>df.select(\"col_1\",\"col_2\").show()</code> or <code>df.select(df.col_1,df.col_2).show()</code> (they are equivalent).</p> <p>Note</p> <p>To return the distinct values in a column, we can use <code>df.select(df.col_1).distinct().show()</code>.</p> <ul> <li> <p>To select a subset of rows, we use the filter method <code>DataFrame.filter()</code>.</p> <pre><code>df.filter(df.a == 1).show()\n# Output\n+---+---+-------+----------+-------------------+\n|  a|  b|      c|         d|                  e|\n+---+---+-------+----------+-------------------+\n|  1|2.0|string1|2000-01-01|2000-01-01 12:00:00|\n+---+---+-------+----------+-------------------+\n# Filter multiple condition\ndf.filter((df.state  == \"OH\") &amp; (df.gender  == \"M\")).show()  \n...\n</code></pre> </li> </ul>"},{"location":"sections/python_libraries/pyspark/#creating-new-columns","title":"Creating new columns","text":"<p><code>withColumn</code> is a DataFrame function that can be used for several different (but related things): * Add a new column to DataFrame * Change the value of an existing column * Convert the datatype of a column * Change the column name * Apply a function to a column</p> <p>For example, to create a new column that transforms the values of an existing column:</p> <pre><code>df.withColumn('upper_c', upper(df.c)).show()\n# Output\n+---+---+-------+----------+-------------------+-------+\n|  a|  b|      c|         d|                  e|upper_c|\n+---+---+-------+----------+-------------------+-------+\n|  1|2.0|string1|2000-01-01|2000-01-01 12:00:00|STRING1|\n|  2|3.0|string2|2000-02-01|2000-01-02 12:00:00|STRING2|\n|  3|4.0|string3|2000-03-01|2000-01-03 12:00:00|STRING3|\n+---+---+-------+----------+-------------------+-------+\n</code></pre>"},{"location":"sections/python_libraries/pyspark/#applying-a-function","title":"Applying a Function","text":"<p>PySpark supports various user defined functions (UDFs) and APIs to allow users to execute Python native functions.  For instance, the example below allows users to directly use the APIs in a pandas Series within a Python native function.</p> <pre><code>import pandas as pd\nfrom pyspark.sql.functions import pandas_udf\n@pandas_udf('long')\ndef pandas_plus_one(series: pd.Series) -&gt; pd.Series:\n# Simply plus one by using pandas Series.\nreturn series + 1\ndf.select(pandas_plus_one(df.a)).show()\n# Output\n+------------------+\n|pandas_plus_one(a)|\n+------------------+\n|                 2|\n|                 3|\n|                 4|\n+------------------+\n</code></pre>"},{"location":"sections/python_libraries/pyspark/#fill-nanan-values","title":"Fill NA/NaN values","text":"<p>We can use <code>DataFrame.na.fill()</code> to replace NA/NaN values with a specified value.</p> <pre><code>df.na.fill(50).collect()\n</code></pre>"},{"location":"sections/python_libraries/pyspark/#grouping-data","title":"Grouping Data","text":"<p>The DataFrame also provides a way of handling grouped data. It groups the data by a certain  condition, applies a function to each group and then combines them back to the DataFrame.</p> <pre><code>simpleData = [(\"James\",\"Sales\",\"NY\",90000,34,10000),\n(\"Michael\",\"Sales\",\"NY\",86000,56,20000),\n(\"Robert\",\"Sales\",\"CA\",81000,30,23000),\n(\"Maria\",\"Finance\",\"CA\",90000,24,23000),\n(\"Raman\",\"Finance\",\"CA\",99000,40,24000),\n(\"Scott\",\"Finance\",\"NY\",83000,36,19000),\n(\"Jen\",\"Finance\",\"NY\",79000,53,15000),\n(\"Jeff\",\"Marketing\",\"CA\",80000,25,18000),\n(\"Kumar\",\"Marketing\",\"NY\",91000,50,21000)\n]\nschema = [\"employee_name\",\"department\",\"state\",\"salary\",\"age\",\"bonus\"]\ndf = spark.createDataFrame(data=simpleData, schema = schema)\ndf.show(truncate=False)\n# Output\n+-------------+----------+-----+------+---+-----+\n|employee_name|department|state|salary|age|bonus|\n+-------------+----------+-----+------+---+-----+\n|        James|     Sales|   NY| 90000| 34|10000|\n|      Michael|     Sales|   NY| 86000| 56|20000|\n|       Robert|     Sales|   CA| 81000| 30|23000|\n|        Maria|   Finance|   CA| 90000| 24|23000|\n|        Raman|   Finance|   CA| 99000| 40|24000|\n|        Scott|   Finance|   NY| 83000| 36|19000|\n|          Jen|   Finance|   NY| 79000| 53|15000|\n|         Jeff| Marketing|   CA| 80000| 25|18000|\n|        Kumar| Marketing|   NY| 91000| 50|21000|\n+-------------+----------+-----+------+---+-----+\n</code></pre> <p>Grouping and then applying the <code>sum()</code> function to the resulting groups.</p> <pre><code>df.groupBy(\"department\",\"state\").sum(\"salary\",\"bonus\").show()\n# Output\n+----------+-----+-----------+----------+\n|department|state|sum(salary)|sum(bonus)|\n+----------+-----+-----------+----------+\n|Finance   |NY   |162000     |34000     |\n|Marketing |NY   |91000      |21000     |\n|Sales     |CA   |81000      |23000     |\n|Marketing |CA   |80000      |18000     |\n|Finance   |CA   |189000     |47000     |\n|Sales     |NY   |176000     |30000     |\n+----------+-----+-----------+----------+\n</code></pre>"},{"location":"sections/python_libraries/pyspark/#joins","title":"Joins","text":"<p>The PySpark Join is used to combine two DataFrames from the values of two of their columns.  It supports all basic join type operations available in traditional SQL:</p> <pre><code>empDF.show()\n# Output\n+------+--------+---------------+-----------+-----------+------+------+\n|emp_id|name    |superior_emp_id|year_joined|emp_dept_id|gender|salary|\n+------+--------+---------------+-----------+-----------+------+------+\n|1     |Smith   |-1             |2018       |10         |M     |3000  |\n|2     |Rose    |1              |2010       |20         |M     |4000  |\n|3     |Williams|1              |2010       |10         |M     |1000  |\n|4     |Jones   |2              |2005       |10         |F     |2000  |\n|5     |Brown   |2              |2010       |40         |      |-1    |\n|6     |Brown   |2              |2010       |50         |      |-1    |\n+------+--------+---------------+-----------+-----------+------+------+\ndeptDF.show()\n# Output\n+---------+-------+\n|dept_name|dept_id|\n+---------+-------+\n|Finance  |10     |\n|Marketing|20     |\n|Sales    |30     |\n|IT       |40     |\n+---------+-------+\n# Inner join\nempDF.join(deptDF,empDF.emp_dept_id == deptDF.dept_id,\"inner\").show()\n# Output\n+------+--------+---------------+-----------+-----------+------+------+---------+-------+\n|emp_id|name    |superior_emp_id|year_joined|emp_dept_id|gender|salary|dept_name|dept_id|\n+------+--------+---------------+-----------+-----------+------+------+---------+-------+\n|1     |Smith   |-1             |2018       |10         |M     |3000  |Finance  |10     |\n|2     |Rose    |1              |2010       |20         |M     |4000  |Marketing|20     |\n|3     |Williams|1              |2010       |10         |M     |1000  |Finance  |10     |\n|4     |Jones   |2              |2005       |10         |F     |2000  |Finance  |10     |\n|5     |Brown   |2              |2010       |40         |      |-1    |IT       |40     |\n+------+--------+---------------+-----------+-----------+------+------+---------+-------+\n</code></pre> <p>In this last example we used <code>inner</code>, but we can also use:</p> <ul> <li><code>inner</code></li> <li><code>left</code></li> <li><code>outer</code></li> </ul>"},{"location":"sections/python_libraries/pyspark/#working-with-sql","title":"Working with SQL","text":"<p>An incredibly powerful option of PySpark DataFrames is that they can be queried with SQL. For example, you can register a DataFrame as a table and run a SQL query on it easily as below:</p> <pre><code>df.createOrReplaceTempView(\"tableA\")\nspark.sql(\"SELECT count(*) from tableA\").show()\n# Output\n+--------+\n|count(1)|\n+--------+\n|       8|\n+--------+\n</code></pre> <p>In addition, functions can be registered and invoked in SQL out of the box:</p> <pre><code>@pandas_udf(\"integer\")\ndef add_one(s: pd.Series) -&gt; pd.Series:\nreturn s + 1\nspark.udf.register(\"add_one\", add_one)\nspark.sql(\"SELECT add_one(v1) FROM tableA\").show()\n# Output\n+-----------+\n|add_one(v1)|\n+-----------+\n|          2|\n|          3|\n|          4|\n|          5|\n|          6|\n|          7|\n|          8|\n|          9|\n+-----------+\n</code></pre> <p>These SQL expressions can directly be mixed and used as PySpark columns.</p> <pre><code>from pyspark.sql.functions import expr\ndf.selectExpr('add_one(v1)').show()\ndf.select(expr('count(*)') &gt; 0).show()\n# Output\n+-----------+\n|add_one(v1)|\n+-----------+\n|          2|\n|          3|\n|          4|\n|          5|\n|          6|\n|          7|\n|          8|\n|          9|\n+-----------+\n+--------------+\n|(count(1) &gt; 0)|\n+--------------+\n|          true|\n+--------------+\n</code></pre>"},{"location":"sections/python_libraries/typer/","title":"Typer","text":"<p>Typer is a library for building command-line interface (CLI) applications in Python. It is built on top of  Click (another popular CLI library) and makes it very easy  to build complex CLI applications by providing a clean interface for defining commands and arguments.</p> <p> </p> A screenshot of Typer from a terminal."},{"location":"sections/python_libraries/typer/#installation","title":"Installation","text":"<p>Typer can be installed with <code>pip</code>:</p> <pre><code>pip install typer\n</code></pre> <p>Or, in a poetry project:</p> <pre><code>poetry add typer\n</code></pre>"},{"location":"sections/python_libraries/typer/#creating-a-cli-with-typer","title":"Creating a CLI with Typer","text":"<p>It is recommended to use Typer in a Python project with a clean directory structure. This makes it easier to organize the code and to add new commands and arguments. In what follows, we will assume that the project directory structure looks like this:</p> <pre><code>.\n\u251c\u2500\u2500 my_project # The directory containing the project code\n\u2502   \u251c\u2500\u2500 __main__.py # The file that will be used to run the CLI\n\u2502   \u251c\u2500\u2500 cli # The directory containing the CLI code\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py # A file that contains links to the commands\n\u2502   \u2502   \u251c\u2500\u2500 command_1.py\n\u2502   \u2502   \u251c\u2500\u2500 ... # Other commands\n\u2502   \u2502   \u2514\u2500\u2500 command_n.py\n\u2502   \u2514\u2500\u2500 ... # Other project code, unrelated to the CLI\n</code></pre> <p>where <code>cli</code> is a folder inside the <code>my_project</code> directory. In this last example, our CLI has several commands (<code>command1</code>, ...) and a <code>__main__.py</code> file, inside the <code>my_project</code> directory, that will be used to run the CLI.</p>"},{"location":"sections/python_libraries/typer/#writing-a-simple-cli","title":"Writing a simple CLI","text":"<p>We will make a simple CLI that has two commands. The first is the command <code>say</code>, which has 3 subcommands: <code>hello</code>, <code>goodbye</code>, and <code>greet</code>: the <code>hello</code> command will print <code>\"Hello, world!\"</code>, the <code>goodbye</code> command  will print <code>\"Goodbye, it is &lt;time&gt; and we should go to sleep\"</code>, where <code>&lt;time&gt;</code> is the current time in the  format <code>HH:MM</code>, and the <code>greet</code> command will take a name as an argument and print \"<code>Hello, &lt;name&gt;!\"</code>. The second command is the <code>operate</code> command, which only has the subcommand <code>add</code>: it will take two numbers  as arguments and print their sum.</p> <p>Note</p> <p>The commands are completely unrelated to each other. In a more realistic machine learning project, the commands would be related to each other and would be used to train, evaluate, etc. a machine learning model.</p> <p>Let's start first by creating the code for the commands. After that, we will create the <code>__init__.py</code> and the <code>__main__.py</code> files.</p>"},{"location":"sections/python_libraries/typer/#the-say-command","title":"The <code>say</code> command","text":"<p>We will first create the <code>say</code> command, which has 3 subcommands, and then we will review them one by one. We should create a file called <code>say.py</code> inside the <code>cli</code> directory, containing the following code:</p> <pre><code># Path: cli/say.py\nfrom typer import Typer, Option\nimport datetime\napp = Typer()\n@app.command(\"hello\", help=\"Prints 'Hello, world!'\")\ndef hello():\n\"\"\"Prints 'Hello, world!'.\"\"\"\nprint(\"Hello, world!\")\nreturn\n@app.command(\"goodbye\", help=\"Prints 'Goodbye, it is &lt;time&gt; and we should go to sleep'\")\ndef goodbye():\n\"\"\"Prints 'Goodbye, it is &lt;time&gt; and we should go to sleep'.\"\"\"\nnow = datetime.datetime.now()\nprint(f\"Goodbye, it is {now.hour}:{now.minute} and we should go to sleep\")\nreturn\n@app.command(\"greet\", help=\"Prints 'Hello, &lt;name&gt;!'\")\ndef greet(name: str = Option(..., \"--name\", \"-n\", help=\"The name to greet\")):\n\"\"\"Prints 'Hello, &lt;name&gt;!'.\"\"\"\nprint(f\"Hello, {name}!\")\nreturn\n</code></pre>"},{"location":"sections/python_libraries/typer/#the-hello-command","title":"The <code>hello</code> command","text":"<p>The <code>hello</code> command is the simplest of the three commands. It does not take any arguments and simply prints \"Hello, world!\" when it is called. </p> <p>The <code>hello</code> command is defined as a function with the <code>@app.command()</code> decorator. The <code>@app.command()</code> decorator tells Typer that this function is a command and should be added to the CLI. The <code>hello</code> command does not take any arguments, so it does not need to take any parameters. </p> <p>As we see in this example, creating a command is as simple as defining a function and decorating it with the <code>@app.command()</code> decorator.</p> <p>Note</p> <p>The <code>app</code> is a Typer app, the main object provided by Typer to create CLIs. It is created  with <code>app = typer.Typer()</code> </p> <p>Note</p> <p>Commands are defined in regular Python files. This means that any Python code, any imports, etc. can be used inside a command.</p>"},{"location":"sections/python_libraries/typer/#the-goodbye-command","title":"The <code>goodbye</code> command","text":"<p>The <code>goodbye</code> command is a bit more complex than the <code>hello</code> command. It prints \"Goodbye, it is  and we should go to sleep\", where <code>&lt;time&gt;</code> is the current time in the format <code>HH:MM</code>. It imports the <code>datetime</code> library to get the current time and then prints the message. <p>The <code>goodbye</code> command is defined similarly to the <code>hello</code> command, with a function that is slightly more complex.</p>"},{"location":"sections/python_libraries/typer/#the-greet-command","title":"The <code>greet</code> command","text":"<p>The <code>greet</code> command is a bit more complex because it takes a name as an argument (the previous commands had no  arguments/options).</p> <p>The Option <code>--name</code> (or <code>-n</code>), imported from the Typer library, is used to define the argument (in this case <code>name</code>) that the <code>greet</code> command takes. The <code>...</code> in <code>Option(..., help=\"The name to greet\")</code> is used to tell Typer that the <code>name</code> argument is required. </p> <p>If we wanted to make the <code>name</code> argument optional, we could have used <code>None</code> instead of <code>...</code></p> <p>Note</p> <p>The <code>help</code> argument is used to provide a description of the argument. This description will be shown when the <code>--help</code> option is used in a terminal.</p>"},{"location":"sections/python_libraries/typer/#the-operate-command","title":"The <code>operate</code> command","text":"<p>Since it is unrelated to the rest of the <code>say</code> commands, we have included <code>add</code> in a differentiated <code>operate</code> command file (but, of course, how to structure the code is up to you). The  <code>operate</code> command only has one subcommand: <code>add</code>, the arithmetic addition. It takes two numbers as arguments  and prints their sum.</p> <pre><code># Path: cli/operate.py\nfrom typer import Typer, Option\napp = Typer()\n@app.command(\"add\", help=\"Prints the sum of two numbers\")\ndef add(\nnumber_1: float = Option(..., \"--number_1\", \"-n\", help=\"The first number\"),\nnumber_2: float = Option(..., \"--number_2\", \"-m\", help=\"The second number\"),\n):\n\"\"\"Prints the sum of two numbers.\"\"\"\nprint(number_1 + number_2)\nreturn\n</code></pre> <p>Note</p> <p>The <code>--</code> and <code>-</code> in <code>Option(..., \"--number_1\", \"-n\", help=\"The first number\")</code> are used to define the long and short versions of the option. For example, the <code>--number_1</code> option can be used as <code>--number_1 1</code> or <code>-n 1</code>.</p>"},{"location":"sections/python_libraries/typer/#the-__init__py-file","title":"The <code>__init__.py</code> file","text":"<p>We now need to group the commands together and create a single Typer app. This is done in the <code>__init__.py</code> file (which, again, is a regular Python file, even if it has a strange name). The code for this file is:</p> <pre><code># Path: my_project/__init__.py\n\"\"\"**CLI access point**.\nWith this module we enable the ``python -m my_project``\nfunctionality.\nThe CLI should also be accessible through the command:\n``my_project``.\n\"\"\"\nfrom typer import Typer\nfrom my_project.cli.say import app as say\nfrom my_project.cli.operate import app as operate\napp = Typer()\napp.add_typer(say, name=\"say\")\napp.add_typer(operate, name=\"operate\")\n</code></pre>"},{"location":"sections/python_libraries/typer/#the-__main__py-file","title":"The <code>__main__.py</code> file","text":"<p>The <code>__main__.py</code> file inside the <code>my_project</code> directory is what allows us to run the CLI with:</p> <pre><code>python -m my_project &lt;command&gt;\n</code></pre> <p>The code for this file is as simple as:</p> <pre><code>\"\"\"**CLI access point**.\nWith this module we enable the ``python -m my_project``\nfunctionality.\nThe CLI should also be accessible through the command:\n``my_project``.\n\"\"\"\nfrom my_project.cli import app\nif __name__ == \"__main__\":\napp()\n</code></pre> <p>Note</p> <p>The chosen name for the CLI is <code>my_project</code>, but of course this can be changed to whatever you want.</p>"},{"location":"sections/python_libraries/typer/#running-the-cli","title":"Running the CLI","text":""},{"location":"sections/python_libraries/typer/#basic-usage","title":"Basic usage","text":"<p>After creating the CLI, we can run it from a terminal with:</p> <pre><code>python -m my_project &lt;command&gt;\n</code></pre> <p>where <code>&lt;command&gt;</code> is one of the commands defined in the <code>__init__.py</code> file. For example, we can run the <code>hello</code> command with:</p> <pre><code>python -m my_project say hello\n\n# Output:\nHello, world!\n</code></pre> <p>If we need help with the CLI, we can use the <code>--help</code> option:</p> <pre><code>python -m my_project --help\n\n# Output:\nUsage: example_cli [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n  --help                Show this message and exit.\n\nCommands:\n  operate\n  say\n</code></pre>"},{"location":"sections/python_libraries/typer/#get-rid-of-python-m","title":"Get rid of <code>python -m</code>","text":"<p>We can get rid of the <code>python -m</code> part by adding the following code to the <code>pyproject.toml</code> file:</p> <pre><code>[tool.poetry.scripts]\nmy_project = \"my_project.__main__:app\"\n</code></pre> <p>After that, we can install the CLI with:</p> <pre><code>poetry install\n</code></pre> <p>We should see something like:</p> <pre><code>Installing dependencies from lock file\n\nNo dependencies to install or update\n\nInstalling the current project: example-cli (0.1.0)\n</code></pre> <p>Now, we can run the CLI with:</p> <pre><code>my_project &lt;command&gt;\n</code></pre>"},{"location":"sections/sql/introduction/","title":"SQL","text":"<p>SQL (Structured Query Language) is a programming language used to communicate with data stored in a  relational database management system. SQL syntax is similar to the English language, which makes it  relatively easy to write, read, and interpret.</p> <p>SQL is used to perform tasks such as:</p> <ul> <li>Create new databases</li> <li>Create new tables in a database</li> <li>Insert records in a database</li> <li>Update records in a database</li> <li>Delete records from a database</li> <li>Retrieve data from a database</li> </ul> <p>In this section we will cover the basics of SQL, and how to connect to a SQL database from Python.</p>"},{"location":"sections/sql/introduction/#sql-database-engines","title":"SQL DataBase engines","text":"<p>There are many different SQL database engines, but the most common are:</p> <ul> <li>SQLite</li> <li>MySQL</li> <li>PostgreSQL</li> <li>Microsoft SQL Server</li> <li>Oracle SQL</li> </ul> <p>They all share a common SQL syntax, but each has its own unique set of features and capabilities. Once we get familiar with SQL, it is relatively easy to switch between different database engines.</p>"},{"location":"sections/sql/introduction/#connecting-to-a-sql-database","title":"Connecting to a SQL database","text":"<p>In order to connect to an already existing SQL database, we have several options:</p> <ul> <li>Use a GUI (Graphical User Interface) such as DBeaver.</li> <li>Connect to the DB from PyCharm (see here). </li> <li>Use a general Python package such as SQLAlchemy, that works   with many different SQL engines.</li> <li>Use a specific Python package for the SQL engine that we are using. For example,    mysql.connector    for MySQL, or psycopg2 for PostgreSQL.</li> </ul>"},{"location":"sections/sql/introduction/#sql-language","title":"SQL language","text":"<p>SQL is a declarative language, which means that we tell the database what we want to do, and the database engine figures out how to do it. This is different from imperative languages such as Python, where we tell the computer exactly what to do, step by step.</p> <p>SQL is built over queries, which are statements that we send to the database engine. The most common query is the <code>SELECT</code> statement, which is used to read data from a database. Other common queries are <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code>, which are used to modify data in a database.</p>"},{"location":"sections/sql/modification_statements/","title":"Data modification statements","text":"<p>Data modification statements are used to modify data in a database, in contrast to data query statements, which are used to read data from a database and do not modify the data. </p>"},{"location":"sections/sql/modification_statements/#insert","title":"INSERT","text":"<p>INSERT statements are used to add new rows to a table. The syntax is as follows, to insert one row into a table:</p> <p><pre><code>INSERT INTO table_name (column_list)\nVALUES (value_list);\n</code></pre> To insert multiple rows into a table, we can use the following syntax:</p> <pre><code>INSERT INTO table_name (column_list)\nVALUES (value_list_1),\n(value_list_2),\n(value_list_3),\n...\n(value_list_n);\n</code></pre> <p>We can also insert rows into a table from another table, using the following syntax:</p> <pre><code>INSERT INTO table_name (column_list)\nSELECT column_list\nFROM table_name;\n</code></pre> <p>Note</p> <p>INSERT operations on a table without any indices are fast because the new row can simply be  appended to the end of the table. It is an O(1) operation. Conversely, INSERT/UPDATE/DELETE  statements with indices are no longer simple. These operations render all indexes out-of-date,  and as such need to be reconstructed.</p> <p>The situation is reversed with SELECT statements: SELECT operations containing only non-key  fields in the WHERE clause on the same table will require a full table scan, an O(n) operation.  With indices, however, this operation becomes O(log(n)). </p>"},{"location":"sections/sql/modification_statements/#update","title":"UPDATE","text":"<p>UPDATE statements are used to modify existing rows in a table. The syntax is as follows:</p> <pre><code>UPDATE table_name\nSET column_1 = value_1,\ncolumn_2 = value_2,\n...\ncolumn_n = value_n\nWHERE condition;\n</code></pre>"},{"location":"sections/sql/modification_statements/#delete","title":"DELETE","text":"<p>DELETE statements are used to delete rows from a table. The syntax is as follows:</p> <pre><code>DELETE FROM table_name\nWHERE condition;\n</code></pre>"},{"location":"sections/sql/other_operations/","title":"Other operations","text":""},{"location":"sections/sql/other_operations/#to-do","title":"TO DO","text":""},{"location":"sections/sql/other_operations/#other-operations","title":"Other operations","text":"<p>To kill a stuck process:</p> <p>select pid,         usename,         pg_blocking_pids(pid) as blocked_by,         query as blocked_query from pg_stat_activity where cardinality(pg_blocking_pids(pid)) &gt; 0;</p> <p>select * from pg_catalog.pg_stat_activity where pid = 386423</p> <p>SELECT pg_terminate_backend() <p>Optimitzar queries:</p> <p>https://explain.dalibo.com/ i us explain(..) com explica a la web</p>"},{"location":"sections/sql/select_statements/","title":"SELECT statement","text":"<p>The <code>SELECT</code> statement is used to read data from a database. The basic syntax is: <pre><code>SELECT c1, c2 FROM some_table;\n</code></pre></p> <p>Note</p> <p>Although it is common practice to put SQL reserved words in capital letters, in general it is not necessary. For example, <code>SELECT</code> and <code>select</code> are equivalent.</p> <p>The last query will return columns <code>c1</code>, <code>c2</code> from the table <code>some_table</code>.  We can also use the <code>*</code> to query all rows from a table <pre><code>SELECT * FROM some_table;\n</code></pre></p> <p>Note</p> <p>The select statement from SQL is similar to panda's <code>.loc</code> function.  For example, to write the previous query in pandas we would do: <pre><code>df.loc[:, ['c1', 'c2']]\n</code></pre></p>"},{"location":"sections/sql/select_statements/#aliases","title":"Aliases","text":"<p>Sometimes we want to rename the columns that we are querying. We can do this using aliases for tables and columns:</p> <pre><code>SELECT CustomerID AS ID, CustomerName AS Customer\nFROM some_table AS t;\n</code></pre> <p>This is particularly useful when we are accessing data from multiple tables, and we want to avoid ambiguities. For example, if we have two tables with a column called <code>id</code>, we can use aliases to distinguish between them:</p> <pre><code>SELECT t1.id AS id1, t2.id AS id2\nFROM table1 AS t1\nINNER JOIN table2 AS t2 ON t1.id = t2.id;\n</code></pre> <p>We will see more about <code>JOIN</code> statements later. </p> <p>Note</p> <p>We can use break lines in SQL queries to make them more readable, but this is not necessary. With breaklines or not, the query will be executed in the same way.</p> <p>We can also use aliases to define new columns: <pre><code>SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address FROM Customers;\n</code></pre></p> <p>Note</p> <p>The table we query from does not need to be an existing table: it can be any form of  derived table, created by another <code>SELECT ...</code> statement. Typical ways to create this new tables to query from are Common Table Expressions (CTEs) and subqueries (just another <code>SELECT</code> statement between parentheses). We will see more about this later.</p>"},{"location":"sections/sql/select_statements/#where-clauses","title":"WHERE clauses","text":"<p>So far we have seen how to query all rows from a table. However, in most cases we want to query only a subset of the rows. We can do this using the <code>WHERE</code> clause:</p> <pre><code>SELECT c1, c2 FROM table_1 as t WHERE some_condition;\n</code></pre> <p>In the last example, <code>some_condition</code> is a boolean expression that evaluates to <code>True</code> or <code>False</code>.</p> <p>Note</p> <p><code>some_condition</code> can be of type <code>=</code> (e.g. <code>A = 3</code>), different <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, etc.  Conditions can be chained by <code>AND</code> and <code>OR</code> operators. They can also be of the type <code>in a set</code>, e.g.: <code>IN (value1, value2, ...);</code>, or equivalently in a derived table with one column, <code>IN (SELECT ...)</code>.</p> <p>Note</p> <p>To match a string, we can use the <code>LIKE</code> operator, which allows us to use wildcards such as <code>%</code> and <code>_</code>. For example, to match all strings that start with <code>a</code> and end with <code>b</code>, we can use the following condition: <pre><code>WHERE c1 LIKE 'a%b';\n</code></pre></p>"},{"location":"sections/sql/select_statements/#other-operators","title":"Other operators","text":""},{"location":"sections/sql/select_statements/#distinct","title":"DISTINCT","text":"<p>Distinct rows from a table can be queried using the <code>DISTINCT</code> keyword:</p> <pre><code>SELECT DISTINCT c1, c2 FROM t WHERE some_condition;\n</code></pre>"},{"location":"sections/sql/select_statements/#order-by","title":"ORDER BY","text":"<p>We can also sort the result set in ascending or descending order using the <code>ORDER BY</code> clause:</p> <pre><code>SELECT c1, c2 FROM t ORDER BY c1 ASC [or DESC];\n</code></pre>"},{"location":"sections/sql/select_statements/#limit-and-offset","title":"LIMIT and OFFSET","text":"<p>To limit the number of rows returned by a query, we can use the <code>LIMIT</code> clause:</p> <p><pre><code>SELECT c1, c2 FROM t LIMIT n;\n</code></pre> To skip offset of rows and return the next n rows, we can use the <code>OFFSET</code> clause:</p> <pre><code>SELECT c1, c2 FROM t ORDER BY c1 LIMIT n OFFSET offset;\n</code></pre>"},{"location":"sections/sql/select_statements/#group-by-and-aggregate-functions","title":"GROUP BY and aggregate functions","text":"<p>Like in pandas, we can group unique values of one or more columns and apply an aggregate function to them</p> <pre><code>SELECT c1, aggregate(c2) FROM t GROUP BY c1;\n</code></pre> <p>Aggregate functions are, essentially, functions that take a set of values and return a single value. We apply the aggregate function to each column that is not grouped by. For example, we can count the number of rows in each group: <pre><code>SELECT creator, count(*) from fragrances group by creator;\n</code></pre></p> <p>Inside the <code>COUNT</code> parentheses you can put a DISTINCT to count different appearances or all of them.</p> <p>Note</p> <p>The COUNT function returns the number of rows for which the expression evaluates to a non-null value.  (* is a special expression that is not evaluated, it simply returns the number of rows.)</p> <p>Usual aggregate functions are:</p> <ul> <li><code>COUNT</code> (count the number of rows)</li> <li><code>SUM</code> (sum of all values in a column)</li> <li><code>AVG</code> (average of all values in a column)</li> <li><code>MIN</code> (minimum value in a column)</li> <li><code>MAX</code> (maximum value in a column)</li> <li><code>STDDEV</code> (standard deviation of all values in a column)</li> </ul>"},{"location":"sections/sql/select_statements/#having","title":"HAVING","text":"<p>HAVING is used to filter records that work on summarized GROUP BY results. HAVING is typically used with a  GROUP BY clause. When GROUP BY is not used, HAVING behaves like a WHERE clause.</p> <p>Note</p> <p>Difference between HAVING and WHERE: </p> <ul> <li>HAVING is used to check conditions after the aggregation takes place. </li> <li>WHERE is used to check conditions before the aggregation takes place.</li> </ul> <p>Hence, when we can use it, WHERE is faster than HAVING.</p> <p>For example, this code: <pre><code>select City, COUNT(*)\nFrom Address\nWhere State = 'MA'\nGroup By City\n</code></pre> Gives you a table of all cities in MA and the number of addresses in each city. This code: <pre><code>select City, COUNT(*)\nFrom Address\nWhere State = 'MA'\nGroup By City\nHaving COUNT(*)&gt;5\n</code></pre></p> <p>Gives you a table of cities in MA with more than 5 addresses and the number of addresses in each city.</p>"},{"location":"sections/sql/select_statements/#case-statements","title":"CASE statements","text":"<p>The CASE statement goes through conditions as and <code>if/elif</code> statement, and returns a column:</p> <pre><code>SELECT OrderID, Quantity,\nCASE WHEN Quantity &gt; 30 THEN 'The quantity is greater than 30'\nWHEN Quantity = 30 THEN 'The quantity is 30'\nELSE 'The quantity is under 30'\nEND AS QuantityText\nFROM OrderDetails;\n</code></pre>"},{"location":"sections/sql/select_statements/#table-joins","title":"Table JOINs","text":"<p>A join stitches together 2 tables, based on some condition (e.g. equality of a row). We use the <code>JOIN</code> when we want to query data from multiple tables at once. The basic syntax is:</p> <pre><code>SELECT c1, c2 FROM t1 INNER JOIN t2\nON condition;\n</code></pre> <p>For example, we can join the <code>Customers</code> and <code>Orders</code> tables to get the name of the customer who made each order:</p> <pre><code>SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate\nFROM Orders\nINNER JOIN\nCustomers\nON\nOrders.CustomerID = Customers.CustomerID;\n</code></pre> <p>Note</p> <p>The SQL Join is the equivalent of the <code>merge</code> function in pandas.</p> <p>Joins can be of several different types:</p> <ul> <li>INNER (intersection of values)</li> <li>LEFT (Intersection + unpaired from left table)</li> <li>RIGHT (same but with right table) </li> <li>FULL OUTER (both).</li> </ul>"},{"location":"sections/sql/select_statements/#combine-rows-from-two-queries","title":"Combine rows from two queries","text":"<p>UNION ALL is used to combine the result from multiple SELECT statements into a single result set.</p> <pre><code>SELECT c1, c2 FROM t1 UNION ALL\nSELECT c1, c2 FROM t2;\n</code></pre> <p>We can also find the intersection of two queries, or subtract one from the other. Intersection:</p> <p><pre><code>SELECT c1, c2 FROM t1 INTERSECT SELECT c1, c2 FROM t2;\n</code></pre> Subtract a result set from another result set: <pre><code>SELECT c1, c2 FROM t1 MINUS SELECT c1, c2 FROM t2;\n</code></pre></p>"},{"location":"sections/sql/select_statements/#subqueries","title":"Subqueries","text":"<p>A subquery is a SELECT query nested inside another query. We can use subqueries to query data from multiple tables, or to query data from the same table using different conditions. For example, we can use a subquery to find the name of the customer who made the most recent order:</p> <pre><code>SELECT CustomerName\nFROM\nCustomers\nWHERE\nCustomerID = (\nSELECT CustomerID FROM Orders ORDER BY OrderDate DESC LIMIT 1\n);\n</code></pre>"},{"location":"sections/sql/select_statements/#common-table-expressions-ctes","title":"Common Table Expressions (CTEs)","text":"<p>A Common Table Expression (CTE) is a temporary result set that we can reference within another query. It is similar to a subquery, but it is more readable (because it has a name), and hence it is easier to  maintain. </p> <p>CTEs always start with the <code>WITH</code> keyword, followed by the name of the CTE, and the query that defines it. For example, we can use a CTE to find the name of the customer who made the most recent order:</p> <pre><code>WITH last_order AS (\nSELECT CustomerID FROM Orders ORDER BY OrderDate DESC LIMIT 1\n)\nSELECT CustomerName\nFROM\nCustomers\nWHERE\nCustomerID = last_order.CustomerID;\n</code></pre> <p>We can define multiple CTEs in the same query, and we can also use CTEs to query data from multiple tables:</p> <pre><code>WITH last_order AS (\nSELECT CustomerID FROM Orders ORDER BY OrderDate DESC LIMIT 1\n),\ncustomer AS (\nSELECT CustomerName\nFROM\nCustomers\nWHERE\nCustomerID = last_order.CustomerID\n)\nSELECT\ncustomer.CustomerName,\nOrders.OrderDate\nFROM\nOrders\nINNER JOIN\ncustomer\nON\nOrders.CustomerID = customer.CustomerID;\n</code></pre>"},{"location":"sections/sql/sql_from_python/","title":"SQL queries from Python","text":"<p>To connect to a SQL database from Python, we need to install a package that allows us to do so.  One of the most popular packages for this is <code>sqlalchemy</code>. We can install it with <code>pip</code>:</p> <pre><code>pip install sqlalchemy\n</code></pre>"},{"location":"sections/sql/sql_from_python/#connecting-to-sql-databases-with-sqlalchemy","title":"Connecting to SQL Databases with SQLAlchemy","text":"<p>To create a connection to a SQL database, we need to create an engine, an object that  manages connections to the database. To create an engine, we need to provide a database URI, which is a string that tells SQLAlchemy how to connect to the database. The format of the URI depends on the type of database we are connecting to. For example, to connect to a SQLite database from a file called <code>database.db</code> that is on the same folder as the Python script, we can use the following URI:</p> <pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nDB_URI = \"sqlite:///database.db\"\nengine = create_engine(DB_URI, pool_pre_ping=True)\n</code></pre> <p>Once we have an engine, we can create a session, which is an object that manages transactions (i.e. reading and writing) to the database.</p> <pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nDB_URI = \"sqlite:///database.db\"\nengine = create_engine(DB_URI, pool_pre_ping=True)\nSessionLocal = sessionmaker(\nautocommit=False,\nautoflush=False,\nbind=engine,\n)\n</code></pre> <p>Note</p> <p>The <code>pool_pre_ping</code> argument is used to check if the connection to the database is still alive before using it. This is useful when using a database in a remote server, as the connection might be lost if the server is not used for a while.</p> <p><code>SessionLocal</code> is a class that we can use to create session objects. We can create a session object by calling the class thus defined:</p> <pre><code>with SessionLocal() as session:\n# Do something with the session\n...\n</code></pre> <p>Note</p> <p>The session creation code is a bit obscure, but it is always the same, so it can be copied into a separate file. For example, we can copy the code above into a file  called <code>database_session.py</code> (for example). Then, we can import the <code>SessionLocal</code> class  from that file as follows:</p> <pre><code>from database_session import SessionLocal\n</code></pre>"},{"location":"sections/sql/sql_from_python/#readinginsert-to-a-sql-database-with-pandas","title":"Reading/insert to a SQL database with Pandas","text":"<p>Now that we have a session object, we can use it to read and write to the database.</p>"},{"location":"sections/sql/sql_from_python/#reading-from-a-sql-database","title":"Reading from a SQL database","text":"<p>To read data from a SQL database and load it into a pandas DataFrame, we need to provide a SQL query and  a session object. For example, to read all the rows from a table called <code>users</code>, we can use the following code:</p> <pre><code>from sqlalchemy import text\nimport pandas as pd\nfrom database_session import SessionLocal\nquery = text(\"SELECT * FROM users\")\nwith SessionLocal() as session:\ndf = pd.DataFrame(session.execute(query))\n</code></pre> <p>This code will return a pandas dataframe with all the rows from the <code>users</code> table. </p> <p>Note</p> <p>The <code>text</code> function is used to convert a string into a SQLAlchemy <code>TextClause</code> object, which is the type of object that <code>session.execute</code> expects as the first argument.</p>"},{"location":"sections/sql/sql_from_python/#inserting-into-a-sql-database","title":"Inserting into a SQL database","text":"<p>Pandas' <code>to_sql</code> is a function that allows us to insert data from a pandas dataframe into a SQL database with a single line of code, without having to write any SQL INSERT queries. To use <code>to_sql</code>, we need to provide a pandas dataframe and a table name. For example, to insert the rows from a dataframe called <code>df</code> into a table called <code>users</code>, we can use the following code:</p> <pre><code>from sqlalchemy import text\nimport pandas as pd\nfrom database_session import SessionLocal\nwith SessionLocal() as session:\ndf.to_sql(\"users\", session.connection(), if_exists=\"append\", index=False)\n</code></pre> <p>Note</p> <p>The <code>if_exists</code> argument is used to specify what to do if the table already exists. In this case, we are telling pandas to append the rows from the dataframe to the table. If we wanted to replace the table, we could use <code>if_exists=\"replace\"</code> instead.</p> <p>The <code>index</code> argument is used to specify whether to include the index of the dataframe as a  column or not (usually we will not want to do that).</p>"},{"location":"sections/sql/sql_from_python/#working-snippet","title":"Working snippet","text":"<p>After installing sqlalchemy and saving a SQLite database called <code>hr</code> in the same folder as the Python script, we can use the following code to read all the rows from the <code>employees</code> table:</p> <pre><code>from sqlalchemy import create_engine, text\nfrom sqlalchemy.orm import sessionmaker\nimport pandas as pd\nDB_URI = \"sqlite:///hr\"\nengine = create_engine(DB_URI, pool_pre_ping=True)\nSessionLocal = sessionmaker(\nautocommit=False,\nautoflush=False,\nbind=engine,\n)\nquery = text(\"SELECT * FROM employees\")\nwith SessionLocal() as session:\ndf = pd.DataFrame(session.execute(query))\nprint(df.head())\n</code></pre> <p>Note</p> <p>The previous code should run \"as is\" if the <code>hr</code> database is in the same folder as the Python.</p> <pre><code># Output:\nemployee_id first_name last_name  ... manager_id department_id Avg_Salary\n0          100     Steven      King  ...          0            90       None\n1          101      Neena   Kochhar  ...        100            90       None\n2          102        Lex   De Haan  ...        100            90       None\n3          103  Alexander    Hunold  ...        102            60       None\n4          104      Bruce     Ernst  ...        103            60       None\n</code></pre>"},{"location":"sections/sql/sql_from_python/#executing-raw-sql-queries","title":"Executing raw SQL queries","text":"<p>Not all SQL queries come from or should be inserted into a pandas DataFrame. With SQLAlchemy we can also execute  raw SQL queries (i.e., any valid SQL code we want) with the line <code>session.execute(query)</code>. For example, if we wanted to delete a table from the DB we would do:</p> <pre><code>from sqlalchemy import text\nfrom database_session import SessionLocal\nquery = text(\"drop table some_table\")\nwith SessionLocal() as session:\nsession.execute(query)\n</code></pre>"},{"location":"sections/sql/table_operations/","title":"Table operations","text":"<p>Beyond the basic CRUD (create, read, update, delete) operations, there are a number of other operations  that can be performed on tables.</p>"},{"location":"sections/sql/table_operations/#creating-a-table","title":"Creating a table","text":"<p>To create a new table in a database, we use the <code>CREATE TABLE</code> statement. The syntax is as follows:</p> <p><pre><code>CREATE TABLE t (\nid INT PRIMARY KEY,\nname VARCHAR NOT NULL,\nprice INT DEFAULT 0\n);\n</code></pre> As seen in the example, we need to specify the name of the table, and a list of columns, each with a  name and a data type. Data types can be numeric, character, date/time, etc:</p> <ul> <li>Numeric data types:<ul> <li><code>INT</code> - Integer</li> <li><code>FLOAT</code> - Floating point number</li> <li><code>DECIMAL</code> - Fixed precision number</li> <li><code>BOOLEAN</code> - Boolean value (True or False)</li> </ul> </li> <li>Character data types:<ul> <li><code>CHAR(n)</code> - Fixed length character string</li> <li><code>VARCHAR(n)</code> - Variable length character string</li> </ul> </li> </ul> <p>We can also specify constraints on the columns, the most important being the primary key (see the next section for more details on constraints). </p> <p>In the example, we have specified that the <code>id</code> column is the primary key. We have also specified that the <code>name</code> column cannot contain NULL values, and that the <code>price</code> column has a default value of 0.</p>"},{"location":"sections/sql/table_operations/#deleting-a-table","title":"Deleting a table","text":"<p>Similarly, to delete a table from a database, we use the <code>DROP TABLE</code> statement. The syntax is as follows:</p> <pre><code>DROP TABLE t;\n</code></pre>"},{"location":"sections/sql/table_operations/#altering-a-table","title":"Altering a table","text":"<p>There are a number of operations that can be performed on a table after it has been created. These operations are performed using the <code>ALTER TABLE</code> statement. </p> <ul> <li>Add a new column to the table:     <pre><code>ALTER TABLE t ADD column_name data_type;\n</code></pre></li> <li> <p>Drop column <code>c</code> from the table     <pre><code>ALTER TABLE t DROP COLUMN c;\n</code></pre></p> </li> <li> <p>Rename a table from <code>t1</code> to <code>t2</code> <pre><code>ALTER TABLE t1 RENAME TO t2;\n</code></pre></p> </li> <li> <p>Rename column c1 to c2     <pre><code>ALTER TABLE t1 RENAME c1 TO c2 ;\n</code></pre></p> </li> <li> <p>Remove all data from a table (but keep the table structure):     <pre><code>TRUNCATE TABLE t;\n</code></pre></p> </li> </ul>"},{"location":"sections/sql/table_operations/#table-constraints","title":"Table constraints","text":"<p>Table constraints are rules that are enforced on columns of a table. These are used to limit the type of data that can go into the table. The following constraints are commonly used in SQL:</p> <ul> <li><code>NOT NULL</code> - Ensures that a column cannot have a <code>NULL</code> value</li> <li><code>UNIQUE</code> - Ensures that all values in a column are different</li> <li> <p><code>PRIMARY KEY</code> - A combination of <code>NOT NULL</code> plus <code>UNIQUE</code>. Uniquely identifies each row in a table.</p> <p>Note</p> <p>Each table can have only one primary key, and although it is not mandatory, it is a very good practice to have a primary key in every table. Columns that can potentially be primary keys are known  as candidate keys; we can choose any candidate key to be the primary key. </p> <p>Note</p> <p>Primary keys can also be \"composite\", i.e., a combination of columns that uniquely identify each row.</p> </li> <li> <p><code>FOREIGN KEY</code> - Foreign keys are used to link two tables together. A foreign key in one table points      to a primary key in another table. </p> <p>Note</p> <p>For example, if we have a table called <code>Orders</code> that contains information about orders made by  customers, we can create a foreign key in the <code>Orders</code> table that points to the <code>CustomerID</code>  column in the <code>Customers</code> table. This way, we can easily find the customer who made each order. </p> </li> <li> <p><code>DEFAULT</code> - Sets a default value for a column if no value is specified</p> </li> <li><code>CREATE INDEX</code> - Used to create and retrieve data from the database very quickly</li> </ul> <p>Note</p> <p>Table indexes are used to speed up the retrieval of data from a table. Usually, the data in a  table is stored in an unordered manner. When we create an index, the database stores the data in a sorted manner, which makes it much faster to retrieve data from the table. However, this comes at the cost of slower insertions, updates and deletions, since the database has to maintain the sorted order of the data. Hence, we should only create indexes on columns that we frequently use to retrieve data from the table.</p> <p>To add a constraint on a table, we also use the <code>ALTER TABLE</code> statement. The syntax is as follows: <pre><code>ALTER TABLE t ADD constraint;\n</code></pre></p>"},{"location":"sections/sql/table_operations/#example-queries","title":"Example queries","text":"<ul> <li>To add a primary key constraint on the <code>id</code> column of the <code>t</code> table, we can use the following statement:     <pre><code>ALTER TABLE t ADD PRIMARY KEY (id);\n</code></pre></li> <li>To add a foreign key constraint on the <code>customer_id</code> column of the <code>orders</code> table, we can use the following statement:     <pre><code>ALTER TABLE orders ADD FOREIGN KEY (customer_id) REFERENCES customers(id);\n</code></pre></li> <li>To add a default value of 0 to the <code>price</code> column of the <code>t</code> table, we can use the following statement:     <pre><code>ALTER TABLE t ALTER COLUMN price SET DEFAULT 0;\n</code></pre></li> <li>To add a <code>NOT NULL</code> constraint on the <code>name</code> column of the <code>t</code> table, we can use the following statement:     <pre><code>ALTER TABLE t ALTER COLUMN name SET NOT NULL;\n</code></pre></li> <li>To add a <code>UNIQUE</code> constraint on the <code>name</code> column of the <code>t</code> table, we can use the following statement:     <pre><code>ALTER TABLE t ADD UNIQUE (name);\n</code></pre></li> <li>To add an index on the <code>name</code> column of the <code>t</code> table, we can use the following statement:     <pre><code>CREATE INDEX name_index ON t (name);\n</code></pre></li> </ul> <p>To drop a constraint we use the following syntax: <pre><code>ALTER TABLE t DROP constraint;\n</code></pre> For example, to drop the <code>NOT NULL</code> constraint on the <code>name</code> column of the <code>t</code> table, we can use the following statement: <pre><code>ALTER TABLE t ALTER COLUMN name DROP NOT NULL;\n</code></pre></p>"},{"location":"sections/sql/window_functions/","title":"Window functions","text":"<p>A window function is a type of Select statement that performs a calculation across a set of table rows, which are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate  function but, unlike regular aggregate functions, use of a window function does not cause rows to  become grouped into a single output row; the rows retain their separate identities. </p> <p> </p> Group by vs. Window functions. <p>Behind the scenes, the window function is able to access more than just the current row of the query result.</p>"},{"location":"sections/sql/window_functions/#syntax","title":"Syntax","text":"<p>The <code>OVER</code> clause is what specifies a window function and must always be included in the statement.  The default in an OVER clause is the entire rowset. As an example, let\u2019s look at an employee table in a  company database and show the total number of employees on each row, along with each employee\u2019s info,  including when they started with the company.</p> <p><pre><code>SELECT COUNT(*) OVER() As NumEmployees, firstname, lastname, date_started\nFROM Employee\nORDER BY date_started;\n</code></pre> <pre><code>NumEmployees    firstname   lastname    date_started\n3   John    Smith   2019-01-01 00:00:00.000\n3   Sally   Jones   2019-02-15 00:00:00.000\n3   Sam     Gordon  2019-02-18 00:00:00.000\n</code></pre></p> <p>The above, like many window functions, can also be written with a regular subquery:</p> <pre><code>SELECT\n(SELECT COUNT(*) FROM Employee) as NumEmployees, firstname, lastname, date_started\nFROM Employee\nORDER BY date_started;\n</code></pre> <p>But now, let\u2019s say we wish to show the number of employees who started in the same month as the  employee in the row. We will need to narrow or restrict the count to just that month for each row.  How is that done? We use the window PARTITION clause, like so:</p> <pre><code>SELECT COUNT(*) OVER (PARTITION BY MONTH(date_started),YEAR(date_started)) As NumPerMonth, DATENAME(month,date_started)+' '+DATENAME(year,date_started) As TheMonth,\nfirstname, lastname\nFROM Employee\nORDER BY date_started;\n</code></pre> <pre><code>NumPerMonth TheMonth    Firstname   Lastname\n1   January  2019   John    Smith\n2   February 2019   Sally   Jones\n2   February 2019   Sam     Gordon\n</code></pre> <p>Note</p> <p>Partitions allow you to filter the window into sections by a certain value or values. In contrast to GROUP BY, the PARTITION BY clause does not reduce the number of rows returned by the query. In the last example, if we used a <code>Group By</code> clause to calculate the number of employees that started in a particular month instead of a <code>Partition By</code>, we would have gotten only two rows, one for January 2019 and another for February 2019. Hence, we would be losing the information about each particular employee.</p> <p>To take it further, let\u2019s say we not only wanted to find out how many employees started in the  same month, but we want to show in which order they started that month. For that, we can use the  familiar <code>ORDER BY</code> clause. However, within a window function, <code>ORDER BY</code> acts a bit differently than  it does at the end of a query.</p> <p><pre><code>SELECT COUNT(*) OVER (PARTITION BY MONTH(date_started), YEAR(date_started) ORDER BY date_started) As NumThisMonth,\nDATENAME(month,date_started)+' '+DATENAME(year,date_started) As TheMonth,\nfirstname, lastname, date_started\nFROM Employee\nORDER BY date_started;\n</code></pre> <pre><code>NumThisMonth    TheMonth    Firstname   lastname\n1   January  2019   John    Smith\n1   February 2019   Sally   Jones\n2   February 2019   Sam     Gordon\n</code></pre></p> <p>In this case, <code>ORDER BY</code> modifies the window so that it goes from the start of the partition  (in this case the month and year of when the employee started) to the current row. Thus, the count  restarts at each partition.</p>"}]}