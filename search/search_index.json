{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>This site contains notes for the following courses:</p> <ul> <li>PROGRAMMING FOR DATA MANAGEMENT &amp; ANALYSIS</li> <li>PYTHON FOR DATA ANALYSIS 1 &amp; 2</li> </ul> <p>taught by Gerard Conangla Planes.</p> <p>The notes cover almost all topics that are needed for the courses (and sometimes a bit more),  but there might be some gaps and typos. I will include more chapters in the notes as the semester advances.</p> <p>Note</p> <p>It is recommended to complement this notes with information from the rest of the bibliography,  the internet and, of course, a lot of practice doing exercises.</p>"},{"location":"#detecting-errors-in-the-notes","title":"Detecting errors in the notes","text":"<p>If you find any error, please write me at gconangla@faculty.ie.edu and I will try to fix it as fast as I can.</p>"},{"location":"programming/python/classes/","title":"Classes and objects","text":""},{"location":"programming/python/classes/#classes-and-object-oriented-programming","title":"Classes and Object-Oriented-Programming","text":"<p>Objects and classes are a way to group up a bunch of function and variables into a single \"thing\". When you get  all the way down to it, this is simply a way of organizing everything into groups that make sense.  There are benefits down the road for making things easier to understand, debug, extend, or maintain, but  basically it is just a way to make code easy to understand and develop.</p> <p>This might sound very abstract, but in practice it is not: everything is an object in Python!  <code>int</code>, <code>dict</code>, <code>list</code>... etc. are all different types of objects.</p> <p>To be more precise, <code>int</code>, <code>dict</code>, <code>list</code>... are known as classes, and objects are particular instances of such classes. In the next example:  <pre><code>a = 2\n</code></pre> <code>int</code> would be the class, and <code>a</code> would be the object (or instance, they are used interchangeably). So,  in other words, classes are the blueprint from which objects are created.</p> <p>Note</p> <p>It is often helpful to make analogies of classes with animals: for instance, if <code>dog</code> is a class, then <code>Max = dog()</code> (one dog in particular) is the instance.</p> <p>Making use of classes in programming is what is known as Object-Oriented-Programming (OOP). OOP is highly  concerned with code organization, reusability, and encapsulation. OOP is partially in contrast to Functional  Programming, which is a different paradigm used a lot in Python. Not everyone who programs in Python  uses OOP. </p> <p>Note</p> <p>So, should we use functions or classes when programming? As a general rule of thumb, we can think of classes/objects  as nouns and functions/methods as verbs. In other words, functions do specific things, classes are  specific things. With a language like Python we are not forced to choose: we can use just a little bit of each, when it is most convenient.</p>"},{"location":"programming/python/classes/#defining-classes","title":"Defining classes","text":"<p>Python makes it very easy to define our own classes. A very basic class would look something like this:</p> <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\n</code></pre> <p>Note</p> <p>Variables in classes are also known as attributes, and functions in classes are also known as methods. These words are complete synonyms.</p> <p>We'll explain why you have to include that <code>self</code> as a parameter a little bit later.  First, to assign the above class to an object you would do the following:</p> <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\n</code></pre> <p>Now the variable <code>myobjectx</code> holds an object of the class <code>MyClass</code> that contains the variable  and the function defined within the class called <code>MyClass</code>. Accessing Object Variables</p>"},{"location":"programming/python/classes/#accessing-object-variables","title":"Accessing object variables","text":"<p>To access the variable inside the newly created object <code>myobjectx</code> you would do the following: <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nmyobjectx.variable\n</code></pre></p> <p>So for instance the below would output the string <code>blah</code>: <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nprint(myobjectx.variable)\n</code></pre></p> <p>You can create multiple different objects that are of the same class (i.e., have the same variables and functions  defined). However, each object contains independent copies of the variables defined in the class. For instance,  if we were to define another object with the <code>MyClass</code> class and then change the string in the variable above:</p> <p><pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nmyobjecty = MyClass()\nmyobjecty.variable = \"yackity\"\n# Then print out both values\nprint(myobjectx.variable)\nprint(myobjecty.variable)\n</code></pre> nothing would happen to the first object.</p>"},{"location":"programming/python/classes/#accessing-object-functions","title":"Accessing object functions","text":"<p>To access a function inside of an object you use notation similar to accessing a variable:</p> <pre><code>class MyClass:\nvariable = \"blah\"\ndef function(self):\nprint(\"This is a message inside the class.\")\nmyobjectx = MyClass()\nmyobjectx.function()\n</code></pre> <p>The above would print out the message <code>This is a message inside the class.</code></p>"},{"location":"programming/python/classes/#the-meaning-of-self","title":"The meaning of <code>self</code>","text":"<p>The built-in <code>self</code> is used by a class to refer to a specific instantiation of the class. This is easier seen with an example. Consider this class:</p> <pre><code>class Dog:\ndef set_name(name):\ndog_name = name\n</code></pre> <p>and now compare it to:</p> <pre><code>class Dog:\ndef set_name(self, name):\nself.dog_name = name\n</code></pre> <p>The idea of the function <code>set_name</code> is clear: we want to give a name to our object of the class <code>Dog</code>. So, what's the difference between both cases? In the first case, we are defining <code>dog_name</code> inside of the  function <code>set_name</code>, but when we leave the function this \"inside\" variable disappears. Hence, the function has no effect.</p> <p>Note</p> <p>Actually, the first function would not work for reasons a bit more obscure, but that doesn't matter for now. See this  if you're interested in reading more aaa.</p> <p>What we want to do is access the particular dog instance, and set a name to that instance. This is the  purpose of <code>self</code>: it means \"our current instance\".</p>"},{"location":"programming/python/classes/#__init__-function","title":"<code>__init__()</code> function","text":"<p>The <code>__init__()</code> function is a special function that is called when the class is being instantiated.  <code>__init__</code> doesn't initialize a class, it initializes an instance of a class or an object. </p> <p>The difference between variables assigned inside the <code>__init__()</code> method versus variables assigned in the class definition is that in the first case we are only defining values for one particular instance, whereas if we define a value in the class definition, all objects from that class will have the same value. </p> <p>Note</p> <p>In other words, each dog has colour, but dogs as a class don't: hence the color for one particular dog should be defined inside the <code>__init__()</code> method. </p> <p>The class is a concept of an object. When you see Fido and Spot, you recognise their similarity,  their doghood. That's the class. However, when you say <pre><code>class Dog:\ndef __init__(self, legs, colour):\nself.legs = legs\nself.colour = colour\nfido = Dog(4, \"brown\")\nspot = Dog(3, \"mostly yellow\")\n</code></pre></p> <p>You're saying, Fido is a brown dog with 4 legs while Spot is a bit of a cripple and is mostly yellow. </p>"},{"location":"programming/python/classes/#class-inheritance","title":"Class inheritance","text":"<p>Inheritance is a mechanism that allows you to create a hierarchy of classes that share a set of  properties and methods by deriving a class from another class. This is extremely useful because it allows us to write less code thanks to code reuse.</p> <p>For instance, imagine that we need to define a class for a dogs and cats (and potentially many more). Instead of  writing everything every time for each other animal that we define, we could make them inherit from another parent class <code>Animal</code>:</p> <pre><code>class Animal:\ndef __init__(self, age, height):\nself.age = age\nself.height = height\ndef print_height(self):\nprint(self.height)\nclass Dog(Animal):\ndef __init__(self, age, height, race):\nsuper().__init__(age, height)\nself.race = race        \nclass Cat(Animal):\ndef __init__(self, age, height, meowness):\nsuper().__init__(age, height)\nself.meowness = meowness\nmy_cat = Cat(age=2, height=35, meowness=0.5)\nsome_dog = Dog(age=1, height=50, race=\"beagle\")\nmy_cat.print_height()\nprint(some_dog.race)\n# Output\n35\nbeagle\n</code></pre> <p>In this example, <code>Dog</code> and <code>Cat</code> inherit from the class <code>Animal</code>. This means that all <code>Animal</code> methods and attributes are also available to <code>Dog</code> and <code>Cat</code> as if they were defined inside their definitions. </p> <p>Note</p> <p>In the previous code snippet you might notice the use of the <code>super()</code> function. <code>super()</code> is a built-in function returns a proxy that allows us to access methods of the base class. We use it to refer to the base class: in the previous example, we are using it to call the <code>Animal.__init__</code> function from the <code>Dog</code> and <code>Cat</code> <code>__init__</code> functions.</p>"},{"location":"programming/python/control_flow/","title":"Control flow","text":""},{"location":"programming/python/control_flow/#conditional-statements","title":"Conditional statements","text":"<p>Python uses boolean logic to evaluate conditions. For example: <pre><code>x = 2\nprint(x == 2) # prints out True\nprint(x == 3) # prints out False\nprint(x &lt; 3) # prints out True\n</code></pre></p>"},{"location":"programming/python/control_flow/#ifelse-statements","title":"if/else statements","text":"<p>Conditional statements are used to control the flow of the program with <code>if</code>/<code>else</code> statements.  We use the <code>if</code> statement to run a block code only when a certain condition is met.</p> <p>For example, assigning grades (A, B, C) based on marks obtained by a student.</p> <pre><code>if the percentage is above 90, assign grade A\nif the percentage is above 75, assign grade B\nif the percentage is above 65, assign grade C\n</code></pre> <p>In Python, there are three forms of the if...else statement.</p> <pre><code>if statement\nif...else statement\nif...elif...else statement\n</code></pre> <p>The syntax of if statement in Python is:</p> <p><pre><code>if condition:\n# body of if statement\n</code></pre> The <code>if</code> statement evaluates <code>condition</code>.</p> <pre><code>If condition is evaluated to True, the code inside the body of if is executed.\nIf condition is evaluated to False, the code inside the body of if is skipped.\n</code></pre> <p><pre><code>number = 10\n# check if number is greater than 0\nif number &gt; 0:\nprint('Number is positive.')\nprint('The if statement is easy')\n</code></pre> Output <pre><code>Number is positive.\nThe if statement is easy\n</code></pre> An <code>if</code> statement can have an optional <code>else</code> clause.</p> <p>The syntax of<code>if...else</code> statement is: <pre><code>if condition:\n# block of code if condition is True\nelse:\n# block of code if condition is False\n</code></pre> The <code>if...else</code> statement is used to execute a block of code among two alternatives.</p> <p>However, if we need to make a choice between more than two alternatives, we can use the <code>if...elif...else</code> statement.</p> <p>The syntax of the if...elif...else statement is: <pre><code>if condition1:\n# code block 1\nelif condition2:\n# code block 2\nelse: \n# code block 3\n</code></pre></p> <p>We can also use an <code>if</code> statement inside of an <code>if</code> statement. This is known as a nested if statement: <pre><code>number = 5\n# outer if statement\nif number &gt; 0:\n# inner if statement\nif number &gt; 100000:\nprint('Number is very big!')    \n# inner else statement\nelse:\nprint('Number is positive')\nelif number == 0:\nprint(\"Number is zero.\")\n# outer else statement\nelse:\nprint('Number is negative')\n# Output: Number is positive\n</code></pre></p> <p>Any value can be used as an \"if-test\". The \"zero\" values all count as false: <code>None</code>, <code>0</code>, empty string,  empty list, empty dictionary. Each block of if/else statements starts with a <code>:</code> and the statements are  grouped by their indentation:</p> <pre><code>if time_hour &gt;= 0 and time_hour &lt;= 24:\nprint('Suggesting a drink option...')\nif mood == 'sleepy' and time_hour &lt; 10:\nprint('coffee')\nelif mood == 'thirsty' or time_hour &lt; 2:\nprint('lemonade')\nelse:\nprint('water')\n</code></pre>"},{"location":"programming/python/control_flow/#match-case","title":"Match case","text":"<p>Python 3.10 offers a simple and effective way to test multiple values and perform conditional  actions: the match-case statement. In case you\u2019re familiar with C++, it works similarly to the switch case.</p> <p>For our example, let\u2019s say you\u2019re building a program to check a computer\u2019s processor.  Based on the result, the program will let the gamer know if their processor is compatible  with a certain video game. Here\u2019s how our program would look:</p> <pre><code># First, ask the player about their CPU\ncpu_model = input(\"Please enter your CPU model: \")\n# The match statement evaluates the variable's value\nmatch cpu_model:\ncase \"celeron\": # We test for different values and print different messages\nprint (\"Forget about it and play Minesweeper instead...\")\ncase \"core i3\":\nprint (\"Good luck with that ;)\")\ncase \"core i5\":\nprint (\"Yeah, you should be fine.\")\ncase \"core i7\":\nprint (\"Have fun!\")\ncase \"core i9\":\nprint (\"Our team designed nice loading screens\u2026 Too bad you won't see them...\")\ncase _: # the underscore character is used as a catch-all.\nprint (\"Is that even a thing?\")\n</code></pre> <p>The above code checks a few possible values for the cpuModel variable.  If the CPU model the user enters doesn\u2019t match our expected options, the final  case statement prints an error message. Here\u2019s a possible output: <pre><code>Please enter your CPU model: core i9\nOur teams designed nice loading screens... Too bad you won't see them...\n</code></pre></p> <ul> <li>Types of programs, stages in programming and expressions.</li> <li>Using conditional statements to satisfy program specifications</li> </ul>"},{"location":"programming/python/control_flow/#strings","title":"Strings","text":"<p>Python has a built-in string class named <code>str</code> with many handy features. String literals can be  enclosed by either double or single quotes. Backslash escapes work the usual way within both  single and double quoted literals -- e.g. <code>\\n</code> <code>\\'</code> <code>\\\"</code>. A double quoted string literal can  contain single quotes without any fuss (e.g. <code>\"I didn't do it\"</code>) and likewise single quoted string  can contain double quotes. </p> <p>String literals inside triple quotes, \"\"\" or ''', can span multiple lines of text. Python strings are \"immutable\", which means they cannot be changed after they are created. Since strings can't be changed, we construct new strings as we go to represent computed values.  So for example the expression (<code>'hello'</code> + <code>'there'</code>) takes in the 2 strings <code>'hello'</code> and <code>'there'</code> and  builds a new string <code>'hellothere'</code>.</p> <p>Characters in a string can be accessed using the bracket <code>[ ]</code> syntax. </p> <p>Note</p> <p>Like other languages, Python uses zero-based indexing, so if <code>s</code> is <code>'hello'</code> <code>s[1]</code> is <code>'e'</code>.  If the index is out of bounds for the string, Python raises an error. </p> <p>The handy \"slice\" syntax (below) also works to extract any substring from a string.  The <code>len(string)</code> function returns the length of a string. The <code>[ ]</code> syntax and the <code>len()</code>  function actually work on any sequence type -- strings, lists, etc.  Python tries to make its operations work consistently across different types. </p> <p>Note</p> <p>Python newbie gotcha: don't use \"<code>len</code>\" as a variable name to avoid blocking out the <code>len()</code> function. </p> <p>The <code>+</code> operator can concatenate two strings. Notice in the code below that variables are not pre-declared --  just assign to them and go.</p> <pre><code>s = 'hi'\nprint(s[1])          ## i\nprint(len(s))        ## 2\nprint(s + ' there')  ## hi there\n</code></pre> <p>The '<code>+</code>' symbol does not automatically convert numbers or other types to string form. The <code>str()</code> function  converts values to a string form so they can be combined with other strings.</p> <pre><code>pi = 3.14\n##text = 'The value of pi is ' + pi      ## NO, does not work\ntext = 'The value of pi is '  + str(pi)  ## yes\n</code></pre> <p>A \"raw\" string literal is prefixed by an '<code>r</code>' and passes all the chars through without special treatment of  backslashes, so <code>r'x\\nx'</code> evaluates to the length-4 string <code>'x\\nx'</code>.</p> <pre><code>raw = r'this\\t\\n and that'\n# this\\t\\n and that\nprint(raw)\nmulti = \"\"\"It was the best of times.\nIt was the worst of times.\"\"\"\n# It was the best of times.\n#   It was the worst of times.\nprint(multi)\n</code></pre>"},{"location":"programming/python/control_flow/#string-methods","title":"String Methods","text":"<p>Here are some of the most common string methods. A method is like a function, but it runs  \"on\" an object. If the variable <code>s</code> is a string, then the code <code>s.lower()</code> runs the <code>lower()</code> method on  that string object and returns the result (this idea is one of the basic ideas that make up  Object Oriented Programming, OOP). Here are some of the most common string methods:</p> <pre><code>s.lower(), s.upper() -- returns the lowercase or uppercase version of the string\ns.strip() -- returns a string with whitespace removed from the start and end\ns.isalpha()/s.isdigit()/s.isspace()... -- tests if all the string chars are in the various character classes\ns.startswith('other'), s.endswith('other') -- tests if the string starts or ends with the given other string\ns.find('other') -- searches for the given other string (not a regular expression) within s, and returns the first index where it begins or -1 if not found\ns.replace('old', 'new') -- returns a string where all occurrences of 'old' have been replaced by 'new'\ns.split('delim') -- returns a list of substrings separated by the given delimiter. The delimiter is not a regular expression, it's just text. 'aaa,bbb,ccc'.split(',') -&gt; ['aaa', 'bbb', 'ccc']. As a convenient special case s.split() (with no arguments) splits on all whitespace chars.\ns.join(list) -- opposite of split(), joins the elements in the given list together using the string as the delimiter. e.g. '---'.join(['aaa', 'bbb', 'ccc']) -&gt; aaa---bbb---ccc\n</code></pre> <p>A google search for \"python str\" should lead you to the official python.org string methods which lists all the <code>str</code> methods.</p> <p>The \"slice\" syntax is a handy way to refer to sub-parts of sequences -- typically strings and lists.  The slice <code>s[start:end]</code> is the elements beginning at start and extending up to but not including end.  Suppose we have <code>s = \"Hello\"</code>:</p> <p><pre><code>s[1:4] is 'ell' -- chars starting at index 1 and extending up to but not including index 4\ns[1:] is 'ello' -- omitting either index defaults to the start or end of the string\ns[:] is 'Hello' -- omitting both always gives us a copy of the whole thing (this is the pythonic way to copy a sequence like a string or list)\ns[1:100] is 'ello' -- an index that is too big is truncated down to the string length\n</code></pre> The standard zero-based index numbers give easy access to chars near the start of the string.  As an alternative, Python uses negative numbers to give easy access to the chars at the end of  the string: <code>s[-1]</code> is the last char <code>'o'</code>, <code>s[-2]</code> is <code>'l'</code> the next-to-last char, and so on.  Negative index numbers count back from the end of the string:</p> <pre><code>s[-1] is 'o' -- last char (1st from the end)\ns[-4] is 'e' -- 4th from the end\ns[:-3] is 'He' -- going up to but not including the last 3 chars.\ns[-3:] is 'llo' -- starting with the 3rd char from the end and extending to the end of the string. \n</code></pre> <p>It is a neat thing of slices that for any index n, <code>s[:n] + s[n:] == s</code>. This works  even for n negative or out of bounds. </p> <p>One neat thing python can do is automatically convert objects into a string suitable for printing.  Two built-in ways to do this are formatted string literals, also called \"<code>f-strings</code>\", and invoking <code>str.format()</code>.</p> <p>You'll often see formatted string literals used in situations like:</p> <pre><code>value = 2.791514\nprint(f'approximate value = {value:.2f}')  # approximate value = 2.79\ncar = {'tires':4, 'doors':2}\nprint(f'car = {car}') # car = {'tires': 4, 'doors': 2}\n</code></pre> <p>A formatted literal string is prefixed with <code>'f'</code> (like the <code>'r'</code> prefix used for raw strings). Any  text outside of curly braces <code>'{}'</code> is printed out directly. Expressions contained in <code>'{}'</code> are are  printed out using the format specification described in the format spec. There are lots of neat things  you can do with the formatting including truncation and conversion to scientific notation and left/right/center alignment.</p> <p><code>f-strings</code> are very useful when you'd like to print out a table of objects and would like the columns  representing different object attributes to be aligned like</p> <pre><code>address_book = [{'name':'N.X.', 'addr':'15 Jones St', 'bonus': 70},\n{'name':'J.P.', 'addr':'1005 5th St', 'bonus': 400},\n{'name':'A.A.', 'addr':'200001 Bdwy', 'bonus': 5},]\nfor person in address_book:\nprint(f'{person[\"name\"]:8} || {person[\"addr\"]:20} || {person[\"bonus\"]:&gt;5}')\n# N.X.     || 15 Jones St          ||    70\n# J.P.     || 1005 5th St          ||   400\n# A.A.     || 200001 Bdwy          ||     5\n</code></pre> <p>Note</p> <p>We'll see about the <code>for</code> loop in the next section!</p>"},{"location":"programming/python/control_flow/#loops","title":"Loops","text":""},{"location":"programming/python/control_flow/#python-lists","title":"Python lists","text":"<p>Python has a built-in ordered list type named \"<code>list</code>\". Lists are written within square brackets <code>[ ]</code>.  Lists work similarly to strings -- use the <code>len()</code> function and square brackets <code>[ ]</code> to access data, with  the first element at index 0. (See the official python.org list docs.)</p> <pre><code>colors = ['red', 'blue', 'green']\nprint(colors[0])    # red\nprint(colors[2])    # green\nprint(len(colors))  # 3\n</code></pre> <p>Note</p> <p>You can put any sort of variable you want inside a list! Numbers, strings or other (more exotic) objects will work.</p> <p>Assignment with an <code>=</code> on lists does not make a copy. Instead, assignment makes the two variables  point to the same one list in memory.</p> <pre><code>b = colors   # Does not copy the list, just reuses it!\n</code></pre> <p>This means that if we now change <code>b</code>, we will also be changing the contents of the list <code>colors</code>. To make a different (bud identical) copy of a list, that can be modified without affecting the  original list, wee need to call the <code>copy()</code> method</p> <pre><code>b = colors.copy()   # b is now a proper copy of colors\n</code></pre> <p>The \"empty list\" is just an empty pair of brackets <code>[ ]</code>. The '<code>+</code>' works to append two lists,  so <code>[1, 2] + [3, 4]</code> yields <code>[1, 2, 3, 4]</code> (this is just like <code>+</code> with strings).</p>"},{"location":"programming/python/control_flow/#for-loop","title":"For loop","text":"<p>Python's for and in constructs are extremely useful, and the first use of them we'll see is  with lists. The <code>for</code> construct -- <code>for var in list</code> -- is an easy way to look at each element  in a list (or other collection). </p> <pre><code>squares = [1, 4, 9, 16]\nsum = 0\nfor num in squares:\nsum += num\nprint(sum)  # 30\n</code></pre> <p>Note</p> <p>Do not add or remove items from the list during iterations! It will give you plenty of headaches.</p> <p>If you know what sort of thing is in the list, use a variable name in the loop that captures that  information (such as \"num\", or \"name\", or \"url\") to improve readability. </p> <p>The in construct on its own is an easy way to test if an element appears in a list or another collection: <code>value in collection</code> tests if the value is in the collection, returning <code>True</code>/<code>False</code>.</p> <pre><code>list = ['larry', 'curly', 'moe']\nif 'curly' in list:\nprint('yay')\n</code></pre> <p>The for/in constructs are very commonly used in Python code and work on data types other than list,  so you should just memorize their syntax. You may have habits from other languages where you start  manually iterating over a collection, where in Python you should just use for/in.</p> <p>You can also use for/in to work on a string. The string acts like a list of its chars, so </p> <pre><code>for ch in s: \nprint(ch)\n</code></pre> <p>prints all the chars in a string.</p>"},{"location":"programming/python/control_flow/#range","title":"Range","text":"<p>The <code>range(n)</code> function yields the numbers 0, 1, ... n-1, and <code>range(a, b)</code> returns a, a+1, ... b-1 -- up to but  not including the last number. The combination of the for-loop and the range() function allow you to build  a traditional numeric for loop:</p> <pre><code># print the numbers from 0 through 99\nfor i in range(100):\nprint(i)\n</code></pre>"},{"location":"programming/python/control_flow/#while-loop","title":"While Loop","text":"<p>Python also has the standard while-loop. The above for/in loops solves the common case of iterating over  every element in a list, but the while loop gives you total control over the index numbers.</p> <p>Its syntaxis is quite simple:</p> <pre><code>while \"some boolean condition\":\n# block of code that gets executed in each iteration\n...\n</code></pre> <p>Here's a while loop which accesses every 3rd element in a list:</p> <pre><code># Access every 3rd element in a list\ni = 0\nwhile i &lt; len(a):\nprint(a[i])\ni = i + 3\n</code></pre> <p>As in other languages, we have the <code>break</code> and <code>continue</code> statements:</p> <ul> <li><code>break</code> finishes the while loop</li> <li><code>continue</code> moves on to the next iteration</li> </ul> <pre><code>a = [1, 2, 3, 4, 5, 6, 7, 8]\ni = 0\nwhile i &lt; len(a):\nprint(a[i])\nif i &gt; 4:\nbreak # finish while loop\nelif i == 2:\nprint(\"i is 2!\")\ni += 2\ncontinue # go back to the beginning of the while loop\ni += 1    \n</code></pre>"},{"location":"programming/python/data_structures/","title":"Data structures","text":""},{"location":"programming/python/data_structures/#data-structures_1","title":"Data structures","text":"<p>Python has some built-in data structures that are very convenient to use. </p> <ul> <li>Lists: an ordered collection of elements</li> <li>Dictionaries: a collection of elements, indexed by keys</li> <li>Sets: a collection of elements with no order, indexes or repeated elements</li> <li>Tuples: an ordered collection of elements that, unlike lists, cannot be modified</li> </ul>"},{"location":"programming/python/data_structures/#lists","title":"Lists","text":"<p>We have seen an introduction to lists in the previous loops section. We will see a few other details here:</p>"},{"location":"programming/python/data_structures/#list-methods","title":"List methods","text":"<p>Here are some common list methods.</p> <ul> <li><code>list.append(elem)</code> -- adds a single element to the end of the list. Common error: does not return the new list, just modifies the original.</li> <li><code>list.insert(index, elem)</code> -- inserts the element at the given index, shifting elements to the right.</li> <li><code>list.extend(list2)</code> adds the elements in list2 to the end of the list. Using + or += on a list is similar to using extend().</li> <li><code>list.index(elem)</code> -- searches for the given element from the start of the list and returns its index. Throws a ValueError if the element does not appear (use \"in\" to check without a ValueError).</li> <li><code>list.remove(elem)</code> -- searches for the first instance of the given element and removes it (throws ValueError if not present)</li> <li><code>list.sort()</code> -- sorts the list in place (does not return it). (The sorted() function shown later is preferred.)</li> <li><code>list.reverse()</code> -- reverses the list in place (does not return it)</li> <li><code>list.pop(index)</code> -- removes and returns the element at the given index. Returns the rightmost element if index is omitted (roughly the opposite of append()).</li> </ul> <p>Notice that these are methods on a list object, while <code>len()</code> is a function that takes the list  (or string or whatever) as an argument.</p> <pre><code>list = ['larry', 'curly', 'moe']\nlist.append('shemp')         ## append elem at end\nlist.insert(0, 'xxx')        ## insert elem at index 0\nlist.extend(['yyy', 'zzz'])  ## add list of elems at end\nprint(list)  ## ['xxx', 'larry', 'curly', 'moe', 'shemp', 'yyy', 'zzz']\nprint(list.index('curly'))    ## 2\nlist.remove('curly')         ## search and remove that element\nlist.pop(1)                  ## removes and returns 'larry'\nprint(list)  ## ['xxx', 'moe', 'shemp', 'yyy', 'zzz']\n</code></pre> <p>Note</p> <p>Common error: note that the above methods do not return the modified list, they just  modify the original list.</p> <pre><code>list = [1, 2, 3]\nprint(list.append(4))   ## NO, does not work, append() returns None\n## Correct pattern:\nlist.append(4)\nprint(list)  ## [1, 2, 3, 4]\n</code></pre>"},{"location":"programming/python/data_structures/#building-up-a-list","title":"Building up a list","text":"<p>One common pattern is to start a list as the empty list [], then use append() or extend() to add elements to it:</p> <pre><code>list = []          ## Start as the empty list\nlist.append('a')   ## Use append() to add elements\nlist.append('b')\n</code></pre>"},{"location":"programming/python/data_structures/#list-slices","title":"List Slices","text":"<p>Slices work on lists just as with strings, and can also be used to change sub-parts of the list.</p> <pre><code>list = ['a', 'b', 'c', 'd']\nprint(list[1:-1])   ## ['b', 'c']\nlist[0:2] = 'z'    ## replace ['a', 'b'] with ['z']\nprint(list)         ## ['z', 'c', 'd']\n</code></pre>"},{"location":"programming/python/data_structures/#dictionaries","title":"Dictionaries","text":"<p>Python provides another composite data type called a dictionary, which is similar to a list in that it is a  collection of objects.</p> <p>Dictionaries and lists share the following characteristics:</p> <ul> <li>Both are mutable.</li> <li>Both are dynamic. They can grow and shrink as needed.</li> <li>Both can be nested. A list can contain another list. A dictionary can contain another dictionary.  A dictionary can also contain a list, and vice versa.</li> </ul> <p>Dictionaries differ from lists primarily in how elements are accessed:</p> <ul> <li>List elements are accessed by their position in the list, via indexing. </li> <li>Dictionary elements are accessed via keys.</li> </ul> <p>Defining a Dictionary</p> <p>A dictionary consists of a collection of key-value pairs. Each key-value pair maps the key to its associated value. You can define a dictionary by enclosing a comma-separated list of key-value pairs in curly braces (<code>{}</code>). A colon  (<code>:</code>) separates each key from its associated value:</p> <p><pre><code>d = {\n&lt;key&gt;: &lt;value&gt;,\n&lt;key&gt;: &lt;value&gt;,\n.\n.\n.\n&lt;key&gt;: &lt;value&gt;\n}\n</code></pre> For example: <pre><code>football_teams = {\n\"bilbao\": \"athletic\",\n\"barcelona\": \"bar\u00e7a\",\n\"madrid\": \"real madrid\",\n\"munich\": \"bayern\",\n\"paris\": \"psg\"\n}\n</code></pre></p> <p>Of course, dictionary elements must be accessible somehow. If you don\u2019t get them by index, then how do you get them? A value is retrieved from a dictionary by specifying its corresponding key in square brackets (<code>[]</code>):</p> <p><pre><code>&gt;&gt;&gt; football_teams['bilbao']\n'athletic'\n&gt;&gt;&gt; football_teams['paris']\n'psg'\n</code></pre> If you refer to a key that is not in the dictionary, Python raises an exception: <pre><code>&gt;&gt;&gt; football_teams['toronto']\nKeyError: 'Toronto'\n</code></pre></p> <p>Defining a dictionary using curly braces and a list of key-value pairs, as shown above, is fine  if you know all the keys and values in advance. But what if you want to build a dictionary on the fly?</p> <p>You can start by creating an empty dictionary, which is specified by empty curly braces. Then you can  add new keys and values one at a time:</p> <pre><code>&gt;&gt;&gt; person = {}\n&gt;&gt;&gt; type(person)\n&lt;class 'dict'&gt;\nperson['fname'] = 'Joe'\nperson['lname'] = 'Fonebone'\nperson['age'] = 51\nperson['spouse'] = 'Edna'\nperson['children'] = ['Ralph', 'Betty', 'Joey']\nperson['pets'] = {'dog': 'Fido', 'cat': 'Sox'}\n</code></pre> <p>Note</p> <p>In dictionaries, a given key can appear in only once.  Duplicate keys are not allowed. A dictionary maps each key to a corresponding value,  so it doesn\u2019t make sense to map a particular key more than once. </p>"},{"location":"programming/python/data_structures/#iterating-over-dictionaries","title":"Iterating over dictionaries","text":"<p>When you\u2019re working with dictionaries, it\u2019s likely that you\u2019ll want to work with both the keys  and the values. One of the most useful ways to iterate through a dictionary in Python is by  using <code>.items()</code>, which is a method that returns a new view of the dictionary\u2019s items:</p> <pre><code>&gt;&gt;&gt; a_dict = {'color': 'blue', 'fruit': 'apple', 'pet': 'dog'}\n&gt;&gt;&gt; d_items = a_dict.items()\n&gt;&gt;&gt; d_items  # Here d_items is a view of items\ndict_items([('color', 'blue'), ('fruit', 'apple'), ('pet', 'dog')])\n</code></pre> <p>To iterate through the keys and values of the dictionary, we will just need to \"unpack\" the elements of  the dict like so:</p> <pre><code>for key, value in a_dict.items():\nprint(key, '-&gt;', value)\n# Output\ncolor -&gt; blue\nfruit -&gt; apple\npet -&gt; dog\n</code></pre>"},{"location":"programming/python/data_structures/#dict-important-methods","title":"Dict important methods","text":"<ul> <li><code>clear()</code> Removes all the elements from the dictionary</li> <li><code>copy()</code>  Returns a copy of the dictionary</li> <li><code>fromkeys()</code>  Returns a dictionary with the specified keys and value</li> <li><code>get()</code>   Returns the value of the specified key</li> <li><code>items()</code> Returns a list containing a tuple for each key value pair</li> <li><code>keys()</code>  Returns a list containing the dictionary's keys</li> <li><code>pop()</code>   Removes the element with the specified key</li> <li><code>popitem()</code>   Removes the last inserted key-value pair</li> <li><code>setdefault()</code>    Returns the value of the specified key. If the key does not exist: insert the key, with the specified value</li> <li><code>update()</code>    Updates the dictionary with the specified key-value pairs</li> <li><code>values()</code>    Returns a list of all the values in the dictionary</li> </ul>"},{"location":"programming/python/data_structures/#sets-and-tuples","title":"Sets and tuples","text":"<p>Sets and tuples are the last of Python main data structures. </p> <p>In Python, we create sets by placing all the elements inside curly braces {}, separated by comma.</p> <p>A set can have any number of items and they may be of different types (integer, float, tuple, string etc.).  But a set cannot have mutable elements like lists, sets or dictionaries as its elements.</p> <pre><code># create a set of integer type\nstudent_id = {112, 114, 116, 118, 115}\nprint('Student ID:', student_id)\n# create a set of string type\nvowel_letters = {'a', 'e', 'i', 'o', 'u'}\nprint('Vowel Letters:', vowel_letters)\n# create a set of mixed data types\nmixed_set = {'Hello', 101, -2, 'Bye'}\nprint('Set of mixed data types:', mixed_set)\n# Output\nStudent ID: {112, 114, 115, 116, 118}\nVowel Letters: {'u', 'a', 'e', 'i', 'o'}\nSet of mixed data types: {'Hello', 'Bye', 101, -2}\n</code></pre> <p>Sets cannot have duplicate elements. Let's see what will happen if we try to include duplicate items in a set: <pre><code>numbers = {2, 4, 6, 6, 2, 8}\nprint(numbers)   \n# Output\n{8, 2, 4, 6}\n</code></pre></p> <p>A tuple is created by placing all the items (elements) inside parentheses (), separated by commas.  A tuple can have any number of items and they may be of different types (integer, float, list, string, etc.).</p> <pre><code># Different types of tuples\n# Empty tuple\nmy_tuple = ()\nprint(my_tuple)\n# Tuple having integers\nmy_tuple = (1, 2, 3)\nprint(my_tuple)\n# tuple with mixed datatypes\nmy_tuple = (1, \"Hello\", 3.4)\nprint(my_tuple)\n# nested tuple\nmy_tuple = (\"mouse\", [8, 4, 6], (1, 2, 3))\nprint(my_tuple)\n# Output\n()\n(1, 2, 3)\n(1, 'Hello', 3.4)\n('mouse', [8, 4, 6], (1, 2, 3))\n</code></pre> <p>Note</p> <p>When defining a tuple, parentheses are optional (although it is good practice to use them)</p> <p>Like lists, tuples allow slicing and indexing. However, unlike lists, tuples are immutable: once  defined, they cannot be changed.</p>"},{"location":"programming/python/exceptions/","title":"Exceptions","text":""},{"location":"programming/python/exceptions/#basic-exception-handling","title":"Basic exception handling","text":"<p>Exceptions are a way to keep Python errors under control, once a program is running.  Exceptions errors arise when correct Python programs (i.e., syntactically correct code) produce an error.</p> <p>Python creates an exception object whenever such errors occur. When we write code that deals with the  exception, our programs will continue running, even if an error is thrown. If we don't, then our programs will  stop executing and show a trace-back, which is sometimes hard for a user to understand.</p>"},{"location":"programming/python/exceptions/#example-1","title":"Example 1","text":"<p>Let's run a program that divides a number by zero. We know (or we should) that you cannot divide by zero, but let\u2019s see what Python does: <pre><code>print(6/0)\n</code></pre> When we run the above code, Python gives the following traceback:</p> <p><pre><code>Traceback (most recent call last):\n  File \u201cC:\\Users\\ADMIN\\PycharmProject\\pythonProject\\main.py\u201d, line 1, in &lt;module&gt;\n print(6/0)\nZeroDivisionError: division by zero\n</code></pre> Since Python cannot divide a number by zero, it reports an error in the trace-back as <code>ZeroDivisionError</code>,  which is an exception object, and then the execution stops.  This kind of object responds to a scenario where Python can't do what we asked it to.</p> <p>Note</p> <p>There are many different types of exceptions in Python. You will probably find some of them soon, if you haven't yet. You can even define your own exceptions.</p> <p>If you think an error might occur in your code, use the try-except block to control the exception  that may be raised.</p> <p>To handle the <code>ZeroDivisionError</code> exception, use a try-except block like this:</p> <p><pre><code>try:\nprint(6/0)\nexcept ZeroDivisionError:\nprint(\"You can\u2019t divide by zero!\") # You can\u2019t divide by zero!\n</code></pre> When you runt it, you will see the following output: <pre><code>You can\u2019t divide by zero!\n</code></pre></p>"},{"location":"programming/python/exceptions/#example-2","title":"Example 2","text":"<p>Errors arise often when working with files that are missing. Python may fail to retrieve a file, if  you have written the wrong spelling of the filename, or the file does not exist.</p> <p>We handle this situation like before: by making use of the try-except block. For example, imagine the program  below tries to read a file that doesn't exist on your computer:</p> <pre><code>filename = 'some_nonexistent_file.txt'\nwith open(filename) as file:\ncontents = file.read()\n</code></pre> <p>Since Python cannot read a file that does not exist, it raises an exception:</p> <pre><code>Traceback (most recent call last):\n  File \u201cC:\\Users\\ADMIN\\PycharmProject\\pythonProject\\main.py\u201d, line 2, in &lt;module&gt;\n with open(filename) as f_obj:\nFileNotFoundError: [Errno 2] No such file or directory: \u2018some_nonexistent_file.txt\u2019\n</code></pre> <p>This is the <code>FileNotFoundError</code> exception. In this example, the <code>open()</code> function creates the error.  To solve this error, use the try block just before the line, which involves the <code>open()</code> function:</p> <pre><code>filename = 'some_nonexistent_file.txt'\ntry:\nwith open(filename) as f_obj:\ncontents = f_obj.read()\nexcept FileNotFoundError:\nmsg = \"Sorry, the file \"+ filename + \"does not exist.\"\nprint(msg) # Sorry, the file some_nonexistent_file.txt does not exist.\n</code></pre> <p>Now the code works correctly. This is known as catching the exception.</p>"},{"location":"programming/python/exceptions/#try-except-structure","title":"Try-except structure","text":"<p>The full exception handling in Python has this structure:</p> <pre><code>try:\n# Some Code.... \nexcept:\n# optional block\n# Handling of exception (if required)\nelse:\n# execute if no exception\nfinally:\n# Some code .....(always executed)\n</code></pre> <p>Note</p> <p>Note that in the try-except block above we didn't specify what exception we are  catching. It is not mandatory to do so, but it is very good practice to do it always. Otherwise, we could be having a different error in the code (that we have not foreseen) and we wouldn't notice!</p> <p>However, in practice we often only use it like this: <pre><code>try:\n# some code\nexcept SomeException:\n# what to do when the exception is raised\n</code></pre></p>"},{"location":"programming/python/exceptions/#how-to-manually-raise-an-exception-in-python","title":"How to manually raise an exception in Python","text":"<p>How do we raise an exception in Python so that it can later be caught via an except block? We should always use the most specific Exception constructor that semantically fits your issue.</p> <p>Some common rules:</p> <ul> <li>Be specific in your message, e.g.:     <pre><code>raise ValueError('A very specific bad thing happened.')\n</code></pre></li> <li>Don't raise generic exceptions: avoid raising a generic Exception. To catch it, you'll have to  catch all other more specific exceptions that subclass it.</li> </ul>"},{"location":"programming/python/functions/","title":"Functions","text":""},{"location":"programming/python/functions/#functions_1","title":"Functions","text":""},{"location":"programming/python/functions/#introduction","title":"Introduction","text":"<p>You may be familiar with the mathematical concept of a function. A function is a relationship or  mapping between one or more inputs and a set of outputs. In mathematics, a function is typically represented like</p> \\[\\begin{align} z = f(x,y) \\end{align}\\] <p>Here, \\(f\\) is a function that operates on the inputs \\(x\\) and \\(y\\). The output of the function is \\(z\\).  However, programming functions are much more generalized and versatile than this mathematical definition.  In fact, appropriate function definition and use is so critical to proper software development that virtually  all modern programming languages support both built-in and user-defined functions.</p> <p>In programming, a function is a self-contained block of code that encapsulates a specific task or related group  of tasks. We have already seen some of the built-in functions provided by Python: <code>print()</code>, <code>type()</code> or <code>len()</code>.  For example, <code>len()</code> returns the length of the argument passed to it:</p> <pre><code>&gt;&gt;&gt; a = ['foo', 'bar', 'baz', 'qux']\n&gt;&gt;&gt; len(a)\n4\n</code></pre> <p>These functions are part of the Python Standard Library, a collection of modules accessible to Python programs that require no installation of external code. The Python standard library can be used to  simplify the programming process, removing the need to reinvent the wheel and rewrite commonly used commands.</p> <p>Most functions from the standard library can be used by calling <code>import package_name</code> at the beginning of a script, where <code>package_name</code> is the name of the precise library that we want to use. We'll see a couple of important  Python modules in the next sections.</p> <p>Note</p> <p>Not all functions need to be imported to be used. <code>print()</code>, <code>type()</code> or <code>len()</code> are so general that we can use them without the need to import anything.</p>"},{"location":"programming/python/functions/#the-math-library","title":"The math library","text":"<p>For straightforward mathematical calculations in Python, you can use the built-in mathematical operators,  such as addition (<code>+</code>), subtraction (<code>-</code>), division (<code>/</code>), and multiplication (<code>*</code>). But more advanced operations,  such as exponential, logarithmic, trigonometric, or power functions, are not built in. Does that mean you need  to implement all of these functions from scratch? </p> <p>Fortunately, no. Python provides a module specifically designed for higher-level mathematical operations: the math  module. The math module comes packaged with the Python release, so you don\u2019t have to install it separately.  Using it is just a matter of importing the module:</p> <p><pre><code>&gt;&gt;&gt; import math\n</code></pre> You can import the Python math module using the above command. After importing, you can use it straightaway. For instance, imagine that we want to use the cosine function, \\(f(x) = \\cos(x)\\). Then we would do</p> <p><pre><code>x = 3.14\ny = math.cos(y)\n</code></pre> and similarly for all other functions and parameters of the math module. </p> <p>Note</p> <p>If we don't want to write <code>math.XXX</code> in front of every import of the math module, we can also just import the specific parts of the module that we need, as in</p> <pre><code>from math import cos\nx = 3.14\ny = cos(y)\n</code></pre>"},{"location":"programming/python/functions/#numbers-math-functions","title":"Numbers, math functions","text":"<p>The math module provides many functions and important \"named\" numbers. This is a list of some of the most important:</p> <ul> <li><code>ceil(x)</code>: returns the smallest integer greater than or equal to x.</li> <li><code>trunc(x)</code>: returns the truncated integer value of x.</li> <li><code>factorial(x)</code>: returns the factorial of x</li> <li><code>pow(x, y)</code>: returns x raised to the power y</li> <li><code>cos(x)</code>, <code>sin(y)</code>, <code>tan(y)</code>: trigonometric functions</li> <li><code>pi</code>: mathematical constant 3.1415...</li> <li><code>e</code>: mathematical constant 2.7182...</li> </ul>"},{"location":"programming/python/functions/#random-numbers","title":"Random numbers","text":"<p>Python provides the <code>random</code> module to generate random numbers. This is also a built-in module that requires no installation. <code>random</code> provides a number of useful tools for generating what we call pseudo-random data.</p> <p>Note</p> <p>Disclaimer: most random data generated with Python is not fully random in the scientific sense of the word.  Rather, it is pseudorandom: generated with a pseudorandom number generator (PRNG), which is essentially any  algorithm for generating seemingly random but still reproducible data.</p>"},{"location":"programming/python/functions/#random-floats","title":"Random floats","text":"<p>The <code>random.random()</code> function returns a random float in the interval \\([0.0, 1.0)\\):</p> <pre><code>&gt;&gt;&gt; # Don't call `random.seed()` yet\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.random()\n0.35553263284394376\n&gt;&gt;&gt; random.random()\n0.6101992345575074\n</code></pre> <p>If you run this code yourself, the numbers returned on your machine will be different.  The default when you don\u2019t seed the generator is to use your current system time or a \u201crandomness source\u201d from  your OS if one is available.</p> <p>With <code>random.seed()</code>, you can make results reproducible, and the chain of calls after <code>random.seed()</code> will  produce the same trail of data:</p> <pre><code>&gt;&gt;&gt; random.seed(444)\n&gt;&gt;&gt; random.random()\n0.3088946587429545\n&gt;&gt;&gt; random.random()\n0.01323751590501987\n&gt;&gt;&gt; random.seed(444)  # Re-seed\n&gt;&gt;&gt; random.random()\n0.3088946587429545\n&gt;&gt;&gt; random.random()\n0.01323751590501987\n</code></pre>"},{"location":"programming/python/functions/#random-integers","title":"Random integers","text":"<p>You can generate a random integer between two endpoints in Python with the <code>random.randint()</code> function. This spans  the full \\([x, y]\\) interval and may include both endpoints:</p> <pre><code>&gt;&gt;&gt; random.randint(0, 10)\n7\n&gt;&gt;&gt; random.randint(500, 50000)\n18601\n</code></pre> <p>Note</p> <p>If we wanted to simulate a dice, we could run <code>random.randint(1, 6)</code>.</p>"},{"location":"programming/python/functions/#custom-function-definitions","title":"Custom function definitions","text":"<p>If no function from an already existing package fits our needs, we can always define our own  custom function.</p> <p>When you define your own Python function, it works just the same as with built-in functions.  From somewhere in your code, you\u2019ll call your Python function and program execution will  transfer to the body of code that makes up the function.</p> <p>Note</p> <p>Functions are really really important in programming, since they allow code reusability.</p> <p>When the function is finished, execution returns to the location where the function was called.  Depending on how you designed the function\u2019s interface, data may be passed in when the function is called,  and return values may be passed back when it finishes.</p> <p>The usual syntax for defining a Python function is as follows:</p> <pre><code>def &lt;function_name&gt;([&lt;arguments&gt;]):\n\"\"\"Docstring.\"\"\"\n&lt;statement(s)&gt;\n</code></pre> <p>where the components are:</p> <ul> <li><code>def</code>: the keyword that informs Python that a function is being defined</li> <li><code>&lt;function_name&gt;</code>: A valid Python identifier that names the function</li> <li><code>&lt;arguments&gt;</code>: An optional, comma-separated list of parameters that may be passed to the function</li> <li><code>Docstring</code>: information on how the function works, what it does, its arguments and return types.</li> <li><code>:</code>: Punctuation that denotes the end of the Python function header (the name and parameter list)</li> <li><code>&lt;statement(s)&gt;</code>: A block of valid Python code that does something with the passed parameters</li> </ul> <p>Here\u2019s an example that defines and calls f(): <pre><code>def f():    \ns = '-- Inside f()'    \nprint(s)\nprint('Before calling f()')\nf()\nprint('After calling f()')\n</code></pre></p> <p>Here\u2019s how this code works:</p> <ul> <li> <p>Line 1 uses the def keyword to indicate that a function is being defined. Execution of the def    statement merely creates the definition of <code>f()</code>. All the following lines that are indented (lines 2 to 3)    become part of the body of <code>f()</code> and are stored as its definition, but they aren\u2019t executed yet.</p> </li> <li> <p>Line 4 is a bit of whitespace between the function definition and the first line of the main program.    While it isn\u2019t syntactically necessary, it is nice to have. </p> </li> <li> <p>Line 5 is the first statement that isn\u2019t indented because it isn\u2019t a part of the definition of <code>f()</code>.    It\u2019s the start of the main program. When the main program executes, this statement is executed first.</p> </li> <li> <p>Line 6 is a call to <code>f()</code>. Note that empty parentheses are always required in both a function definition    and a function call, even when there are no parameters or arguments. Execution proceeds to <code>f()</code> and the statements    in the body of <code>f()</code> are executed.</p> </li> <li> <p>Line 7 is the next line to execute once the body of <code>f()</code> has finished. Execution returns to this <code>print()</code> statement.</p> </li> </ul>"},{"location":"programming/python/functions/#return-statement","title":"Return statement","text":"<p>To use a function, first you need to call it. As we have seen, a function call consists of the function's name  followed by the function\u2019s arguments in parentheses:</p> <pre><code>function_name(arg1, arg2, ..., argN)\n</code></pre> <p>You\u2019ll need to pass arguments to a function call only if the function requires them. The parentheses, on the other  hand, are always required in a function call. If you forget them, then you won\u2019t be calling the function but  referencing it as a function object.</p> <p>But, how do we make the function return a value? For that we need to use the Python <code>return</code> statement. </p> <pre><code>def mean(sample):\nreturn sum(sample) / len(sample)\n</code></pre> <p>we can also return more than one value if we put the results in a list, tuple or dictionary:</p> <pre><code>def sum_and_diff(var1, var2):\nreturn var1 + var2, var1 - var2\n</code></pre>"},{"location":"programming/python/functions/#definition-arguments-and-type-annotations","title":"Definition, arguments and type annotations","text":"<p>Consider the following function definition:</p> <p><pre><code>def duplicate(msg):\n\"\"\"Returns a string containing two copies of `msg`\"\"\"\nreturn msg + msg\n</code></pre> The argument of the function is the parameter <code>msg</code>: this function is intended to duplicate the passed message. For example, if called with the value <code>\"Hello\"</code>, it returns the value <code>\"HelloHello\"</code>. If called with other types of  data, however, it will not work as expected. </p> <p>Note</p> <p>What will the function do if given an <code>int</code> or a <code>float</code> value?</p> <p>Python allows you to indicate the intended type of the function parameters and the type of the function  return value in a function definition using a special notation demonstrated in this example:</p> <p><pre><code>def duplicate(msg: str) -&gt; str:\n\"\"\"Returns a string containing two copies of `msg`\"\"\"\nreturn msg + msg\nresult = duplicate('Hello')\nprint(result)\n</code></pre> This definition of <code>duplicate</code> makes use of type annotations that indicate the function\u2019s parameter type  and return type (the return type is what comes after the <code>-&gt;</code>). A type annotation, sometimes called a type hint,  is an optional notation that specifies the type of a parameter or function result.  It tells the programmer using the function what kind of data to  pass to the function, and what kind of data to expect when the function returns a value.</p> <p>Note</p> <p>It\u2019s important to understand that adding type annotations to a function definition does not cause the  Python interpreter to check that the values passed to a function are the expected types, or cause the  returned value to be converted to the expected type! This is only an indication for the programmer and, if you are using one, for the IDE.</p> <p>For example, consider the following function:</p> <p><pre><code>def add(x: int, y: int) -&gt; int:\n\"\"\"Returns the sum of `x` and `y`\"\"\"\nreturn x + y\n</code></pre> If the function <code>add</code> in the example above is called like this: <pre><code>result = add('5', '15')\n</code></pre> the function will receive two string values, concatenate them, and return the resulting string <code>\"515\"</code>.  The <code>int</code> annotations are completely ignored by the Python interpreter. </p> <p>Note</p> <p>You should always try to use type annotations! Code looks much better with them, and it is easier to understand.</p>"},{"location":"programming/python/functions/#mutability-and-arguments","title":"Mutability and arguments","text":"<p>In Python, arguments of functions can be of two types: immutable (<code>int</code>, <code>float</code>, <code>str</code>, <code>tuples</code>...) or mutable (mostly <code>lst</code> and <code>dict</code>). </p> <p>If you pass a mutable object into a function, the function gets a reference to that same object: this means that the function can modify the value of the outer variable. However, with immutable objects, the rest of the script will remain unchanged. </p> <p>Example of a function that modifies a list:</p> <pre><code>def try_to_change_list_contents(the_list):\nprint('got', the_list)\nthe_list.append('four')\nprint('changed to', the_list)\nouter_list = ['one', 'two', 'three']\nprint('before, outer_list =', outer_list)\ntry_to_change_list_contents(outer_list)\nprint('after, outer_list =', outer_list)\n# Output:\nbefore, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n</code></pre> <p>Example of a function not modifying a string:</p> <pre><code>def try_to_change_string_reference(the_string):\nprint('got', the_string)\nthe_string = 'In a kingdom by the sea'\nprint('set to', the_string)\nouter_string = 'It was many and many a year ago'\nprint('before, outer_string =', outer_string)\ntry_to_change_string_reference(outer_string)\nprint('after, outer_string =', outer_string)\n# Output:\nbefore, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n</code></pre>"},{"location":"programming/python/functions/#lambda-functions","title":"Lambda functions","text":"<p>Lambda functions are small anonymous functions. They work as normal python functions, but are defined within a single line and a little bit differently, as:</p> <pre><code>lambda arguments : expression \n</code></pre> <p>A lambda function can take any number of arguments, but can only have one expression. For instance, a function that adds 10 to an argument a, and returns the result would be written as:</p> <pre><code>x = lambda a : a + 10\nprint(x(5)) \n</code></pre>"},{"location":"programming/python/io_files/","title":"Input, output and files","text":""},{"location":"programming/python/io_files/#text-files","title":"Text files","text":""},{"location":"programming/python/io_files/#introduction","title":"Introduction","text":"<p>One of the most common tasks that you can do with Python is reading and writing files.  Whether it\u2019s writing to a simple text file, reading a complicated server log, or even analyzing raw  byte data, all of these situations require reading or writing a file.</p> <p>Before we can go into how to work with files in Python, it\u2019s important to understand what exactly a  file is and how modern operating systems handle some of their aspects.</p> <p>At its core, a file is a contiguous set of bytes used to store data. This data is organized  in a specific format and can be anything as simple as a text file or as complicated as a  program executable. In the end, these byte files are then translated into binary 1 and 0 for  easier processing by the computer.</p> <p>Files on most modern file systems are composed of three main parts:</p> <ul> <li>Header: metadata about the contents of the file (file name, size, type, and so on)</li> <li>Data: contents of the file as written by the creator or editor</li> <li>End of file (EOF): special character that indicates the end of the file</li> </ul> <p>What this data represents depends on the format specification used, which is typically represented by an extension.</p>"},{"location":"programming/python/io_files/#file-paths","title":"File paths","text":"<p>When you access a file on an operating system, a file path is required. The file path is a string  that represents the location of a file. It\u2019s broken up into three major parts:</p> <ul> <li>Folder Path: the file folder location on the file system where subsequent folders are separated    by a forward slash / (Unix) or backslash \\ (Windows)</li> <li>File Name: the actual name of the file</li> <li>Extension: the end of the file path pre-pended with a period (.) used to indicate the file type</li> </ul> <p>Here\u2019s a quick example. Let\u2019s say you have a file located within a file structure like this:</p> <pre><code>/\n\u2502\n\u251c\u2500\u2500 path/\n|   \u2502\n\u2502   \u251c\u2500\u2500 to/\n\u2502   \u2502   \u2514\u2500\u2500 cats.gif\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 dog_breeds.txt\n|\n\u2514\u2500\u2500 animals.csv\n</code></pre> <p>Let\u2019s say you wanted to access the cats.gif file, and your current location was in the same folder as path.  In order to access the file, you need to go through the path folder and then the to folder, finally  arriving at the <code>cats.gif</code> file. The Folder Path is <code>path/to/</code>. The File Name is cats. The File  Extension is <code>.gif</code>. So the full path is <code>path/to/cats.gif</code>.</p>"},{"location":"programming/python/io_files/#opening-and-closing-a-file-in-python","title":"Opening and Closing a File in Python","text":"<p>When you want to work with a file, the first thing to do is to open it. This is done by invoking  the <code>open()</code> built-in function. <code>open()</code> has a single required argument that is the path to the file.  <code>open()</code> has a single return, the file object. Once we are done with the file, we need to close it:</p> <pre><code>file = open('dog_breeds.txt')\n# do something with file\nfile.close()\n</code></pre> <p>It\u2019s important to remember that it\u2019s your responsibility to close the file! This is why it's always recommended to use the <code>with</code> statement when dealing with files:</p> <pre><code>with open('dog_breeds.txt') as reader:\n# Further file processing goes here\n...\n</code></pre> <p>When the <code>with</code> statement is finished, everything goes back to normal (and we don't need to remember to close anything). </p> <p>When opening a file, we are (directly or indirectly) using one of the different modes provided by Python. The most commonly used modes are the following:</p> <ul> <li><code>r</code>: Open for reading (default mode if nothing is specified)</li> <li><code>w</code>: Open for writing, truncating (overwriting) the file first</li> <li><code>a</code>: Open for writing, appending to the end of the file</li> <li><code>rb</code> or <code>wb</code>: Open in binary mode (read/write using byte data)</li> </ul> <p>Reading example:</p> <pre><code>with open('dog_breeds.txt', 'r') as file:\n# Option 1: Read entire file all at once\nmy_str = file.read()\n# Option 2: read line by line\nstr_list = []\nfor line in file:\nstr_list.append(line)\n</code></pre> <p>Writing example: <pre><code>with open('dog_breeds_reversed.txt', 'w') as file:\n# Write the dog breeds to the file in reversed order\nfor line in reversed(file):\nfile.write(line)\n</code></pre></p> <p>Appending to end of a file example: <pre><code>with open(\"test.txt\", \"a\") as file:\nfile.write(\"appended text\")\n</code></pre></p> <p>Note</p> <p>To read a binary file, in contrast to a text file, we would use <code>open(\"filename\", \"b\")</code></p>"},{"location":"programming/python/io_files/#reading-and-writing-json-files","title":"Reading and writing JSON files","text":"<p>JSON is an open standard file format and data interchange format that uses human-readable text  to store and transmit data objects, consisting of attribute\u2013value pairs and arrays (or other serializable values).  It is a common data exchange format on the internet, including that of web applications with servers. An  example JSON file looks like this:</p> <pre><code>{\n\"first_name\": \"John\",\n\"last_name\": \"Smith\",\n\"is_alive\": true,\n\"age\": 27,\n\"address\": {\n\"street_address\": \"21 2nd Street\",\n\"city\": \"New York\",\n\"state\": \"NY\",\n\"postal_code\": \"10021-3100\"\n},\n\"phone_numbers\": [\n{\n\"type\": \"home\",\n\"number\": \"212 555-1234\"\n},\n{\n\"type\": \"office\",\n\"number\": \"646 555-4567\"\n}\n],\n\"children\": [\n\"Catherine\",\n\"Thomas\",\n\"Trevor\"\n],\n\"spouse\": null\n}\n</code></pre>"},{"location":"programming/python/io_files/#json-file-to-python","title":"JSON file to Python","text":"<p>To load (read) the data from a <code>.json</code> file, we use the following code structure:</p> <p><pre><code>import json\nwith open(\"strings.json\", \"r\") as file:\nd = json.load(file)\nprint(d)\n</code></pre> In this example, the <code>strings.json</code> file is loaded into a variable <code>d</code> of type <code>dict</code>. If, on the contrary, we want to write a new JSON file from a dictionary variable we already have, we would use: <pre><code>import json\nmy_dict = ...\nwith open(\"out_file.json\", \"w\") as file:\njson.dump(my_dict, file)\n</code></pre> Bear in mind, however, that the structure of a JSON file is included on its use of curly brackets, in contrast to YAML files or Python code, that use indentation for that. Hence, the <code>out_file.json</code> (from the last example) will not be pretty to look at. If we want to force the use of indentation, we can add the optional parameter <code>indent</code> like so: <pre><code>import json\nmy_dict = ...\nwith open(\"out_file.json\", \"w\") as file:\njson.dump(my_dict, file, indent=4)\n</code></pre></p> <p>Note</p> <p>The <code>json</code> package is included with the standard Python installation, we don't need to install it.</p>"},{"location":"programming/python/io_files/#json-string-to-python","title":"JSON string to Python","text":"<p>The <code>json</code> package also has functions to serialize a Python object into a JSON string, and also to perform the inverse operation and deserialize a JSON string into a Python dictionary:</p> <ul> <li>Dictionary to JSON string:     <pre><code>import json \n# Data to be written \ndictionary ={ \n\"id\": \"04\", \n\"name\": \"sunil\", \n\"department\": \"HR\"\n} \n# Serializing json  \njson_object = json.dumps(dictionary, indent=4) \nprint(json_object)\n# Output\n{\n\"department\": \"HR\",\n\"id\": \"04\",\n\"name\": \"sunil\"\n}    \n</code></pre></li> <li>JSON string to dictionary:     <pre><code>import json\ndata = \"\"\"\n    {  \n    \"Name\": \"Jennifer Smith\",  \n    \"Contact Number\": 7867567898,  \n    \"Email\": \"jen123@gmail.com\",  \n    \"Hobbies\":[\"Reading\", \"Sketching\", \"Horse Riding\"]  \n    }\n\"\"\"\n# parse data:  \nres = json.loads(data)  \n</code></pre></li> </ul>"},{"location":"programming/python/python_introduction/","title":"Introduction to Python","text":""},{"location":"programming/python/python_introduction/#language-introduction","title":"Language Introduction","text":"<p>Python is an interpreted language. It uses variables to store information:  whether information is a number, text or a list of names, it will always be saved in a variable.  Information in variables can later be processed, or kept as is. </p> <p>When we declare variables in Python, we are not forced to tell the interpreter of what sort they  will be; Python will infer it at runtime. This gives the programmer some flexibility, but also  the possibility of making mistakes.</p> <p>An excellent way to see how Python code works is to run the Python interpreter and type code  right into it. If you ever have a question like, \"What happens if I do this or that?\" just  typing it into the Python interpreter is a fast and likely the best way to see what happens. </p> <pre><code>$ python3        ## Run the Python interpreter\nPython 3.X.X (XXX, XXX XX XXXX, XX:XX:XX) [XXX] on XXX\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; a = 6       ## set a variable in this interpreter session\n&gt;&gt;&gt; a           ## entering an expression prints its value\n6\n&gt;&gt;&gt; a + 2\n8\n&gt;&gt;&gt; a = 'hi'    ## 'a' can hold a string just as well\n&gt;&gt;&gt; a\n'hi'\n&gt;&gt;&gt; len(a)      ## call the len() function on a string\n2\n&gt;&gt;&gt; a + len(a)  ## try something that doesn't work\nTraceback (most recent call last):\nFile \"\", line 1, in \nTypeError: can only concatenate str (not \"int\") to str\n&gt;&gt;&gt; a + str(len(a))  ## probably what you really wanted\n'hi2'\n&gt;&gt;&gt; foo         ## try something else that doesn't work\nTraceback (most recent call last):\nFile \"\", line 1, in \nNameError: name 'foo' is not defined\n&gt;&gt;&gt; ^D          ## type CTRL-d to exit (CTRL-z in Windows/DOS terminal)\n</code></pre> <p>Note</p> <p>If you don't understand everything that is happening in the previous code snippet,  don't worry! We'll see it on the next sessions.</p> <p>As you can see above, it's easy to experiment with variables and operators.  Also, the interpreter throws, or \"raises\" in Python parlance, a runtime error if the  code tries to read a variable that has not been assigned a value. Like other programming languages,  Python is case sensitive so \"<code>a</code>\" and \"<code>A</code>\" are different variables. The end of a line marks the end  of a statement, so Python does not require a semicolon at the end of each statement.  Comments begin with a <code>#</code> and extend to the end of the line.</p>"},{"location":"programming/python/python_introduction/#basic-variables-and-types","title":"Basic variables and types","text":""},{"location":"programming/python/python_introduction/#numbers","title":"Numbers","text":"<p>The interpreter acts as a simple calculator: you can type an expression at it and it will write the value.  Expression syntax is straightforward: the operators +, -, * and / can be used to perform arithmetic;  parentheses (()) can be used for grouping. For example:</p> <pre><code>&gt;&gt;&gt;\n2 + 2\n4\n50 - 5*6\n20\n(50 - 5*6) / 4\n5.0\n8 / 5  # division always returns a floating point number\n1.6\n</code></pre> <p>The integer numbers (e.g. 2, 4, 20) have type <code>int</code>, the ones with a fractional part  (e.g. 5.0, 1.6) have type <code>float</code>. Finally, boolean numbers have type <code>bool</code> and represent logical values of <code>True</code> or <code>False</code>.</p> <p>Note</p> <p>Booleans can't be operated as normal numbers, with additions or powers. Rather, they should be used in logical expressions such as \"do this if this and that, or do that if this and that\". We'll see more about it in another section.</p> <p>Division (/) always returns a float. To do floor division and get an integer result you can  use the // operator; to calculate the remainder you can use %: <pre><code>&gt;&gt;&gt;\n17 / 3  # classic division returns a float\n5.666666666666667\n&gt;&gt;&gt;\n17 // 3  # floor division discards the fractional part\n5\n17 % 3  # the % operator returns the remainder of the division\n2\n5 * 3 + 2  # floored quotient * divisor + remainder\n17\n</code></pre></p> <p>With Python, it is possible to use the ** operator to calculate powers:</p> <pre><code>&gt;&gt;&gt;\n5 ** 2  # 5 squared\n25\n2 ** 7  # 2 to the power of 7\n128\n</code></pre> <p>The equal sign <code>=</code> is used to assign a value to a variable. Afterwards, no result is displayed  before the next interactive prompt: <pre><code>&gt;&gt;&gt;\nwidth = 20\nheight = 5 * 9\nwidth * height\n900\n</code></pre></p> <p>If a variable is not \u201cdefined\u201d (assigned a value), trying to use it will give you an error:</p> <pre><code>&gt;&gt;&gt;\nn  # try to access an undefined variable\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'n' is not defined\n</code></pre> <p>There is full support for floating point; operators with mixed type operands convert the integer operand  to floating point: <pre><code>&gt;&gt;&gt;\n4 * 3.75 - 1\n14.0\n</code></pre> In interactive mode, the last printed expression is assigned to the variable _. This means that when you are using  Python as a desk calculator, it is somewhat easier to continue calculations, for example: <pre><code>&gt;&gt;&gt;\ntax = 12.5 / 100\nprice = 100.50\nprice * tax\n12.5625\nprice + _\n113.0625\nround(_, 2)\n113.06\n</code></pre></p> <p>This variable should be treated as read-only by the user. Don\u2019t explicitly assign a value to it \u2014 you would  create an independent local variable with the same name masking the built-in variable with its magic behavior.</p>"},{"location":"programming/python/python_introduction/#text","title":"Text","text":"<p>Python can manipulate text (represented by type <code>str</code>, so-called \u201cstrings\u201d) as well as numbers.  This includes characters \u201c!\u201d, words \u201crabbit\u201d, names \u201cParis\u201d, sentences \u201cGot your back.\u201d, etc. \u201cYay! :)\u201d.  They can be enclosed in single quotes ('...') or double quotes (\"...\") with the same result. <pre><code>&gt;&gt;&gt;\n'spam eggs'  # single quotes\n'spam eggs'\n\"Paris rabbit got your back :)! Yay!\"  # double quotes\n'Paris rabbit got your back :)! Yay!'\n'1975'  # digits and numerals enclosed in quotes are also strings\n'1975'\n</code></pre></p> <p>We should always use double quotes <code>\"...\"</code> as quotation marks (since they allo the use of <code>'</code> inside): <pre><code>&gt;&gt;&gt;\n\"doesn't need to\"  # ...use double quotes instead\n\"doesn't need to\"\n</code></pre></p> <p>In the Python shell, the string definition and output string can look different. The print()  function produces a more readable output, by omitting the enclosing quotes and by  printing escaped and special characters: <pre><code>&gt;&gt;&gt;\ns = 'First line.\\nSecond line.'  # \\n means newline\ns  # without print(), special characters are included in the string\n'First line.\\nSecond line.'\nprint(s)  # with print(), special characters are interpreted, so \\n produces new line\nFirst line.\nSecond line.\n</code></pre></p> <p>If you don\u2019t want characters prefaced by \\ to be interpreted as special characters, you can use raw  strings by adding an r before the first quote:</p> <pre><code>&gt;&gt;&gt;\nprint('C:\\some\\name')  # here \\n means newline!\nC:\\some\name\nprint(r'C:\\some\\name')  # note the r before the quote\nC:\\some\\name\n</code></pre> <p>String literals can span multiple lines. One way is using triple-quotes: <code>\"\"\"...\"\"\"</code>.  End of lines are automatically included in the string:</p> <pre><code>print(\"\"\"\\\nUsage: thingy [OPTIONS]\n     -h                        Display this usage message\n     -H hostname               Hostname to connect to\n\"\"\")\n</code></pre> <p>produces the following output (note that the initial newline is not included):</p> <pre><code>Usage: thingy [OPTIONS]\n-h                        Display this usage message\n-H hostname               Hostname to connect to\n</code></pre> <p>Strings can be concatenated (glued together) with the + operator, and repeated with *:</p> <pre><code>&gt;&gt;&gt;\n# 3 times 'un', followed by 'ium'\n3 * 'un' + 'ium'\n'unununium'\n</code></pre>"},{"location":"programming/python/python_introduction/#basic-python-functions","title":"Basic Python functions","text":"<p>We can find the complete set of Python built-in functions here. In this section we will only describe the most common and basic:</p>"},{"location":"programming/python/python_introduction/#type","title":"Type","text":"<p>The <code>type()</code> function is mostly used for debugging purposes. If a single argument <code>type(obj)</code> is passed,  it returns the type of the given object. </p> <pre><code>x = 10\nprint(type(x))\n# Output: &lt;class 'int'&gt;\n</code></pre>"},{"location":"programming/python/python_introduction/#length","title":"Length","text":"<p>The <code>len()</code> function returns the length of a data structure passed to it. We'll see more about it in coming sessions:</p> <pre><code>&gt;&gt;&gt; a = ['foo', 'bar', 'baz', 'qux']\n&gt;&gt;&gt; len(a)\n4\n</code></pre>"},{"location":"programming/python/python_introduction/#python-output","title":"Python Output","text":"<p>In Python, we can simply use the <code>print()</code> function to print output on the \"standard output\". For example, <pre><code>print('Python is powerful')\n# Output: Python is powerful\n</code></pre> Here, the <code>print()</code> function displays the string enclosed inside the single quotation. In the above code, the <code>print()</code> function is taking a single parameter (the actual syntax of  the print function accepts as much as 5 parameters, but if we really need them we can google it).</p> <p>We can also use the <code>print()</code> function to display the values of Python variables. We can do it in several ways, but the most convenient is the use of the <code>f-string</code>: 1. Prefix the string that we want to print with the letter <code>f</code>, as in <code>print(f\"some text here\")</code>.  2. Now, imagine that we have defined a variable before, as in     <pre><code>dog_name = \"Ruff\"\n</code></pre> 3. To use this variable with <code>print()</code> in an f-string we just need to call it like     <pre><code>print(f\"My dog name is {dog_name}\")\n# Output: My dog name is Ruff\n</code></pre> 4. We can insert as many variables as we like in an f-string:     <pre><code>age = 15\nhair_color = purple\nname = \"Amy\"\nprint(f\"My name is {name}, I'm {age} and have {hair_color} hair.\")\n# Output: My name is Amy, I'm 15 and have purple hair.\n</code></pre></p> <p>We can also join two strings together inside the <code>print()</code> statement. For example, <pre><code>print('This class is ' + 'awesome.')\n# Output: This class is awesome.\n</code></pre></p> <p>The <code>print()</code> function normally prints out one or more python items followed by a newline (but the ending character, which by default is <code>\\n</code>, can be changed.)</p>"},{"location":"programming/python/python_introduction/#python-input","title":"Python input","text":"<p>While programming, we might want to take the input from the user. In Python, we can use the <code>input()</code> function: <pre><code>input(prompt)\n</code></pre> Here, <code>prompt</code> is the string we wish to display on the screen and is optional.</p> <p>An example: <pre><code># using input() to take user input\nnum = input('Enter a number: ')\nprint('You Entered:', num)\nprint('Data type of num:', type(num))\n</code></pre> Output: <pre><code>Output\nEnter a number: 10\nYou Entered: 10\nData type of num: &lt;class 'str'&gt;\n</code></pre> In the above example, we have used the <code>input()</code> function to take input from the user  and stored the user input in the num variable.</p> <p>It is important to note that the entered value 10 is a <code>string</code>, not a <code>number</code>. So, type(num)  returns . If we want to convert the string to a number, we should do it explicitly, like: <pre><code>age = input(\"Enter your age: \")\nage = int(age)\n</code></pre>"},{"location":"programming/python/python_introduction/#basic-python-operators","title":"Basic Python operators","text":""},{"location":"programming/python/python_introduction/#python-arithmetic-operators","title":"Python Arithmetic Operators","text":"<p>Arithmetic operators are used to perform mathematical operations like addition, subtraction,  multiplication, etc. For example,</p> <pre><code>a = 7\nb = 2\n# addition\nprint ('Sum: ', a + b)  \n# subtraction\nprint ('Subtraction: ', a - b)   \n# multiplication\nprint ('Multiplication: ', a * b)  \n# division\nprint ('Division: ', a / b) \n# floor division\nprint ('Floor Division: ', a // b)\n# modulo\nprint ('Modulo: ', a % b)  \n# a to the power b\nprint ('Power: ', a ** b)   \n</code></pre> <p>Output: <pre><code>Sum: 9\nSubtraction: 5\nMultiplication: 14\nDivision: 3.5\nFloor Division: 3\nModulo: 1\nPower: 49\n</code></pre></p>"},{"location":"programming/python/python_introduction/#assignment-operators","title":"Assignment operators","text":"<p>Assignment operators are used to assign values to variables. For example,</p> <p><pre><code># assign 5 to x \nvar x = 5\n</code></pre> Here, <code>=</code> is an assignment operator that assigns 5 to x. Some extra examples: <pre><code># assign 10 to a\na = 10\n# assign 5 to b\nb = 5 \n# assign the sum of a and b to a\na += b      # a = a + b\nprint(a)\n# Output: 15\n</code></pre></p>"},{"location":"programming/python/python_introduction/#python-comparison-operators","title":"Python Comparison Operators","text":"<p>Comparison operators compare two values/variables and return a boolean result: <code>True</code> or <code>False</code>.  For example,</p> <pre><code>a = 5\nb = 2\n# equal to operator\nprint('a == b =', a == b)\n# not equal to operator\nprint('a != b =', a != b)\n# greater than operator\nprint('a &gt; b =', a &gt; b)\n# less than operator\nprint('a &lt; b =', a &lt; b)\n# greater than or equal to operator\nprint('a &gt;= b =', a &gt;= b)\n# less than or equal to operator\nprint('a &lt;= b =', a &lt;= b)\n</code></pre>"},{"location":"programming/python/python_introduction/#python-logical-operators","title":"Python Logical Operators","text":"<p>Logical operators are used to check whether an expression is <code>True</code> or <code>False</code>.  They are used in decision-making. For example, <pre><code># logical AND\nprint(True and True)     # True\nprint(True and False)    # False\n# logical OR\nprint(True or False)     # True\n# logical NOT\nprint(not True)          # False\n</code></pre> Python also offers some special types of operators, like the identity operator and the membership operator.  In Python, <code>is</code> and <code>is not</code> are used to check if two values are located on the same part of the memory: <pre><code>x1 = 5\ny1 = 5\nx2 = 'Hello'\ny2 = 'Hello'\nx3 = [1,2,3]\ny3 = [1,2,3]\nprint(x1 is not y1)  # prints False\nprint(x2 is y2)  # prints True\nprint(x3 is y3)  # prints False\n</code></pre> <code>in</code> and <code>not in</code> are the membership operators. They are used to test whether a value or  variable is found in a sequence (string, list, tuple, set and dictionary):</p> <pre><code>x = 'Hello world'\ny = {1:'a', 2:'b'}\n# check if 'H' is present in x string\nprint('H' in x)  # prints True\n# check if 'hello' is present in x string\nprint('hello' not in x)  # prints True\n# check if '1' key is present in y\nprint(1 in y)  # prints True\n# check if 'a' key is present in y\nprint('a' in y)  # prints False\n</code></pre>"},{"location":"programming/python/python_packages/","title":"Python packages","text":""},{"location":"programming/python/python_packages/#package-distribution","title":"Package distribution","text":"<p>A <code>.whl</code> (wheel) file is a distribution package file saved in Python\u2019s wheel format. It is a standard format  installation of Python distributions and contains all the files and metadata required for installation.  The WHL file also contains information about the Python versions and platforms supported by this wheel file.  WHL file format is a ready-to-install format that allows running the installation package without building the  source distribution.</p> <p>Note</p> <ul> <li>All else being equal, wheels are typically smaller in size than source distributions.</li> <li>Installing from wheels directly avoids the intermediate step of building packages off of  the source distribution.</li> </ul> <p>A <code>.whl</code> file is essentially a zip archive with a specially crafted filename that tells installers what  Python versions and platforms the wheel will support.</p>"},{"location":"programming/python/python_programs/","title":"Python programs","text":""},{"location":"programming/python/python_programs/#python-programs_1","title":"Python programs","text":"<p>If you quit from the Python interpreter and enter it again, the definitions you have made  (functions and variables) are lost. Therefore, if you want to write a somewhat longer program,  you are better off using a text editor to prepare the input for the interpreter and running it  with that file as input instead. This is known as creating a script. As your program gets longer,  you may want to split it into several files for easier maintenance. You may also want to use a  handy function that you\u2019ve written in several programs without copying its definition into each program.</p> <p>What we want to make is a Python module: a file containing Python definitions and statements.  The file name is the module name  with the suffix <code>.py</code> appended. Within a module, the module\u2019s name (as a string) is available as  the value of the global variable <code>__name__</code>. </p>"},{"location":"programming/python/python_programs/#the-import-statement","title":"The import Statement","text":"<p>Python modules start by importing code from other modules, if necessary.  The import statement takes many different forms, but the simplest form is the one already shown above: <pre><code>import some_module\n</code></pre></p> <p>We can then access the contents of the module (for example, an imaginary <code>some_function</code> from <code>some_module</code>) like so: <pre><code>a = some_module.some_function()\n</code></pre></p> <p>An alternate form of the import statement allows individual objects from the module to be imported  directly into the caller\u2019s symbol table: <pre><code>from &lt;module_name&gt; import &lt;name(s)&gt;\n</code></pre></p> <p>Following execution of the above statement,  can be referenced in the caller\u2019s environment  without the  prefix: <pre><code>&gt;&gt;&gt; from mod import s\n&gt;&gt;&gt; s\n'If Comrade Napoleon says it, it must be right.'\n&gt;&gt;&gt; from math import e\n&gt;&gt;&gt; e\n2.718281828459045\n</code></pre> Because this form of import places the object names directly into the caller\u2019s symbol table,  any objects that already exist with the same name will be overwritten: <pre><code>&gt;&gt;&gt; a = ['foo', 'bar', 'baz']\n&gt;&gt;&gt; a\n['foo', 'bar', 'baz']\n&gt;&gt;&gt; from mod import a\n&gt;&gt;&gt; a\n[100, 200, 300]\n</code></pre> It is also possible to import individual objects but enter them into the local symbol  table with alternate names: <pre><code>from &lt;module_name&gt; import &lt;name&gt; as &lt;alt_name&gt;[, &lt;name&gt; as &lt;alt_name&gt; \u2026]\n</code></pre> This makes it possible to place names directly into the local symbol table but avoid conflicts with previously existing names: <pre><code>&gt;&gt;&gt; s = 'foo'\n&gt;&gt;&gt; a = ['foo', 'bar', 'baz']\n&gt;&gt;&gt; from mod import s as string, a as alist\n&gt;&gt;&gt; s\n'foo'\n&gt;&gt;&gt; string\n'If Comrade Napoleon says it, it must be right.'\n&gt;&gt;&gt; a\n['foo', 'bar', 'baz']\n&gt;&gt;&gt; alist\n[100, 200, 300]\n</code></pre> <p>Finally, you can also import an entire module under an alternate name:</p> <pre><code>import &lt;module_name&gt; as &lt;alt_name&gt;\n&gt;&gt;&gt; import mod as my_module\n&gt;&gt;&gt; my_module.a\n[100, 200, 300]\n&gt;&gt;&gt; my_module.foo('qux')\narg = qux\n</code></pre>"},{"location":"programming/python/python_programs/#definitions","title":"Definitions","text":"<p>The central part of the Python module are function and class definitions. Hence, so far a module could  look like this</p> <pre><code>import math as m\ndef silly_function(a: int) -&gt; int:\n\"\"\"Some description.\"\"\"\nb = m.cos(a)**2\nreturn b\n</code></pre>"},{"location":"programming/python/python_programs/#script","title":"Script","text":"<p>Our module, so far, only has imports and definitions. This means that it does not do anything. We can add some function calls (anything that is not inside a definition of a function or a class gets actually executed) in the last section of the file: </p> <pre><code>import math as m\ndef silly_function(a: int) -&gt; int:\n\"\"\"Some description.\"\"\"\nb = m.cos(a)**2\nreturn b\nprint(\"This will be executed.\")\nvar = silly_function(2)\nprint(f\"The result is {var}.\")\n</code></pre> <p>Note</p> <p>Even though the structure above is the standard, in principle you can order your code however you want. Just bear in mind that code starts executing from the beginning of the file and then goes down line by line. So if there is a script section in the middle of the file that makes use of something that hasn't  been defined yet, it will not work.</p>"},{"location":"programming/python/python_programs/#running-scripts-from-the-terminal","title":"Running scripts from the terminal","text":"<p>Any <code>.py</code> file that contains a module is essentially a Python script. Therefore, let's save our newly created module as <code>test.py</code> inside a folder. To run the script, we need to open a terminal, go to the  folder where the file is located and then run</p> <p><pre><code>/home/gerard/documents&gt; python3 test.py\n</code></pre> or, in Windows, <pre><code>C:\\Users\\gerard\\Documents&gt; python test.py\n</code></pre></p>"},{"location":"programming/python_libraries/matplotlib/","title":"Matplotlib","text":""},{"location":"programming/python_libraries/matplotlib/#matplotlib","title":"Matplotlib","text":"<p>Coming soon.</p>"},{"location":"programming/python_libraries/numpy/","title":"Numpy","text":""},{"location":"programming/python_libraries/numpy/#numpy","title":"Numpy","text":"<p>Coming soon.</p>"},{"location":"programming/python_libraries/pandas/","title":"Pandas","text":""},{"location":"programming/python_libraries/pandas/#introduction","title":"Introduction","text":"<p>Pandas is a high-level data manipulation tool built with the Numpy package. Its key data structure is called the  DataFrame, which allow us to store and manipulate tabular data (we can think of the rows as different \"observations\"  and the columns as the variables).</p> <p>Note</p> <p>Intuitively, pandas DataFrames can be thought of as a way to hold Excel spreadsheets data in a Python object.</p> <p>Since Pandas is not part of the standard Python library, we will need to install it first in the virtual  environment, for instance with <code>pip</code>:</p> <pre><code>pip install pandas\n</code></pre> <p>Once we have it installed, to use it in the code will need to import it with</p> <pre><code>import pandas\n# Code here\n...\n</code></pre> <p>Note</p> <p>Often, pandas is renamed to <code>pd</code> in the import, as: <pre><code>import pandas as pd\n</code></pre> This is of course not mandatory, but very common.    </p> <p>After importing the package, we can start using its most important object, the DataFrame.  There are several ways to create a DataFrame, for example:</p> <p><pre><code>dict = {\"country\": [\"Brazil\", \"Russia\", \"India\", \"China\", \"South Africa\"],\n\"capital\": [\"Brasilia\", \"Moscow\", \"New Dehli\", \"Beijing\", \"Pretoria\"],\n\"area\": [8.516, 17.10, 3.286, 9.597, 1.221],\n\"population\": [200.4, 143.5, 1252, 1357, 52.98] }\nimport pandas as pd\nbrics = pd.DataFrame(dict)\nprint(brics)\n</code></pre> which outputs <pre><code>     area    capital       country  population\n0   8.516   Brasilia        Brazil      200.40\n1  17.100     Moscow        Russia      143.50\n2   3.286  New Dehli         India     1252.00\n3   9.597    Beijing         China     1357.00\n4   1.221   Pretoria  South Africa       52.98\n</code></pre></p> <p>Note</p> <p>If you want a nice, complete introduction and walkthrough to Pandas, it is recommended to check the official documentation's own guide. The notes in this page are not comprehensive.</p>"},{"location":"programming/python_libraries/pandas/#pandas-vs-excel","title":"Pandas vs. Excel","text":"<p>Tasks such as data cleaning, data normalization, visualization, and statistical analysis can be performed on  both Excel and Pandas. That being said, Pandas has some major benefits over Excel:</p> <ul> <li>Limitation by size: Excel can handle around 1 million rows, while Python can handle millions and millions of rows  (the limitation is on PC computing power and memory).</li> <li>Complex data transformation: Memory-intensive computations in Excel can crash a workbook.  Python can handle complex computations without major problems.</li> <li>Automation: Excel was not designed to automate tasks. You can create a macro or use VBA to simplify some tasks,  but Python is a general programming language (meaning we can program almost anything).</li> </ul>"},{"location":"programming/python_libraries/pandas/#basic-objects-series-and-dataframes","title":"Basic objects: Series and Dataframes","text":"<p>Fundamentally, Pandas has two main objects that we will be using: </p> <ul> <li>Pandas Series are one-dimensional labeled arrays capable of holding any data  type (integers, strings, floating point numbers, Python objects, etc.). We can think of a Pandas Series as a single \"column\" of a table.</li> <li>Pandas Dataframes are 2-dimensional labeled data structures with columns of potentially different  types. We can think of it like a spreadsheet or SQL table, or a dict of Series objects. </li> </ul> <p>Note</p> <p>In general we will only be using Pandas Dataframes, which are the most commonly used pandas object. However, since Pandas Dataframes are a collection of Pandas Series, Series will appear often as the result of using some of the methods of Dataframes.</p>"},{"location":"programming/python_libraries/pandas/#series-creation","title":"Series creation","text":"<p>In a Series object, the axis labels are collectively referred to as the index. The basic method  to create a Series is to call:</p> <pre><code>s = pd.Series(data, index=index)\n</code></pre> <p>Here, data can be many different things, for example:</p> <ul> <li>A Python dict or list</li> <li>A scalar value</li> <li>A numpy array</li> </ul> <p>If <code>data</code> is a numpy array, index must be the same length as data. If no index is passed,  one will be created having values <code>[0, ..., len(data) - 1]</code>.</p> <pre><code>s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])\ns\nOut[4]: \na    0.469112\nb   -0.282863\nc   -1.509059\nd   -1.135632\ne    1.212112\ndtype: float64\ns.index\nOut[5]: Index(['a', 'b', 'c', 'd', 'e'], dtype='object')\npd.Series(np.random.randn(5))\nOut[6]: \n0   -0.173215\n1    0.119209\n2   -1.044236\n3   -0.861849\n4   -2.104569\ndtype: float64\n</code></pre>"},{"location":"programming/python_libraries/pandas/#dataframe-creation","title":"Dataframe creation","text":"<p>DataFrames are, in practice, a dictionary of columns. That's why column labels must be unique.  Each column corresponds to a <code>Series</code>, and different columns can be of different type. Rows are  identified by an index, shared by all the columns (and may be non-unique). </p> <p>To instantiate a DataFrame we may use different kinds of input, such as:</p> <ul> <li> <p>A <code>dict</code> of 1D objects: Numpy arrays, lists, dicts, or Series. In any case, the arrays must all be the same length.  If an index is passed, it must also be the same length as the arrays. If no index is passed, the result will be  <code>range(n)</code>, where <code>n</code> is the array length:</p> <pre><code>d = {\"one\": [1.0, 2.0, 3.0, 4.0], \"two\": [4.0, 3.0, 2.0, 1.0]}\npd.DataFrame(d)\nOut[46]: \none  two\n0  1.0  4.0\n1  2.0  3.0\n2  3.0  2.0\n3  4.0  1.0\npd.DataFrame(d, index=[\"a\", \"b\", \"c\", \"d\"])\nOut[47]: \none  two\na  1.0  4.0\nb  2.0  3.0\nc  3.0  2.0\nd  4.0  1.0\n</code></pre> </li> <li> <p>From a list of dicts (where each dict has the same keys, which correspond to the DataFrame-to-be columns):</p> <pre><code>In [53]: data2 = [{\"a\": 1, \"b\": 2}, {\"a\": 5, \"b\": 10, \"c\": 20}]\nIn [54]: pd.DataFrame(data2)\nOut[54]: \na   b     c\n0  1   2   NaN\n1  5  10  20.0\nIn [55]: pd.DataFrame(data2, index=[\"first\", \"second\"])\nOut[55]: \na   b     c\nfirst   1   2   NaN\nsecond  5  10  20.0\nIn [56]: pd.DataFrame(data2, columns=[\"a\", \"b\"])\nOut[56]: \na   b\n0  1   2\n1  5  10\n</code></pre> </li> <li> <p>Tables from a <code>.csv</code> file or Excel file (e.g., <code>.xlsx</code>)</p> </li> <li>A single Pandas Series</li> <li>2-D numpy.ndarray</li> </ul> <p>In any case, the DataFrame construction always follows the same syntax: <pre><code>import pandas as pd\n# suppose \"a\" is a Python object type that can be converted to a DataFrame\na = ...\n# DataFrame object creation\ndf = pd.DataFrame(a)\n</code></pre></p> <p>Note</p> <p>Although Series are 1D, nothing prevents us from converting a Pandas Series into a Pandas DataFrame. This is often very convenient since DataFrames and Series do not have the same methods available.</p>"},{"location":"programming/python_libraries/pandas/#readingwriting-dataframes","title":"Reading/writing dataframes","text":"<p>Dataframes are very useful, but how can we transfer tabular information between different Python sessions?</p> <p>Note</p> <p>Remember that information stored in Python objects disappears once the current execution is finished.</p> <p>The most common way to achieve this is to save the tables in files. These files can be reused in future executions, or transferred through the internet (this is mostly how we download datasets from the internet).</p> <p>A simple way to store big data sets is to use <code>.csv</code> files (comma separated files). CSV files contain plain text and is a well known format that can be read by everyone (including Pandas).</p>"},{"location":"programming/python_libraries/pandas/#reading-from-a-csv","title":"Reading from a CSV","text":"<p>Reading from a CSV is as easy as:</p> <pre><code>import pandas as pd\ndf = pd.read_csv('data.csv')\nprint(df.to_string()) \n# Output\nDuration  Pulse  Maxpulse  Calories\n0          60    110       130     409.1\n1          60    117       145     479.0\n2          60    103       135     340.0\n3          45    109       175     282.4\n</code></pre> <p>If the file has a header, or uses different characters (instead of commas), the pandas documentation has several examples on how to use the <code>.read_csv()</code> method.</p> <p>Note</p> <p>In the previous example, the <code>to_string()</code> method is not really necessary. This method is used to make sure that we are printing the whole DataFrame (otherwise, if it has many columns and rows,  pandas might shorten it when we try to print).</p>"},{"location":"programming/python_libraries/pandas/#saving-to-a-csv","title":"Saving to a CSV","text":"<p>Saving an already existing DataFrame <code>df</code> into a <code>.csv</code> can be accomplished with:</p> <pre><code>df.to_csv('file_name.csv')\n</code></pre> <p>If you want to export without the index, simply add index=False;</p> <pre><code>df.to_csv('file_name.csv', index=False)\n</code></pre> <p>If you get a <code>UnicodeEncodeError</code>, simply add encoding='utf-8':</p> <pre><code>df.to_csv('file_name.csv', encoding='utf-8')\n</code></pre>"},{"location":"programming/python_libraries/pandas/#viewing-dataframes","title":"Viewing DataFrames","text":"<p>To view the contents of a DataFrame, we can use one of several options:</p> <ul> <li>Using the <code>print(some_dataframe)</code> function</li> <li>To view the top of a dataframe, use <code>DataFrame.head()</code></li> <li>To view the bottom of a dataframe, use <code>DataFrame.tail()</code></li> </ul> <pre><code>In [13]: df.head()\nOut[13]: \nA         B         C         D\n2013-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2013-01-02  1.212112 -0.173215  0.119209 -1.044236\n2013-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\nIn [14]: df.tail(3)\nOut[14]: \nA         B         C         D\n2013-01-04  0.721555 -0.706771 -1.039575  0.271860\n2013-01-05 -0.424972  0.567020  0.276232 -1.087401\n2013-01-06 -0.673690  0.113648 -1.478427  0.524988\n</code></pre> <p>We can also explore the data with an IDE such as PyCharm, or we can export the DataFrame to a <code>.csv</code> file  and open it with a spreadsheet editor.</p>"},{"location":"programming/python_libraries/pandas/#accessing-data-in-a-dataframe","title":"Accessing data in a DataFrame","text":"<p>There are 3 options to access the data of a pandas object:</p> <ul> <li><code>[]</code>, the \"standard getter\" which is highly overloaded</li> <li><code>.loc[]</code>, label based selector</li> <li><code>.iloc[],</code> integer location based selector</li> </ul> <p>Note</p> <p>The <code>[]</code> operator is highly overloaded and its use is discouraged. Use <code>.loc[]</code> and <code>.iloc[]</code> whenever possible.</p>"},{"location":"programming/python_libraries/pandas/#accessing-data-in-one-ore-more-columns","title":"Accessing data in one ore more columns","text":"<p>We can either use the standard getter <code>[]</code> or <code>.loc[]</code>.</p> <p>With the standard getter it works like this (the return type is another DataFrame):</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30], 4.5: [\"Alice\", \"Eve\", \"Bob\"]},\nindex=[\"a\", \"b\", \"b\"],\n)\n&gt;&gt;&gt; my_dataframe[[4.5]]\n4.5\na  Alice\nb    Eve\nb    Bob\n&gt;&gt;&gt; my_dataframe[[4.5, \"colA\"]]\n4.5  colA\na  Alice    10\nb    Eve    20\nb    Bob    30\n</code></pre> <p>To select columns with the <code>.loc[]</code> operator we use the syntax <code>my_dataframe.loc[:, col_selector]</code>.  The <code>:</code> indicates that we want to select all rows (more on that later), and <code>col_selector</code> should be a list of the columns that we want to select:</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30, 40], 4.5: [\"Alice\", \"Eve\", \"Bob\", \"Charlie\"]},\nindex=[\"a\", \"b\", \"b\", \"c\"],\n)\n&gt;&gt;&gt; my_dataframe.loc[:, [4.5]]  # returns a DataFrame\n4.5\na  Alice\nb    Eve\nb    Bob\nc    Charlie\n&gt;&gt;&gt; my_dataframe.loc[:, [4.5, \"colA\"]]  # returns a DataFrame\n4.5  colA\na  Alice     10\nb    Eve     20\nb    Bob     30\nc    Charlie 40\n</code></pre> <p>Note</p> <p>In both examples we could have used a column name, instead of a list of column names,  as a selector. In this case, the return type, instead of a DataFrame, would be a Pandas Series. In general, try to avoid working with Series whenever possible and only use methods that return DataFrames.</p>"},{"location":"programming/python_libraries/pandas/#slicing","title":"Slicing","text":"<p>Slices act on row index, and are a way to access data from row X to row Y following the same  logic as explained before: a slice <code>[1:3]</code> will return all members from 1 to 3, except for the last one (i.e., 3 will be excluded). The return is a DataFrame:</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30, 40], 4.5: [\"Alice\", \"Eve\", \"Bob\", \"Charlie\"]},\nindex=[\"a\", \"b\", \"b\", \"c\"],\n)\n&gt;&gt;&gt; my_dataframe[1:3]\ncolA  4.5\nb    20  Eve\nb    30  Bob\n&gt;&gt;&gt; my_dataframe[:\"b\"]\ncolA    4.5\na    10  Alice\nb    20    Eve\nb    30    Bob\n</code></pre>"},{"location":"programming/python_libraries/pandas/#selecting-rows-and-columns-at-the-same-time","title":"Selecting rows and columns at the same time","text":"<p>To select rows with the <code>.loc[]</code> operator we use the syntax <code>my_dataframe.loc[row_selector, column_selector]</code>.  As before, <code>column_selector</code> can be <code>:</code>, which indicates that we want to select all columns (but we could also  put in here any list of columns we want).</p> <p>Note</p> <p><code>my_dataframe.loc[row_selector, :]</code> can also be written as <code>my_dataframe.loc[row_selector]</code>, without the <code>:</code>. However, the first version is more explicit, and so its use is recommended.</p> <p>We can select rows based on row name, row subset (by using a list, as with columns), a slice or, interestingly, based on boolean conditions:</p> <pre><code>my_dataframe = pd.DataFrame(\n{\"colA\": [10, 20, 30, 40], 4.5: [\"Alice\", \"Eve\", \"Bob\", \"Charlie\"]},\nindex=[\"a\", \"b\", \"b\", \"c\"],\n)\n&gt;&gt;&gt; my_dataframe.loc[[\"c\", \"a\"], :]\ncolA      4.5\nc    40  Charlie\na    10    Alice\n&gt;&gt;&gt; my_dataframe.loc[3:2, :]\ncolA      4.5\n3    20      Eve\n1    30      Bob\n2    40  Charlie\n&gt;&gt;&gt; my_dataframe.loc[my_dataframe[\"colA\"] &gt; 30, 4.5]\n4.5\nc  Charlie \n</code></pre> <p>Note</p> <p>In the last example we have used a simple \"greater than\" boolean condition to select data in the DataFrame, but we can make this boolean condition as sophisticated or complex as we want, for example <pre><code>df.loc[(df[\"a\"] &gt; 0) &amp; (df[\"b\"] == df[\"d\"]), [\"a\", \"c\", \"g\"]\n</code></pre></p>"},{"location":"programming/python_libraries/pandas/#accessing-data-from-its-location-on-the-dataframe","title":"Accessing data from its location on the DataFrame","text":"<p>The <code>.iloc[]</code> operator works the same as <code>.loc[]</code>, but on integer location of rows and also columns.  The syntax is the same, <code>my_dataframe[row_selector, column_selector]</code> and you can use <code>:</code> to indicate all rows or columns.</p>"},{"location":"programming/python_libraries/pandas/#column-selectors","title":"Column selectors","text":"<ul> <li>Selecting a single column (<code>my_dataframe.iloc[:, 1]</code>) always returns a Series.</li> <li>Selecting a list of columns (<code>my_dataframe.iloc[:, [1]]</code>) always returns a DataFrame.</li> </ul>"},{"location":"programming/python_libraries/pandas/#row-selectors","title":"Row selectors","text":"<ul> <li>Selecting a single integer position (<code>my_dataframe.iloc[1, :]</code>) always returns a Series.</li> <li>Selecting with a list of integer positions (<code>my_dataframe.iloc[[1, 5], :]</code>) always returns a DataFrame.</li> <li>Selecting with a slice of integer positions (<code>my_dataframe.iloc[1:4, :]</code>) always returns a DataFrame.  Recall that the upper limit is excluded.</li> <li>Selecting with a list of boolean indexes (<code>my_dataframe.iloc[1:4, :]</code>) always returns a DataFrame</li> </ul>"},{"location":"programming/python_libraries/pandas/#setting-new-values-on-a-dataframe","title":"Setting new values on a DataFrame","text":"<p>We can use the same methods that have been shown to access data to set new values to the DataFrame. We just need to put the dataframe cell selection on the left side of a Python assignment, for example:</p> <pre><code># this assigns the value 10 to all cells in the column \"D\"\ndf.loc[:, \"D\"] = 10\n# this assigns the value 0 to all cells with negative values\ndf.loc[df &lt; 0, :] = 0\n</code></pre>"},{"location":"programming/python_libraries/pandas/#working-with-dataframes","title":"Working with DataFrames","text":"<p>This section describes very common methods or tasks that you will be performing with pandas DataFrames. Before we start, however, one word of caution: DataFrames are objects, that derive from the  <code>pandas.DataFrame</code> class. As objects, they have a lot of available methods that have been implemented for the class, and we may think that when we call one of this methods, the original DataFrame might be modified (since, after all, methods can change the attributes of the class). However, in pandas this is not the case. </p> <p>Note</p> <p>By default, in pandas, dataframe operations return a copy of the dataframe and leave the original  dataframe data intact.</p> <p>Let's see this with an example. Assume we have the following dataframe <code>df</code>: <pre><code>print(df)\n# Output\ncol1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n</code></pre> If we sort it by <code>col1</code> and then print <code>df</code> again, the result will not change: <pre><code>df.sort_values(by=['col1'])\nprint(df)\n# Output\ncol1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n</code></pre> This is because these methods do not change the internal state (i.e., its attributes) of the <code>df</code> instance. Hence, if we want to use the output of this method, we will need to save the <code>return</code> output of this methods to another variable (or chain it):</p> <pre><code>new_df = df.sort_values(by=['col1'])\nprint(new_df)\n# Output\ncol1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\n</code></pre> <p>Hence, if we want to \"update\" the DataFrame after a change, we will need to assign the output of the method to the original variable, like:</p> <pre><code>new_df = df.sort_values(by=['col1'])\n</code></pre> <p>Note</p> <p>We can make this functions modify the original dataframe with the optional parameter <code>inplace=True</code> (<code>False</code> is the default). However, in general its use is discouraged.</p>"},{"location":"programming/python_libraries/pandas/#common-tasks","title":"Common tasks","text":""},{"location":"programming/python_libraries/pandas/#finding-the-size-of-a-dataframe","title":"Finding the size of a DataFrame","text":"<ul> <li>To display the number of rows, columns, etc.: <code>df.info()</code></li> <li>To get the number of rows and columns: <code>df.shape</code></li> <li>To get the number of rows: <code>len(df)</code></li> <li>To get the number of columns: <code>len(df.columns)</code></li> </ul> <p>We also have access to an attribute <code>df.empty</code>, of <code>bool</code> type, which returns <code>True</code> if the DataFrame is empty and <code>False</code> otherwise.</p>"},{"location":"programming/python_libraries/pandas/#removing-duplicates","title":"Removing duplicates","text":"<p>Pandas <code>drop_duplicates()</code> method helps in removing duplicates from Pandas Dataframes.</p> <pre><code>import pandas as pd \ndata = { \n\"A\": [\"TeamA\", \"TeamB\", \"TeamB\", \"TeamC\", \"TeamA\"], \n\"B\": [50, 40, 40, 30, 50], \n\"C\": [True, False, False, False, True] \n} \ndf = pd.DataFrame(data) \nprint(df.drop_duplicates())\n# Output\nA       B      C\n0    TeamA    50    True\n1    TeamB    40    False\n3    TeamC    30    False\n</code></pre>"},{"location":"programming/python_libraries/pandas/#filling-missing-data","title":"Filling missing data","text":"<p>We can use the <code>.isna()</code> method to detect (and fill, if we need to) cells without values:</p> <pre><code>df.loc[df[\"a\"].isna(), :] = 0\n</code></pre> <p>Note</p> <p>The <code>.isnull()</code> method is an alias for the <code>.isna()</code> method, so both are exactly the same.</p> <p>Note</p> <p>Pandas primarily uses the value <code>np.nan</code> to represent missing data. Missing data is by default  not included in computations.</p>"},{"location":"programming/python_libraries/pandas/#resetting-the-index","title":"Resetting the index","text":"<p>After dropping and filtering the rows of a DataFrame, the original index values for each row remain.  If we want to re-create the index, dropping the original values, we can do it with <pre><code>DataFrame.reset_index(drop=True)\n</code></pre></p>"},{"location":"programming/python_libraries/pandas/#renaming-columns","title":"Renaming columns","text":"<p>To rename specific columns of a DataFrame, we may use the <code>df.rename()</code> method: <pre><code>df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'})\n</code></pre> Only the columns in the dictionary passed as input will be renamed.</p>"},{"location":"programming/python_libraries/pandas/#sorting","title":"Sorting","text":"<p>We can sort a DataFrame by the values of one or multiple columns, like so:</p> <pre><code>df.sort_values(by=['col1', 'col2'], ascending=True)\ncol1  col2  col3 col4\n1    A     1     1    B\n0    A     2     0    a\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\n</code></pre>"},{"location":"programming/python_libraries/pandas/#creating-new-columns","title":"Creating new columns","text":"<p>There are several ways to create a new column, but the most common one follow this syntax: <pre><code>df[\"new_column_name\"] = ...\n</code></pre> and on the <code>...</code> we can put whatever we want. For example, if we have a list <code>my_list</code> with the same length as the DataFrame has rows, we could do: <pre><code>df[\"new_column_name\"] = my_list\n</code></pre> Alternatively, we could create a new column using the values from other columns, for example: <pre><code>df[\"new_column\"] = df[\"A\"] + df[\"B\"]\n</code></pre></p>"},{"location":"programming/python_libraries/pandas/#counting-unique-values","title":"Counting unique values","text":"<p>The unique function in pandas is used to find the unique values from a series:</p> <pre><code>import pandas as pd\n# Creating a dataframe\ndf = pd.DataFrame({'Sports': ['Football', 'Cricket', 'Baseball', 'Basketball',\n'Tennis', 'Table-tennis', 'Archery', 'Swimming', 'Boxing'], \n'Player': [\"Messi\", \"Afridi\", \"Chad\", \"Johnny\", \"Federer\",\n\"Yong\", \"Mark\", \"Phelps\", \"Khan\"],\n'Country': [\"Argentina\", \"Pakistan\", \"England\", \"England\", \"Switzerland\",\n\"China\", \"China\", \"USA\", \"Pakistan\" ],\n'Rank': [1, 9, 7, 12, 1, 2, 11, 1, 1] })\n# Finding unique countries\nprint(df[\"Country\"].unique())\n# Finding unique rankings\nprint(df[\"Rank\"].unique())\n# Output\n['Argentina' 'Pakistan' 'England' 'Switzerland' 'China' 'USA']\n[1, 9, 7, 12, 2, 11]\n</code></pre>"},{"location":"programming/python_libraries/pandas/#pivoting-a-dataframe","title":"Pivoting a dataframe","text":"<p><code>pandas.melt()</code> unpivots a DataFrame from wide format to long format:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': {0: 'a', 1: 'b', 2: 'c'},\n...                    'B': {0: 1, 1: 3, 2: 5},\n...                    'C': {0: 2, 1: 4, 2: 6}})\n&gt;&gt;&gt; df\nA  B  C\n0  a  1  2\n1  b  3  4\n2  c  5  6\n&gt;&gt;&gt; pd.melt(df, id_vars=['A'], value_vars=['B', 'C'])\nA variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n3  a        C      2\n4  b        C      4\n5  c        C      6\n</code></pre>"},{"location":"programming/python_libraries/pandas/#basic-statistics","title":"Basic statistics","text":"<p>There are many statistical operations already implemented in pandas. We can use them by selecting a subset of the DataFrame (e.g., a few columns) and then calling these methods. Some of the most  important are:</p> <ul> <li>The mean: <code>some_df.mean()</code></li> <li>The median: <code>some_df.median()</code></li> <li>The standard deviation: <code>some_df.std()</code></li> <li>The min and max: <code>.min()</code> and <code>.max()</code></li> <li>The number of records for each category in a column:     <pre><code>In [12]: titanic[\"Pclass\"].value_counts()\nOut[12]: \nPclass\n3    491\n1    216\n2    184\nName: count, dtype: int64\n</code></pre></li> </ul> <p>There is also a helpful <code>.describe()</code> method that gives you several of these at the same time.</p>"},{"location":"programming/python_libraries/pandas/#applying-custom-functions","title":"Applying custom functions","text":"<p>The pandas DataFrame <code>apply()</code> function is used to apply a function along an axis of the DataFrame. This function that we apply can be an external or a custom defined function. It works like this:</p> <pre><code>import pandas as pd\ndf = pd.DataFrame({'A': [1, 2], 'B': [10, 20]})\ndef square(x):\nreturn x * x\ndf1 = df.apply(square)\nprint(df)\nprint(df1)\n# Output\nA   B\n0  1  10\n1  2  20\nA    B\n0  1  100\n1  4  400\n</code></pre> <p>Note</p> <p>We don't need to apply the function to the whole dataframe. We can slice it and only apply the function to a subset of the columns.</p> <p>If you look at the above example, our <code>square()</code> function is very simple. We can easily convert it  into a lambda function: <pre><code>df1 = df.apply(lambda x: x * x)\n</code></pre> The output will remain the same as in the last example.</p>"},{"location":"programming/python_libraries/pandas/#group-by","title":"Group by","text":"<p>The <code>groupby()</code> method is used for grouping the data according to the categories and applying a  function to aggregate them categories. This is easier seen with an example. Suppose that  we have the following dataframe:</p> <pre><code>import pandas as pd\nimport numpy as np\ndf = pd.DataFrame(\n{\n\"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n\"B\": [\"one\", \"one\", \"two\", \"three\", \"two\", \"two\", \"one\", \"three\"],\n\"C\": np.random.randn(8),\n\"D\": np.random.randn(8),\n}\n)\nprint(df)\n# Output\nA      B         C         D\n0  foo    one  0.845112  2.525473\n1  bar    one -0.485309  0.067261\n2  foo    two  1.106288  0.205404\n3  bar  three -0.958754  0.923104\n4  foo    two  2.033509 -0.436023\n5  bar    two -0.945948  0.869062\n6  foo    one -0.288766 -1.497993\n7  foo  three  0.344638 -0.786353\n</code></pre> <p>We can ask ourselves what happens if we combine the data from all the columns that share values in the columns <code>A</code> and <code>B</code> (e.g., all the columns that have <code>foo</code> in column <code>A</code> and <code>bar</code> in  column <code>B</code>). </p> <p>For this we need what's known as an aggregating function. This function gives an answer to the following question: assume that I found all the rows that share values in <code>A</code> and <code>B</code> and, somehow, I want to group together the values in all the remaining columns. How do I do that? Do I calculate the mean of those values? The sum? The minimum?</p> <p>With Python's <code>groupby()</code> function we may use any aggregating function we want: the important thing to understand is that this function will be applied to the set defined by all rows where <code>A</code> and <code>B</code> are shared.</p> <p>Going back to the previous dataframe, and using the <code>sum()</code> function as an example, we could use it as:</p> <pre><code>df.groupby([\"A\", \"B\"], as_index=False).sum()\n# Output\nA      B         C         D\n0  bar    one -0.485309  0.067261\n1  bar  three -0.958754  0.923104\n2  bar    two -0.945948  0.869062\n3  foo    one  0.556346  1.027480\n4  foo  three  0.344638 -0.786353\n5  foo    two  3.139796 -0.230619\n</code></pre> <p>The syntax is always the same: <code>df.groupby(list_of_columns_used_to_classify, as_index=False).some_func()</code>, where <code>some_func()</code> is the function that is used to aggregate the columns that are not in <code>list_of_columns_used_to_classify</code>.</p> <p>Note</p> <p>In the last example the <code>as_index=False</code> is important. If we don't use it, then the group by will return a dataframe with a \"strange\" new index, created by the combination of the values of <code>A</code> and <code>B</code>.</p>"},{"location":"programming/python_libraries/pandas/#joins-and-merges","title":"Joins and merges","text":"<p>Pandas provides a single function, <code>merge()</code>, as the equivalent of standard SQL database join operations,  but in this case between DataFrames.</p> <p>Before getting into the details of how to use <code>merge()</code>, you should first understand the various forms of joins. The idea of a merge (or join, as is known in SQL) is that we have two tables, and we stitch them together on the basis of two columns (one from the first table, another from the second table) having the same value. The resulting merged table will be the first table glued with the second table, with the shared column acting as glue. This can be done in different ways:</p> <ul> <li>inner merge: the resulting merged table will contain all the rows from the original tables that found a      match in the other table, but all rows (from either table) that find no match are discarded.</li> <li>outer merge: the opposite of the previous case: every row from either table will appear in the merged table,     and if for some of them there is no match, we will get null values on the columns coming from the other table.</li> <li>left merge: this is an intermediate case between the inner and the outer merge. It behaves like the inner    merge, but we also keep the rows from the first (\"left\") table that have no matches.    </li> <li>right merge: like the left merge, but the table on the second table is acting as if it was the left table   (usually we don't use the right merge for anything, since we can perform a left merge with the two tables in    the opposite order).</li> </ul> <p>These are some examples on how to use the <code>merge()</code> function:</p> <pre><code>import pandas as pd\n#create DataFrame\ndf1 = pd.DataFrame({'team': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],\n'points': [18, 22, 19, 14, 14, 11, 20, 28]})\ndf2 = pd.DataFrame({'team': ['A', 'B', 'C', 'D', 'G', 'H', 'Z'],\n'assists': [4, 9, 14, 13, 10, 8, 15]})\n#view DataFrames\nprint(df1)\nteam  points\n0    A      18\n1    B      22\n2    C      19\n3    D      14\n4    E      14\n5    F      11\n6    G      20\n7    H      28\nprint(df2)\nteam  assists\n0    A        4\n1    B        9\n2    C       14\n3    D       13\n4    G       10\n5    H        8\n6    Z       15\ndf1.merge(df2, on='team', how='outer')\n# Output\nteam  points  assists\n0    A    18.0      4.0\n1    B    22.0      9.0\n2    C    19.0     14.0\n3    D    14.0     13.0\n4    E    14.0      NaN\n5    F    11.0      NaN\n6    G    20.0     10.0\n7    H    28.0      8.0\n8    Z     NaN     15.0\ndf1.merge(df2, on='team', how='left')\n# Output\nteam  points  assists\n0    A      18      4.0\n1    B      22      9.0\n2    C      19     14.0\n3    D      14     13.0\n4    E      14      NaN\n5    F      11      NaN\n6    G      20     10.0\n7    H      28      8.0\ndf1.merge(df2, on='team', how='inner')\n# Output\nteam  points  assists\n0    A      18        4\n1    B      22        9\n2    C      19       14\n3    D      14       13\n4    G      20       10\n5    H      28        8\n</code></pre>"},{"location":"programming/python_libraries/pandas/#concatenating-dataframes","title":"Concatenating DataFrames","text":"<p>If we have 2 or more DataFrames which share exactly the same columns, we can concatenate them like this:</p> <pre><code>In [1]: df1 = pd.DataFrame(\n...:     {\n...:         \"A\": [\"A0\", \"A1\", \"A2\", \"A3\"],\n...:         \"B\": [\"B0\", \"B1\", \"B2\", \"B3\"],\n...:         \"C\": [\"C0\", \"C1\", \"C2\", \"C3\"],\n...:         \"D\": [\"D0\", \"D1\", \"D2\", \"D3\"],\n...:     },\n...:     index=[0, 1, 2, 3],\n...: )\n...: \nIn [2]: df2 = pd.DataFrame(\n...:     {\n...:         \"A\": [\"A4\", \"A5\", \"A6\", \"A7\"],\n...:         \"B\": [\"B4\", \"B5\", \"B6\", \"B7\"],\n...:         \"C\": [\"C4\", \"C5\", \"C6\", \"C7\"],\n...:         \"D\": [\"D4\", \"D5\", \"D6\", \"D7\"],\n...:     },\n...:     index=[4, 5, 6, 7],\n...: )\n...: \nIn [3]: df3 = pd.DataFrame(\n...:     {\n...:         \"A\": [\"A8\", \"A9\", \"A10\", \"A11\"],\n...:         \"B\": [\"B8\", \"B9\", \"B10\", \"B11\"],\n...:         \"C\": [\"C8\", \"C9\", \"C10\", \"C11\"],\n...:         \"D\": [\"D8\", \"D9\", \"D10\", \"D11\"],\n...:     },\n...:     index=[8, 9, 10, 11],\n...: )\n...: \nIn [4]: frames = [df1, df2, df3]\nIn [5]: result = pd.concat(frames)\n</code></pre>"},{"location":"programming/python_libraries/pandas/#melt-from-untidy-to-tidy-data","title":"Melt: from untidy to tidy data","text":"<p>The <code>melt()</code> function is used to transform or reshape data in a dataframe, transforming it from  wide format to long format:</p> <pre><code>import pandas as pd\ndf = pd.DataFrame(\n{\n\"first\": [\"John\", \"Mary\"],\n\"last\": [\"Doe\", \"Bo\"],\n\"job\": [\"Nurse\", \"Economist\"],\n\"height\": [5.5, 6.0],\n\"weight\": [130, 150],\n}\n)\nmelt_df = df.melt(\nid_vars=[\"first\", \"last\"], \nvar_name=\"quantity\", \nvalue_vars=[\"height\", \"weight\"]\n)\nprint(\"\\n Unmelted: \")\nprint(df)\nprint(\"\\n Melted: \")\nprint(melt_df)\n# Output\nUnmelted: \nfirst  last  job         height  weight\n0  John   Doe   Nurse       5.5     130\n1  Mary   Bo    Economist   6.0     150\nMelted: \nfirst     last    quantity   value\n0     John      Doe     height     5.5\n1     Mary      Bo      height     6.0\n2     John      Doe     weight     130.0\n3     Mary      Bo      weight     150.0\n</code></pre>"},{"location":"programming/python_libraries/pandas/#variable-types-and-memory-usage","title":"Variable types and memory usage","text":"<p>A pandas DataFrame can have columns of different types. To find out what these are, we may use <code>df.dtypes</code>: <pre><code>print(df.dtypes)\n# Output\nfloat              float64\nint                  int64\ndatetime    datetime64[ns]\nstring              object\ndtype: object\n</code></pre></p> <p>Note</p> <p>For very large datasets, make sure that you are not using more bits than you need in the columns. You can transform the variable types, for example <code>int64</code> to <code>int16</code>, anytime.</p> <p>To actually learn how much RAM memory (in Bytes) we are using for a particular DataFrame, we may use the <code>df.memory_usage(deep=True)</code> function:</p> <pre><code>&gt;&gt;&gt; df.memory_usage(deep=True)\n(lists each column's full memory usage)\n&gt;&gt;&gt; df.memory_usage(deep=True).sum()\n462432\n</code></pre>"},{"location":"programming/python_libraries/pyspark/","title":"Pyspark","text":"<p>SESSION 23 (LIVE IN-PERSON) Pyspark (1) Limitations of Pandas. Introduction to PySpark, including setting up accounts/computers and how to use Python to interact with Spark SESSION 24 (LIVE IN-PERSON) PySpark (2) The fundamentals of using Resilient Distributed Dataset (RDDs) and mapping Filtering and sorting SESSION 25 (LIVE IN-PERSON) PySpark (3) RDD Actions and key/value datastores. SESSION 26 (LIVE IN-PERSON) Practice session In these sessions, we will be setting programming challenges and practicing what we have learnt in the course. Frank Kane's Taming Big Data with Apache Spark and Python \u2013 Chapters 2 - 3 SESSION 27 (LIVE IN-PERSON) Practice session In these sessions, we will be setting programming challenges and practicing what we have learnt in the course. 6 06th June 2023Frank Kane's Taming Big Data with Apache Spark and Python \u2013 Chapters 2 - 3</p>"},{"location":"programming/sql/sql/","title":"SQL","text":""},{"location":"programming/sql/sql/#introduction","title":"Introduction","text":""},{"location":"programming/sql/sql/#sql-database-engines","title":"SQL DataBase engines","text":""},{"location":"programming/sql/sql/#sql-language","title":"SQL language","text":""},{"location":"programming/sql/sql/#select-queries","title":"Select queries","text":"<p>Note</p> <p>Although it is common practice to put SQL reserved words in capital letters, in general it is not necessary.</p> <p>Query data in columns c1, c2 from a table <pre><code>SELECT c1, c2 FROM some_table;\n</code></pre> Query all rows and columns from a table <pre><code>SELECT * FROM some_table;\n</code></pre> Create aliases for tables/columns: Query all rows and columns from a table <pre><code>SELECT CustomerID AS ID, CustomerName AS Customer\nFROM some_table\n</code></pre> Access data from various tables: <pre><code>SELECT o.OrderID, c.CustomerName FROM Customers AS c, Orders AS o;\n</code></pre> Access data from various tables: <pre><code>SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address FROM Customers;\n</code></pre></p> <p>Note</p> <p>The table we query from does not need to be an existing table: it can be any form of  derived table, created by another <code>SELECT ...</code> statement. Typical ways to create this new tables to query from are Common Table Expressions (CTEs) and subqueries (just another <code>SELECT</code> statement between parentheses.</p>"},{"location":"programming/sql/sql/#where-clauses","title":"Where clauses","text":"<p>Query data and filter rows with a condition <pre><code>SELECT c1, c2 FROM t WHERE some_condition;\n</code></pre></p> <p>Note</p> <p><code>some_condition</code> can be of type <code>=</code> (e.g. <code>A = 3</code>), different <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, etc.  Conditions can be chained by <code>AND</code> and <code>OR</code> operators. They can also be of the type <code>in a set</code>, e.g.: <code>IN (value1, value2, ...);</code>, or equivalently in a derived table, <code>IN (SELECT ...)</code>.</p> <p>Query distinct rows from a table <pre><code>SELECT DISTINCT c1 FROM t WHERE condition;\n</code></pre></p> <p>Sort the result set in ascending or descending order <pre><code>SELECT c1, c2 FROM t ORDER BY c1 ASC [DESC];\n</code></pre></p> <p>Skip offset of rows and return the next n rows <pre><code>SELECT c1, c2 FROM t ORDER BY c1 LIMIT n OFFSET offset;\n</code></pre></p> <p>COUNT/AGGREGATES Group rows using an aggregate function <pre><code>SELECT c1, aggregate(c2) FROM t GROUP BY c1;\n</code></pre></p> <p>Aggregate functions are, essentially, COUNT. You can\u2019t use COUNT without telling by which  GROUP BY the rows should be aggregated (basically every other column that is not counted). E.g. <pre><code>SELECT etl_origin_id, creator, count(*) from etl_fragrances group by etl_origin_id, creator;\n</code></pre></p> <p>Inside a COUNT parentheses you can put a DISTINCT/ALL to count different appearances or all of them.</p> <p>Note</p> <p>The COUNT function returns the number of rows for which the expression evaluates to a non-null value.  (* is a special expression that is not evaluated, it simply returns the number of rows.)</p> <p>There are two additional modifiers for the expression: ALL and DISTINCT.  These determine whether duplicates are discarded. Since ALL is the default, your example is the same  as count(ALL 1), which means that duplicates are retained. Since the expression \"1\" evaluates to non-null  for every row, and since you are not removing duplicates, COUNT(1) should always return the same number as COUNT(*).</p> <p>Note</p> <p>Difference between HAVING and WHERE:  * HAVING is used to check conditions after the aggregation takes place.  * WHERE: is used to check conditions before the aggregation takes place.</p> <p>This code: <pre><code>select City, COUNT(*)\nFrom Address\nWhere State = 'MA'\nGroup By City\n</code></pre> Gives you a table of all cities in MA and the number of addresses in each city. This code: <pre><code>select City, COUNT(*)\nFrom Address\nWhere State = 'MA'\nGroup By City\nHaving COUNT(*)&gt;5\n</code></pre></p> <p>Gives you a table of cities in MA with more than 5 addresses and the number of addresses in each city.</p> <p>The CASE statement goes through conditions as and <code>if/elif</code> statement, and returns a column. E.g. <pre><code>SELECT OrderID, Quantity,\nCASE WHEN Quantity &gt; 30 THEN 'The quantity is greater than 30'\nWHEN Quantity = 30 THEN 'The quantity is 30'\nELSE 'The quantity is under 30'\nEND AS QuantityText\nFROM OrderDetails;\n</code></pre></p> <p>TABLE JOINS</p>"},{"location":"programming/sql/sql/#joins","title":"Joins","text":"<p>A join \u201csews\u201d together 2 tables, based on some condition (e.g. equality of a row): <pre><code>SELECT c1, c2 FROM t1 INNER JOIN t2 ON condition;\n</code></pre></p> <p>Joins can be of type:</p> <ul> <li>INNER (intersection of values)</li> <li>LEFT (Intersection + unpaired from left table)</li> <li>RIGHT (same with right table) or </li> <li>FULL OUTER (both).</li> </ul> <p>Combine rows from two queries <pre><code>SELECT c1, c2 FROM t1 UNION [ALL] SELECT c1, c2 FROM t2;\n</code></pre> Return the intersection of two queries <pre><code>SELECT c1, c2 FROM t1 INTERSECT SELECT c1, c2 FROM t2;\n</code></pre> Subtract a result set from another result set <pre><code>SELECT c1, c2 FROM t1 MINUS SELECT c1, c2 FROM t2;\n</code></pre></p> <p>MANIPULATING TABLES</p> <p>Create a new table: <pre><code>CREATE TABLE t (\nid INT PRIMARY KEY,\nname VARCHAR NOT NULL,\nprice INT DEFAULT 0\n);\n</code></pre> Delete the table from the database <pre><code>DROP TABLE t;\n</code></pre> Add a new column to the table <pre><code>ALTER TABLE t ADD column;\n</code></pre> Drop column c from the table <pre><code>ALTER TABLE t DROP COLUMN c;\n</code></pre></p>"},{"location":"programming/sql/sql/#table-constraints","title":"Table constraints","text":"<p>Constraints: rules for the data in a table. The following constraints are commonly used in SQL: * NOT NULL - Ensures that a column cannot have a NULL value * UNIQUE - Ensures that all values in a column are different * PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Uniquely identifies each row in a table * FOREIGN KEY - Prevents actions that would destroy links between tables * CHECK - Ensures that the values in a column satisfies a specific condition * DEFAULT - Sets a default value for a column if no value is specified * CREATE INDEX - Used to create and retrieve data from the database very quickly</p> <p>Add a constraint <pre><code>ALTER TABLE t ADD constraint;\n</code></pre> Drop a constraint <pre><code>ALTER TABLE t DROP constraint;\n</code></pre> Rename a table from t1 to t2 <pre><code>ALTER TABLE t1 RENAME TO t2;\n</code></pre> Rename column c1 to c2 <pre><code>ALTER TABLE t1 RENAME c1 TO c2 ;\n</code></pre> Remove all data in a table <pre><code>TRUNCATE TABLE t;\n</code></pre></p>"},{"location":"programming/sql/sql/#manipulating-data","title":"MANIPULATING DATA","text":"<p>Insert one row into a table <pre><code>INSERT INTO t(column_list)\nVALUES(value_list);\n</code></pre> Insert multiple rows into a table <pre><code>INSERT INTO t(column_list)\nVALUES (value_list), (value_list), \u2026;\n</code></pre> Insert rows from t2 into t1 <pre><code>INSERT INTO t1(column_list)\nSELECT column_list\nFROM t2;\n</code></pre></p> <p>Note</p> <p>INSERT operations on a table without any indices are fast because the new row can simply be  appended to the end of the table. It is an O(1) operation. Conversely, INSERT/UPDATE/DELETE  statements with indices are no longer simple. These operations render all indexes out-of-date,  and as such need to be reconstructed.</p> <p>The situation is reversed with SELECT statements: SELECT operations containing only non-key  fields in the WHERE clause on the same table will require a full table scan, an O(n) operation.  With indices, however, this operation becomes O(log(n)). </p> <p>Update new value in the column c1 for all rows <pre><code>UPDATE t\nSET c1 = new_value;\n</code></pre> Update values in the column c1, c2 that match the condition <pre><code>UPDATE t\nSET c1 = new_value, c2 = new_value\nWHERE condition;\n</code></pre> Delete all data in a table <pre><code>DELETE FROM t;\nDelete subset of rows in a table\nDELETE FROM t\nWHERE condition;\n</code></pre></p> <p>MISSING WITH, TIES, USING, partition by, TOP, computed, window function, coalesce a outer join, LIKE, LOCATE, With, exemples https://ploomber.io/blog/sql/ , union, returning</p>"},{"location":"programming/sql/sql/#group-by","title":"Group by","text":""},{"location":"programming/sql/sql/#table-management","title":"Table management","text":""},{"location":"programming/sql/sql/#connecting-to-sql-databases-from-python-programs","title":"Connecting to SQL Databases from Python programs","text":""},{"location":"programming/sql/sql/#readinginsert-to-a-sql-database-with-pandas","title":"Reading/insert to a SQL database with Pandas","text":""}]}